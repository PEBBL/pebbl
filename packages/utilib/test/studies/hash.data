// AbstractHeap.cpp
#ifdef __GNUC__
#pragma implementation
#endif
AbstractHeap::AbstractHeap(const char* nameBuff,
	   int initSize, 
	   int quantumChoice) :
	   Sense(increasing),
	   used(0),
	   allocated(initSize),
	   quantum(quantumChoice),
	   name(nameBuff)
if (!name)
tree = (new (AbstractHeapItem*[initSize])) - 1;
AbstractHeap::~AbstractHeap()
// We assume that the subclass has deleted the element information
delete[] (tree + 1);
void AbstractHeap::swap(int a,int b) 
register AbstractHeapItem* t1 = tree[a];
register AbstractHeapItem* t2 = tree[b];
tree[a] = t2;
tree[b] = t1;
t1->element=b;
t2->element=a;
moveEffect(t1);
moveEffect(t2);
int AbstractHeap::floatUp(int element)
int next;
while (((next = element >> 1) >= 1) && 
       ((Sense*compare(tree[element]->key(),tree[next]->key())) < 0))
  swap(element,next);
  element = next;
return element;
int AbstractHeap::sinkDown(int element)
int child;
while ((child = element << 1) <= used) 
  if ((child < used) && ((Sense*compare(tree[child+1]->key(),tree[child]->key()))<0))
     child++;
  if ((Sense*compare(tree[element]->key(),tree[child]->key()))<0)
     return(element);
  swap(element,child);
  element = child;
return element;
int AbstractHeap::refloatElement(int element)
int newLocation = floatUp(element);
if (newLocation == element)
   return sinkDown(element);
else
   return element;
void AbstractHeap::add(AbstractHeapItem* item) 
if (used == allocated) {
   if (quantum > 0) {
      allocated += quantum;
      AbstractHeapItem** oldTree = tree;
      tree = (new (AbstractHeapItem*[allocated])) - 1; 
      for (int i=1; i<=used; i++)
	tree[i] = oldTree[i];
      delete [] (oldTree + 1);
      }
   else 
   }
tree[++used] = item;
addEffect(item);
item->element=used;
moveEffect(item);
floatUp(used);
void AbstractHeap::remove(AbstractHeapItem* item, int& status) 
int element = item->element;
if ((element < 1) || (element > used)) {
   status=FALSE;
   return;
   }
#define TOMS_REORDER 1
#if TOMS_REORDER
removeEffect(item);
deleteElement(element);
#else
deleteElement(element);
removeEffect(item);
#endif
#undef TOMS_REORDER
if (element < used) {
   AbstractHeapItem* t = tree[used];
   tree[element] = t;
   used--;
   t->element=element;
   moveEffect(t);
   refloatElement(element);
   }
else
   used--;
status=TRUE;
int AbstractHeap::prune() 
int n = used;
while (n > (used >> 1)) {
  if (prunable(tree[n])) {
     AbstractHeapItem* item = tree[n];
     pruneEffect(item);
     deleteElement(n);
     if (n > used)
	n = used;
     }
  else 
     n--;
return used;
int AbstractHeap::write(ostream& os) const
os << size() << endl;
for (int i=1; i<=size(); i++) {
  write_item(os,member(i));
os << endl;
return OK;
             
int AbstractHeap::read(istream& is)
int Size;
is >> Size;
for (int i=1; i<=Size; i++) {
  AbstractHeapItem* item;
  read_item(is,item);
  add(item);
return OK;
}          
// AbstractSplayTree.cpp
#ifdef __GNUC__
#pragma implementation
#endif
#include <stdio.h>
#ifdef _MSC_VER
#endif
#define node_size(x)   (((x)==NULL) ? 0 : ((x)->size))
AbstractSplayTree::AbstractSplayTree(const char* nameBuff)
	: name(nameBuff)
t = NULL;
if (!name)
counter=0;
Sense = increasing;
// Splay using the key (which may or may not be in the tree.)
AbstractSplayTreeItem* AbstractSplayTree::splay(const void* key, 
						AbstractSplayTreeItem* t)
    AbstractSplayTreeItem N, *l, *r, *y;
    int comp, l_size, r_size;
    
    if (t == NULL) return t;
    comp = Sense*compare(key, t->Key());
    if (comp == 0) return t;
    N.left = N.right = NULL;
    l = r = &N;
    l_size = r_size = 0;
    while (1) {
        if (comp < 0) {
            if (t->left == NULL) break;
            if ((Sense*compare(key, t->left->Key())) < 0) {
                y = t->left;                           /* rotate right */
                t->left = y->right;
                y->right = t;
                t->size = node_size(t->left) + node_size(t->right) + 1;
                t = y;
                if (t->left == NULL) break;
            }
            r->left = t;                               /* link right */
            r = t;
            t = t->left;
            r_size += 1+ node_size(r->right);
        } else if (comp > 0) {
            if (t->right == NULL) break;
            if ((Sense*compare(key,t->right->Key())) > 0) {
                y = t->right;                          /* rotate left */
                t->right = y->left;
                y->left = t;
		t->size = node_size(t->left) + node_size(t->right) + 1;
                t = y;
                if (t->right == NULL) break;
            }
            l->right = t;                              /* link left */
            l = t;
            t = t->right;
            l_size += 1+ node_size(l->left);
        } else {
            break;
        }
        comp = Sense*compare(key, t->Key());
    }
    l_size += node_size(t->left);  /* Now l_size and r_size are the sizes of */
    r_size += node_size(t->right); /* the left and right trees we just built.*/
    t->size = l_size + r_size + 1;
    l->right = r->left = NULL;
    /* The following two loops correct the size fields of the right path  */
    /* from the left child of the root and the right path from the left   */
    /* child of the root.                                                 */
    for (y = N.right; y != NULL; y = y->right) {
        y->size = l_size;
        l_size -= 1+ node_size(y->left);
    }
    for (y = N.left; y != NULL; y = y->left) {
        y->size = r_size;
        r_size -= 1+ node_size(y->right);
    }
    l->right = t->left;                                /* assemble */
    r->left = t->right;
    t->left = N.right;
    t->right = N.left;
    return t;
// Insert item into the tree t, if it is not already there.
// Return a pointer to the resulting tree.               
void AbstractSplayTree::add(AbstractSplayTreeItem* newroot) {
    counter++;
    if (t == NULL) {
	newroot->left = newroot->right = NULL;
        }
    else {
	const void* key1 = newroot->Key();
	const void* key2 = t->Key();
        if ((Sense*compare(key1,key2)) < 0) {
	   newroot->left = t->left;
	   newroot->right = t;
	   t->left = NULL;
	   t->size = 1+ node_size(t->right);
        } else {
	   newroot->right = t->right;
	   newroot->left = t;
	   t->right = NULL;
	   t->size = 1+ node_size(t->left);
        }
    }
    
    newroot->size = 1 + node_size(newroot->left) + node_size(newroot->right);
    t = newroot;
// Deletes i from the tree if it's there.
void AbstractSplayTree::remove(AbstractSplayTreeItem* node, int& status) {
    AbstractSplayTreeItem* x;
    int tsize;
    if (t==NULL) return;
    tsize = t->size;
    splay(node->Key());
    if ((Sense*compare(node->Key(), t->Key())) == 0) {               // found it
	status = TRUE;
        counter--;
	if (t->left == NULL) {
	    x = t->right;
	} else {
	    x = splay(node->Key(), t->left);
	    x->right = t->right;
	delete_item(t);
	if (x != NULL) {
	    x->size = tsize-1;
	t = x;
    }
    else {
        status = FALSE;
        node = 0;
    }
// Returns a pointer to the node in the tree with the given rank.
// Returns NULL if there is no such node.                        
// Does not change the tree.  To guarantee logarithmic behavior, 
// the node found here should be splayed to the root.            
AbstractSplayTreeItem* AbstractSplayTree::find_rank(int r)
    AbstractSplayTreeItem* tmp=t;
    int lsize;
    if ((r < 0) || (r >= node_size(tmp))) return NULL;
    for (;;) {
	lsize = node_size(tmp->left);
	if (r < lsize) {
	    tmp = tmp->left;
	} else if (r > lsize) {
	    r = r - lsize - 1;
	    tmp = tmp->right;
	} else {
	    break;
    }
    splay(tmp->Key());
    return tmp;
void AbstractSplayTree::print_tree(ostream& os, int d, 
					AbstractSplayTreeItem* t) {
    int i;
    if (t == NULL) return;
    print_tree(os,d+1,t->right);
    dowrite(t,os);
    print_tree(os,d+1,t->left);
int AbstractSplayTree::write(ostream& os)
os << size() << endl;
AbstractSplayTreeItem* node;
node = find_rank(0);
int i=1;
while (node) {
  write_item(os,node);
  os << endl;
  node = find_rank(i++);
return 0;
int AbstractSplayTree::read(istream& is)
int Size;
is >> Size;
for (int i=0; i<Size; i++) {
  AbstractSplayTreeItem* item;
  read_item(is,item);
  add(item);
return OK;
void AbstractSplayTree::clear()
int status;
while (t) {
  remove(t,status);
  if (status)
// Basic2DArray.cpp
#ifdef __GNUC__
#endif
#include <stdlib.h>
#include <assert.h>
#ifdef MIN
#undef MIN
#endif
#define MIN(a,b)	(a<b ? a : b)
// Basic2DArray
template <class T>
void Basic2DArray<T>::construct(const size_type nrows, const size_type ncols, T * d, 
					const EnumDataOwned o)
a = new Basic2DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T [ncols] ;
            assert(a->Data[i] != 0);
            }
	 size_type ndx=0;
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             a->Data[ii][jj] = d[ndx++];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         T* tmp = d;
         for (size_type i=0; i<ncols; i++) {
            a->Data[i] = tmp;
            tmp+= ncols;
            }
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic2DArray<T>::construct(const size_type nrows, const size_type ncols, T **d, 
					const EnumDataOwned o)
a = new Basic2DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T [ncols] ;
            assert(a->Data[i] != 0);
            }
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             a->Data[ii][jj] = d[ii][jj];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      a->Data=d;
      a->own_ptrs = DataNotOwned;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic2DArray<T>::free()
if (--a->ref == 0) {
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++)
           delete [] a->Data[i];
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   delete a;
   }
template <class T>
int Basic2DArray<T>::resize(const size_type nrows, const size_type ncols)
// Maybe we get lucky.
if ((ncols == a->Ncols) && (nrows == a->Nrows))
   return OK;
// Need to completely replace old data.
if ((ncols != a->Ncols) && (nrows != a->Nrows)) {
   //
   // Delete old data (if owned)
   //
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++)
           delete [] a->Data[i];
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   //
   // Make new data
   //
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   a->Nrows = nrows;
   a->Ncols = ncols;
   return OK;
   }
// We need to simply resize the number of rows.
if (nrows != a->Nrows) {
   T **d=NULL;
   if (nrows > 0) {
      d = new T* [nrows];
      assert(d != 0);
      // 
      // Note:  the new memory is not initialized beyond what the constructors
      // do.
      //
      if (a->Nrows > 0) {
         for (size_type i=0; i<MIN(nrows,a->Nrows); i++)
           d[i] = a->Data[i];
         }
      }
   if (a->Data && a->own_ptrs && (a->Nrows > 0))
      delete [] a->Data;
   a->Data = d;
   a->Nrows = nrows;
   }
// We need to simply resize the number of columns
if (ncols != a->Ncols) {
   if (ncols > 0) {
      for (size_type j=0; j<a->Nrows; j++) {
        T* d=NULL;
        d = new T [ncols];
        assert(d != 0);
        // 
        // Note:  the new memory is not initialized beyond what the constructors
        // do.
        //
        if (a->Ncols > 0) {
           for (size_type i=0; i<MIN(ncols,a->Ncols); i++)
             d[i] = a->Data[j][i];
           }
        if (a->Data && a->own_data && (a->Ncols > 0))
           delete [] a->Data[j];
        a->Data[j] = d;
        }
      }
   else 
      if (a->Data && a->own_data && (a->Ncols > 0))
         for (size_type i=0; i<a->Nrows; i++) {
           delete [] a->Data[i];
           a->Data[i] = NULL;
           }
   a->Ncols = ncols;
   }
return OK;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const Basic2DArray<T>& array)
if (this != &array) {
   free();
   construct(array.nrows(),array.ncols(),array.data(),AcquireOwnership);
   }
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator<<(const Basic2DArray<T>& array)
if (array.a == a)
   return *this;
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = array.a->Data[i][j];
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator&=(const Basic2DArray<T>& array)
if (array.a == a) return *this;
free();
a = array.a;
a->ref++;
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const T& val)
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = ( T ) val;
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const BasicArray<T>& val)
if (a->Ncols != val.size())
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = val[j];
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::set_data(const size_type len, T * data, const EnumDataOwned o)
#if TwoDArraySanityChecking==1
if ( (nrows()*ncols()) != len)
			(nrows()*ncols()),len));
#endif
if (a->own_data && (a->Ncols > 0)) {
   for (size_type i=0; i<a->Nrows; i++)
     delete [] a->Data[i];
   }
size_type ndx=0;
for (size_type i=0; i<a->Nrows; i++) {
  a->Data[i] = &(data[ndx]);
  ndx += a->Ncols;
// BUG: I need to fix the model of ownership here.
a->own_data = DataNotOwned;
return *this;
// Basic3DArray.cpp
#ifdef __GNUC__
#endif
#include <stdlib.h>
#include <assert.h>
#ifdef MIN
#undef MIN
#endif
#define MIN(a,b)	(a<b ? a : b)
// Basic3DArray
template <class T>
void Basic3DArray<T>::construct(const size_type nrows, const size_type ncols, 
				const size_type ndeep, T * d, const EnumDataOwned o)
a = new Basic3DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
a->Ndeep = ndeep;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T** [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T* [ncols] ;
         for (size_type j=0; j<ncols; j++) {
           a->Data[i][j] = new T [ndeep] ;
           assert(a->Data[i][j] != 0);
           }
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T** [nrows] ;
         assert(a != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T* [ncols] ;
            for (size_type j=0; j<ncols; j++) {
              a->Data[i][j] = new T [ndeep] ;
              assert(a->Data[i][j] != 0);
              }
            assert(a->Data[i] != 0);
            }
	 size_type ndx=0;
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             for (size_type kk=0; kk<ndeep; kk++)
               a->Data[ii][jj][kk] = d[ndx++];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      if (nrows > 0)  {
         a->Data = new T** [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T* [ncols] ;
            assert(a->Data[i] != 0);
            }
         T* tmp = d;
         for (size_type i=0; i<ncols; i++) {
            a->Data[i] = tmp;
            tmp+= ncols;
            }
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic3DArray<T>::construct(const size_type nrows, const size_type ncols, T **d, 
					const EnumDataOwned o)
a = new Basic3DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T** [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T* [ncols] ;
         for (size_type j=0; j<ncols; j++) {
           a->Data[i][j] = new T [ndeep] ;
           assert(a->Data[i][j] != 0);
           }
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T** [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T* [ncols] ;
            for (size_type j=0; j<ncols; j++) {
              a->Data[i][j] = new T [ndeep] ;
              assert(a->Data[i][j] != 0);
              }
            assert(a->Data[i] != 0);
            }
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             a->Data[ii][jj] = d[ii][jj];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      a->Data=d;
      a->own_ptrs = DataNotOwned;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic3DArray<T>::free()
if (--a->ref == 0) {
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++) {
           for (size_type j=0; j<a->Ncols; j++)
             if (a->Ndeep > 0) delete [] a->Data[i][j];
           delete [] a->Data[i];
           }
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   delete a;
   }
template <class T>
int Basic3DArray<T>::resize(const size_type nrows, const size_type ncols)
// Maybe we get lucky.
if ((ncols == a->Ncols) && (nrows == a->Nrows) && (ndeep == a->Ndeep))
   return OK;
// Need to completely replace old data.
if ((ncols != a->Ncols) && (nrows != a->Nrows) && (ndeep != a->Ndeep)) {
   //
   // Delete old data (if owned)
   //
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++) {
           for (size_type j=0; j<a->Ncols; j++)
             if (a->Ndeep > 0) delete [] a->Data[i][j];
           delete [] a->Data[i];
           }
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   //
   // Make new data
   //
   if (nrows > 0) {
      a->Data = new T** [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T* [ncols] ;
         for (size_type j=0; j<ncols; j++) {
           a->Data[i][j] = new T [ndeep] ;
           assert(a->Data[i][j] != 0);
           }
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   a->Nrows = nrows;
   a->Ncols = ncols;
   a->Ndeep = ndeep;
   return OK;
   }
// We need to simply resize the number of rows.
if (nrows != a->Nrows) {
   T **d=NULL;
   if (nrows > 0) {
      d = new T* [nrows];
      assert(d != 0);
      // 
      // Note:  the new memory is not initialized beyond what the constructors
      // do.
      //
      if (a->Nrows > 0) {
         for (size_type i=0; i<MIN(nrows,a->Nrows); i++)
           d[i] = a->Data[i];
         }
      }
   if (a->Data && a->own_ptrs && (a->Nrows > 0))
      delete [] a->Data;
   a->Data = d;
   a->Nrows = nrows;
   }
// We need to simply resize the number of columns
if (ncols != a->Ncols) {
   if (ncols > 0) {
      for (size_type j=0; j<a->Nrows; j++) {
        T* d=NULL;
        d = new T [ncols];
        assert(d != 0);
        // 
        // Note:  the new memory is not initialized beyond what the constructors
        // do.
        //
        if (a->Ncols > 0) {
           for (size_type i=0; i<MIN(ncols,a->Ncols); i++)
             d[i] = a->Data[j][i];
           }
        if (a->Data && a->own_data && (a->Ncols > 0))
           delete [] a->Data[j];
        a->Data[j] = d;
        }
      }
   else 
      if (a->Data && a->own_data && (a->Ncols > 0))
         for (size_type i=0; i<a->Nrows; i++) {
           delete [] a->Data[i];
           a->Data[i] = NULL;
           }
   a->Ncols = ncols;
   }
return OK;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::operator=(const Basic3DArray<T>& array)
if (this != &array) {
   free();
   construct(array.nrows(),array.ncols(),array.data(),AcquireOwnership);
   }
return *this;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::operator<<(const Basic3DArray<T>& array)
if (array.a == a)
   return *this;
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = array.a->Data[i][j];
return *this;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::operator&=(const Basic3DArray<T>& array)
if (array.a == a) return *this;
free();
a = array.a;
a->ref++;
return *this;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::operator=(const T& val)
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = ( T ) val;
return *this;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::operator=(const BasicArray<T>& val)
if (a->Ncols != val.size())
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = val[j];
return *this;
template <class T>
Basic3DArray<T>& Basic3DArray<T>::set_data(const size_type len, T * data, const EnumDataOwned o)
#if TwoDArraySanityChecking==1
if ( (nrows()*ncols()) != len)
			(nrows()*ncols()),len));
#endif
if (a->own_data && (a->Ncols > 0)) {
   for (size_type i=0; i<a->Nrows; i++)
     delete [] a->Data[i];
   }
size_type ndx=0;
for (size_type i=0; i<a->Nrows; i++) {
  a->Data[i] = &(data[ndx]);
  ndx += a->Ncols;
// BUG: I need to fix the model of ownership here.
a->own_data = DataNotOwned;
return *this;
// BitArrayBase.cpp
// All internal arrays are indexed 0..n-1
#ifdef __GNUC__
#pragma implementation
#endif
#include <assert.h>
#include <string.h>
void BitArrayBase::construct(const size_type array_len_, const size_type mylen,
		char* d, const EnumDataOwned o)
array_len = array_len_;
Len = mylen;
if (d == NULL) {
   if (mylen > 0) {
      Data = new char [mylen] ;
      if (Data == 0)
      initialize(0,array_len);
      }
   else
      Data = NULL;
   }
else {
   if (o == AcquireOwnership) {
      if (mylen > 0)  {
         Data = new char [mylen] ;
         if (Data == 0)
         for (size_type i=0; i<mylen; i++) Data[i] = d[i] ;
         }
      }
   else
      Data = d;
   }
if ((d != NULL) && (o != AcquireOwnership))
   set_shared_data(Data,Len,array_len,o);
else
   shared=0;
void BitArrayBase::free()
if (shared)
   shared->release(this);
else if (Len > 0) {
   delete [] Data;
   Data=NULL;
   array_len = Len = 0;
   }    
BitArrayBase& BitArrayBase::operator=(const BitArrayBase& array)
if (this != &array) {
   free();
   construct(array.size(),array.Len,array.Data,AcquireOwnership);
   }
return *this;
}       
BitArrayBase& BitArrayBase::operator&=(const BitArrayBase& array)
if ((Data != NULL) && (array.Data == Data)) return *this;
if (!array.shared)
free();
shared = array.shared;
shared->acquire(this);
return *this;
}         
BitArrayBase& BitArrayBase::operator&=(BitArrayBase& array)
if ((Data != NULL) && (array.Data == Data)) return *this;
if (!array.shared) 
   array.set_shared_data(array.Data, array.Len, array.array_len, 
							AcquireOwnership);
free();
shared = array.shared;
shared->acquire(this);
return *this;
BitArrayBase& BitArrayBase::operator=(const int value)
for (size_type i=0; i<size(); i++)
  put(i,value);
return *this;
BitArrayBase& BitArrayBase::operator<<(const BitArrayBase& vec)
if (size() != vec.size())
for (size_type i=0; i<vec.size(); i++)
  put(i,vec[i]);
return(*this);
// This clears the vector and resets it
// It shouldn't do this, but should reset the new area allocated
int BitArrayBase::resize(const size_type newl)
if (newl == array_len) return OK;
if (newl == 0) {
   if (shared)
      shared->set_data(0,0,0,AcquireOwnership);
   else if (Len > 0) {
      delete [] Data;
      Data = 0;
      Len = 0;
      array_len = 0;
      }
   return OK;
   }
char* d;
size_type newbytes = (newl + BYTESIZE - 1)/ ( BYTESIZE / element_size() );
d = new char[ newbytes ];
if (d == 0)
#ifndef DEBUGGING
if (Len > 0)
   memcpy( d, Data, sizeof(char) * min(newbytes,Len));
#else
// For debugging purposes, we clear the memory we allocated.
// This isn't strictly necessary since we are using Bit-operations to
// fill in the memory below, but purify gets confused by that.
if (Len > 0) {
   memcpy( d, Data, sizeof(char) * min(newbytes,Len));
   if (newbytes > Len)
      memset( d+Len, '\000', (newbytes - Len));
   }
else
   memset( d, '\000', newbytes);
#endif
if (shared)
  shared->set_data(d,newbytes,newl,AcquireOwnership);
else {
  if (Len > 0)
    delete [] Data;
  Data = d;
  Len = newbytes;
  array_len = newl;
initialize(array_len,newl);
return OK;
int BitArrayBase::operator!= (const BitArrayBase& vec) const
if (vec.Data == Data)
   return 0;
if (vec.array_len != array_len)
   return 1;
for (size_type i=0; i<array_len; i++) 
  if ((*this)[i] != vec[i]) 
     return 1;
return 0; 
int BitArrayBase::operator== (const BitArrayBase& vec) const
if (vec.Data == Data)
   return 1;
if (vec.array_len != array_len)
   return 0;
for (size_type i=0; i<array_len; i++)
  if ((*this)[i] != vec[i])
     return 0;
return 1;
int BitArrayBase::compare(const BitArrayBase& vec) const
if (vec.Data == Data)
   return 0;
if (vec.array_len > array_len)
   return 1;
if (vec.array_len < array_len)
   return 0;
for (size_type i=0; i<array_len; i++)
  if ((*this)[i] != vec[i])
      return ((*this)[i] - vec[i]);
return 0;
int BitArrayBase::operator> (const BitArrayBase& vec) const
return(compare(vec)>0);
int BitArrayBase::operator>= (const BitArrayBase& vec) const
return(compare(vec)>=0);
int BitArrayBase::write(ostream& s) const
if (Data) {
   for (size_type i=0; i<array_len; i++)
       s << operator[](i);
   }
return OK ;
int BitArrayBase::read(UnPackBuffer& s)
int tmp;
s >> tmp;
resize(tmp);
s.unpack(Data, Len);
return OK ;
int BitArrayBase::write(PackBuffer& s) const
if (Data) {
   s << array_len;
   s.pack(Data,Len);
   }
else
   s << (int)0;
return OK ;
void BitArrayBase::initialize(const size_type curr_array_len,
                        const size_type new_array_len)
for (size_type i=curr_array_len; i<new_array_len; i++)
  put(i,0);
void BitArrayBase::set_shared_data(char* data, const size_type newlen,
					const size_type array_len_,
                                                const EnumDataOwned o)
if (!shared) {
   if ((Len > 0) && (data != Data))
      delete [] Data;
   shared = new BitArrayRef();
   if (!shared)
   shared->acquire(this);
   }
shared->set_data(data,newlen,array_len_,o);
// BitArray.cpp
// All internal arrays are indexed 0..n-1
#ifdef __GNUC__
#pragma implementation
#endif
#include <string.h>
int BitArray::read(istream& s)
  size_type i;
  char c;
  if (Data) {	// size is known
     for (i=0; i<array_len; i++) {
       s.get(c);
       while (s && ((c == ' ') || (c == '\t') || (c == '\n')))
         s.get(c);
       if (c == '1') set(i);
       else if (c == '0') reset(i);
       else {
	  break;
	  }
       }
     }
  else 			// size and sparseity is not known
  return OK ;
size_type BitArray::nbits() const
size_type nbits = 0;
for (size_type i=0; i<array_len; i++)
  nbits += (*this)(i);
return nbits;
void BitArray::set()
for (size_type i=0; i<array_len; i++)
  SET_BIT( Data[i /BYTESIZE] , i );
void BitArray::set(const size_type idx)
#if (BitArraySanityChecking==1)
if (idx >= array_len)
#endif
SET_BIT( Data[idx/BYTESIZE] , idx );
void BitArray::reset()
for (size_type i=0; i<array_len; i++)
  RESET_BIT( Data[i/BYTESIZE] , i );
void BitArray::reset(const size_type idx)
#if (BitArraySanityChecking==1)
if (idx >= array_len)
#endif
RESET_BIT( Data[idx /BYTESIZE] , idx );
void BitArray::put(const size_type idx, const int val)
if (val == 0)
   reset(idx);
else if (val == 1)
   set(idx);
else
// This could be done more efficeintly with XOR
void BitArray::flip()
for (size_type i=0; i<array_len; i++)
  put(i, 1 - (*this)(i));
void BitArray::flip(const size_type idx)
{ put(idx, 1 - (*this)(idx) ); }
int bitwise_or(BitArray& a1, BitArray& a2, BitArray& result)
if ((a1.size() != a2.size()) || (a1.size() != result.size()))
		a1.size(), a2.size(), result.size()));
for (size_type i=0; i<result.size(); i++)
  result.put(i,a1(i) | a2(i));
return OK;
int bitwise_xor(BitArray& a1, BitArray& a2, BitArray& result)
if ((a1.size() != a2.size()) || (a1.size() != result.size()))
		a1.size(), a2.size(), result.size()));
for (size_type i=0; i<result.size(); i++)
  result.put(i,a1(i) ^ a2(i));
return OK;
int bitwise_and(BitArray& a1, BitArray& a2, BitArray& result)
if ((a1.size() != a2.size()) || (a1.size() != result.size()))
		a1.size(), a2.size(), result.size()));
for (size_type i=0; i<result.size(); i++)
  result.put(i,a1(i) & a2(i));
return OK;
// return true (1) if the two BitArrays both have a 1 in at least one
// bit.  Equivalent to a bitwise AND and then comparing nbits() on the result
// to 0, but much more efficient (e.g. can return as soon as find agreement)
int BitArray::shared_one(BitArray& other) const
size_type min_length = other.size();
if (size() < min_length)
  min_length = size();
for (size_type i=0; i<min_length; i++)
  if(operator()(i) && other(i)) return 1;  // true
 return 0;  // false
// CharString.cpp
#ifdef __GNUC__
#pragma implementation
#endif
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void CharString::construct(const size_type mylen, char *d, const EnumDataOwned o)
Len = mylen+1;
if (d == NULL) {
   if (mylen > 0) {
      Data = new char [Len] ;
      if (Data == 0)
      for (size_type i=0; i<(mylen+1); i++)
        Data[i] = '\000';
      }
   else
      Data = NULL;
   }
else {
   if (o == AcquireOwnership) {
      if (mylen > 0)  {
         Data = new char [Len] ;
         if (Data == 0)
         for (size_type i=0; i<mylen; i++) Data[i] = d[i] ;
         Data[mylen] = '\000';
         }
      }
   else
      Data = d;
   }
if ((d != NULL) && (o != AcquireOwnership))
   set_shared_data(Data,Len,o);
else
   shared=0;
CharString::CharString() 
  : SimpleArray<char>()
CharString::CharString(const size_type mylen, char *d, const EnumDataOwned o)
  : SimpleArray<char>(mylen+1,d,o)
CharString::CharString(const CharString& array)
  : SimpleArray<char>()
if (array.size())
   construct(array.size(),array.Data,AcquireOwnership);
CharString::CharString(const char* str, const EnumDataOwned o)
  : SimpleArray<char>()
if (str)
   construct(strlen(str), (char*)str, o);
CharString::CharString(char* str, const EnumDataOwned o)
  : SimpleArray<char>()
if (str)
   construct(strlen(str), str, o);
int CharString::resize(const size_type newl)
if (newl == size()) return OK;
if (newl == 0) {
   if (shared)
      shared->set_data(0,0,AcquireOwnership);
   else if (Len > 0) {
      delete [] Data;
      Data = 0;
      Len = 0;
      }
   return OK;
   }
char *d;
d = new char [newl+1];
if (d == 0)
if (Len > 0) {
   char* start = Data;
   for (size_type i=0; i<min(newl,Len-1); i++,start++)
     d[i] = *start;
   }
if (newl > size()) {
   for (size_type i=Len-1; i<newl+1; i++)
     d[i] = '\000';
   }
else
   d[min(newl,Len-1)] = '\000';
if (shared)
   shared->set_data(d,newl+1,AcquireOwnership);
else {
   if (Len > 0)
      delete [] Data;
   Data = d;
   Len = newl+1;
   }
return OK;
CharString& CharString::set_subvec(const size_type start, const size_type len,
                                const CharString& array, const size_type offset)
for (size_type i=start; i<(len+start); i++)
  Data[i] = array.Data[offset+i-start];
Data[len+start] = '\000';
return *this;
int compare(const CharString& str1, const CharString& str2)
if (str1.Len < str2.Len)
   return -1;
else if (str1.Len > str2.Len)
   return 1;
for (size_type i=0; i<str1.Len; i++) {
  if (str1.Data[i] < str2.Data[i])
     return -1;
  else if (str1.Data[i] > str2.Data[i])
     return 1;
return 0;
int CharString::operator<(const CharString& array) const
if (Len < array.Len)
   return 1;
else if (Len > array.Len)
   return 0;
for (size_type i=0; i<Len; i++) {
  if (Data[i] < array.Data[i])
     return 1;
  else if (Data[i] > array.Data[i])
     return 0;
return 0;
int CharString::operator>(const CharString& array) const
if (Len < array.Len)
   return 0;
else if (Len > array.Len)
   return 1;
for (size_type i=0; i<Len; i++) {
  if (Data[i] < array.Data[i])
     return 0;
  else if (Data[i] > array.Data[i])
     return 1;
return 0;
int CharString::read(UnPackBuffer& os)
int len;
os >> len;
resize(len);
for (size_type i=0; i<Len; i++)
  os >> Data[i];
Data[len] = '\000';
return OK;
CharString& CharString::operator+=(const double val)
char tmp[256];
return ( (*this) += tmp );
CharString& CharString::operator+=(const int val)
char tmp[256];
return ( (*this) += tmp );
CharString& CharString::operator+=(const char* str)
if (str) {
   size_type curr = Len-1;
   size_type next = strlen(str);
   resize(curr+next);
   for (size_type i=curr; i<(curr+next); i++)
     Data[i] = str[i-curr];
   Data[curr+next] = '\000';
   }
return *this;
int CharString::write(ostream& os) const
if (Len == 0) return OK;
assert(Data[Len-1] == '\000');
os << Data;
return OK;
int CharString::read(istream& is)
char buf[256];
int ndx=0;
is >> whitespace;
char c, pc=' ';
int flag=TRUE;
int str_flag=FALSE;
while ((flag==TRUE) && is) {
  if (ndx == 255)
  is.get(c);
  if (is) {
     if ((str_flag == FALSE) && ((c == ' ') || (c == '\t') || (c == '\n')))
        flag = FALSE;
     else {
           if (pc == '\\')
              ndx--;
           else
              flag = FALSE;
           }
	else {
	   else buf[ndx++] = c;
	   }
	pc=c;
        }
     }
buf[ndx] = '\000';
resize(ndx);
if (ndx > 0)
   strncpy(Data,buf,ndx+1);
return OK;
int CharString::operator== (const char* array) const
if (Data) {
   if (array && (strcmp(Data,array) == 0))
      return 1;
   else
      return 0;
   }
if (array) {
   if (array[0] == '\000')
      return 1;
   else
      return 0;
   }
else
   return 1;
int CharString::operator!= (const char* array) const
if (Data) {
   if (array && (strcmp(Data,array) == 0))
      return 0;
   else
      return 1;
   }
if (array) {
   if (array[0] == '\000')
      return 0;
   else
      return 1;
   }
else
   return 0;
long int aslong(const CharString& str, int& status)
long int ans;
char* ptr = NULL;
ans = strtol(str.data(),&ptr,0);
if ((ptr == NULL) || (ptr[0] == '\000'))
   status = OK;
else
   status = ERR;
return ans;
double asdouble(const CharString& str, int& status)
double ans;
char* ptr = NULL;
ans = strtod(str.data(),&ptr);
if ((ptr == NULL) || (ptr[0] == '\000'))
   status = OK;
else
   status = ERR;
return ans;
// Ereal.cpp
#include <values.h>
template<>
double Ereal<double>::positive_infinity_val = MAXDOUBLE;
template<>
double Ereal<double>::negative_infinity_val = MINDOUBLE;
template<>
float Ereal<float>::positive_infinity_val = MAXFLOAT;
template<>
float Ereal<float>::negative_infinity_val = MINFLOAT;
// GenericHeap.cpp
#ifdef __GNUC__
#endif
template <class T>
int GenericHeap<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
int tmp=key1->compare(key2);
return tmp*Sense;
template <class T>
GenericHeap<T>::~GenericHeap<T>()
for (int i = size(); i>0; i--)
  deleteElement(i);
template <class T>
void GenericHeap<T>::deleteElement(const int element)
GenericHeapItem<T>* item = (GenericHeapItem<T>*) member(element);
delete item;
// For right now, this is done with a linear search through the
// heap array.  A more efficient method could be designed, but I don't
// expect to use this method much, so...
template <class T>
GenericHeapItem<T>* GenericHeap<T>::find( T& key)
for (int i=1; i<= size(); i++)
  if (*(((GenericHeapItem<T>*)member(i))->Key) == key)
     return (GenericHeapItem<T>*) member(i);
return NULL;
template <class T>
void GenericHeap<T>::read_item(istream& is, AbstractHeapItem*& item)
T* key = new T ();
key->read(is);
item = new GenericHeapItem<T>(key);
}        
// GenericSplayTree.cpp
#ifdef __GNUC__
#endif
template <class T>
GenericSplayTreeItem<T>* GenericSplayTree<T>::insert(const T* key)
splay(*key);
GenericSplayTreeItem<T>* t = (GenericSplayTreeItem<T>*)top();
duplicate_flag = 0;
if (check_duplicates_flag && (t != NULL)) {
   if (compare(key,t->key())==0) {	// it's already there
      t->ctr++;
      duplicate_flag = 1;
      return t;
      }
   }
GenericSplayTreeItem* newroot = new GenericSplayTreeItem(key);
if (newroot == NULL) 
AbstractSplayTree::add(newroot);
return newroot;
template <class T>
int GenericSplayTree<T>::compare(const void* key1_, const void* key2_)
if (key1_ == key2_)
   return 0;
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
return key1->compare(key2);
template <class T>
GenericSplayTree<T>::~GenericSplayTree<T>()
int Size=size();
for (int i=0; i<Size; i++) {
  GenericSplayTreeItem* item = top();
  int status;
  remove(item,status);
template <class T>
void GenericSplayTree<T>::read_item(istream& is, AbstractSplayTreeItem*& item)
T* key = new T ();
key->read(is);
item = new GenericSplayTreeItem<T>(key);
template <class T>
void GenericSplayTree<T>::write_item(ostream& os, AbstractSplayTreeItem* item) const
if (check_duplicates_flag)
((GenericSplayTreeItem*)item)->write(os);
// hash_fn.cpp
// WEH: note that I have not tested the fidelity of these hash functions!
#ifdef __GNUC__
#pragma implementation
#endif
#include <math.h>
#include <limits.h>
/* make a good hash function for any int size */
/* inspired by Aho, Sethi and Ullman, Compilers ..., p436 */
/* adapted from code developed in lpsolve3.0 */
#define HASH_1 sizeof(size_type)
#define HASH_2 (sizeof(size_type) * 6)
#define HASH_3 (((size_type)0xF0) << ((sizeof(size_type) - 1) * CHAR_BIT))
size_type hash_fn1(const CharString& str, size_type table_size)
if (table_size == 0)
   return 0;
size_type result = 0, tmp;
for (size_type i=0; i<str.size(); i++) {
  result = (result << HASH_1) + str[i];
  if ((tmp = result & HASH_3) != 0) {
      /* if any of the most significant bits is on */
      result ^= tmp >> HASH_2; /* xor them in a less significant part */
      result ^= tmp; /* and reset the most significant bits to 0 */
      }
return (result % table_size);
size_type hash_fn2(const CharString& str, size_type table_size)
if (table_size == 0)
   return 0;
size_type result = 0;
for (size_type i=0; i<str.size(); i++)
  result = 131*result + str[i];
return (result % table_size);
size_type hash_fn3(const CharString& str, size_type table_size)
if (table_size == 0)
   return 0;
size_type result = 0;
for (size_type i=0; i<str.size(); i++)
  result = result ^ ((result << 5) + (result >> 2) + str[i]);
return (result % table_size);
#define A 2.6397813781
size_type hash_fn(const BasicArray<int>& vec, size_type table_size)
if (vec.len() == 0)
   return 0;
size_type result = table_size;
for (int i=0; i<vec.len(); i++)
  result = (size_type) floor( result * fmod( (fabs(vec[i])+1.0)*A, 1.0 ) ) + table_size;
return (result % table_size);
size_type hash_fn1(const int& vec, size_type table_size)
size_type result = table_size;
result = (size_type) floor( result * fmod( (fabs(vec)+1.0)*A, 1.0 ) ) + table_size;
return (result % table_size);
int utilib_num_primes = 28;
unsigned long utilib_prime_list[] =
        {
        53,         97,           193,         389,       769,
        1543,       3079,         6151,        12289,     24593,
        49157,      98317,        196613,      393241,    786433,
        1572869,    3145739,      6291469,     12582917,  25165843,
        50331653,   100663319,    201326611,   402653189, 805306457,
        1610612741, 3221225473ul, 4294967291ul
        };
// LinkedList.cpp
#ifdef __GNUC__
#endif
#include <iostream.h>
// ListItem methods
template <class T>
ListItem<T> *ListItem<T>::unused = NULL;
template <class T>
void ListItem<T>::delete_unused()
ListItem<T> *curr = unused;
ListItem<T> *next;
while (curr) {
  next = curr->next;
  char* tmp = (char*) curr;
  delete [] tmp;
  curr = next;
unused=NULL;
template <class T>
void* ListItem<T>::operator new(size_t size)
if (!unused)
   return new char[size];
else {
   ListItem<T> *ptr = unused;
   unused = unused->next;
   return ptr;
   }
template <class T>
void ListItem<T>::operator delete(void *p, size_t)
((ListItem<T>*)p)->next = unused;
unused = (ListItem<T>*)p;
// LinkedList methods
template <class T>
int LinkedList<T>::counter=0;
template <class T>
LinkedList<T>::~LinkedList()
while (!empty())
  extract(first);
counter--;
if (!counter)
   ListItem<T>::delete_unused();
template <class T>
int LinkedList<T>::empty() const
return (first == NULL ? TRUE : FALSE) ;
template <class T>
void LinkedList<T>::extract(ListItem<T>* item)
if (empty())
if (item->prev) 
   item->prev->next = item->next;
else
   first = item->next;
if (item->next)
   item->next->prev = item->prev;
else
   last = item->prev;
delete item;
Len--;
template <class T>
ListItem<T>* LinkedList<T>::insert( T& data, ListItem<T>* next)
ListItem<T>* item = new ListItem<T>(data);
if (next) {
   if (next->prev)
      next->prev->next = item;
   else
      first = item;
   item->next = next;
   item->prev = next->prev;
   next->prev = item;
   }
else { 			// appending to end of list 
   if (last) {
      last->next = item;
      item->prev = last;
      last = item;
      }
   else
      first = last = item;
   }
Len++;
return item;
template <class T>
ListItem<T>* LinkedList<T>::find( T& data)
ListItem<T>* curr = first;
while (curr) {
  if (data == curr->data()) break;
  curr = curr->next;
return curr;
// HashBJ.C
// Hash functions based on the general-purpose hash function published
// by Bob Jenkins in DDJ.  Note:  these hash functions return a value
// that can fill a table with 2^k elements.  Classes derived from
// AbstractHashTable are well-suited for these hash functions.
typedef unsigned long int  ub4; /* unsigned 4-byte quantities */
typedef unsigned      char ub1; /* unsigned 1-byte quantities */
static ub4 lookup( register ub1* k, register ub4 length, register ub4 level);
unsigned long int hash_bj(const double& val)
{ return lookup((ub1*)&val,sizeof(double),0); }
unsigned long int hash_bj(const int& val)
{ return lookup((ub1*)&val,sizeof(int),0); }
unsigned long int hash_bj(const BasicArray<double>& array)
{ return lookup((ub1*)(array.data()), array.size()*sizeof(double), 0); }
unsigned long int hash_bj(const BasicArray<int>& array)
{ return lookup((ub1*)(array.data()), array.size()*sizeof(int), 0); }
//unsigned long int hash_bj(const BitArray& array)
//{ return lookup((ub1*)(array.data()),(array.size()+BYTESIZE-1)/BYTESIZE, 0); }
// This uses the rehashing as suggested by Jenkins (for strings).  It may be
// more effective to modify his code to treat a MixedIntVars as one
// contiguous sequence of bytes.
unsigned long int hash_bj(const MixedIntVars& vars)
register ub4 tmp = 0;
tmp = lookup(vars.doubleVars(), vars.ndoubleVars()*sizeof(double), tmp);
tmp = lookup(vars.generalIntVars(), vars.nGeneralIntVars()*sizeof(int), tmp);
tmp = lookup(vars.binaryVars(), (vars.binaryVars().size()+BYTESIZE-1)/BYTESIZE, tmp);
return tmp;
--------------------------------------------------------------------
lookupa.c, by Bob Jenkins, December 1996.  Same as lookup2.c
You may use this code in any way you wish.  It has no warranty.
Source is http://ourworld.compuserve.com/homepages/bob_jenkins/lookupa.c
--------------------------------------------------------------------
#ifndef STANDARD
#endif
#ifndef LOOKUPA
#endif
--------------------------------------------------------------------
mix -- mix 3 32-bit values reversibly.
For every delta with one or two bit set, and the deltas of all three
  high bits or all three low bits, whether the original value of a,b,c
  is almost all zero or is uniformly distributed,
* If mix() is run forward or backward, at least 32 bits in a,b,c
  have at least 1/4 probability of changing.
* If mix() is run forward, every bit of c will change between 1/3 and
  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)
mix() takes 36 machine instructions, but only 18 cycles on a superscalar
  machine (like a Pentium or a Sparc).  No faster mixer seems to work,
  that's the result of my brute-force search.  There were about 2^^68
  hashes to choose from.  I only tested about a billion of those.
--------------------------------------------------------------------
#define mix(a,b,c) \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8); \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12);  \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5); \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
--------------------------------------------------------------------
lookup() -- hash a variable-length key into a 32-bit value
  k     : the key (the unaligned variable-length array of bytes)
  len   : the length of the key, counting by bytes
  level : can be any 4-byte value
Returns a 32-bit value.  Every bit of the key affects every bit of
the return value.  Every 1-bit and 2-bit delta achieves avalanche.
About 6len+35 instructions.
The best hash table sizes are powers of 2.  There is no need to do
mod a prime (mod is sooo slow!).  If you need less than 32 bits,
use a bitmask.  For example, if you need only 10 bits, do
  h = (h & hashmask(10));
In which case, the hash table should have hashsize(10) elements.
If you are hashing n strings (ub1 **)k, do it like this:
  for (i=0, h=0; i<n; ++i) h = lookup( k[i], len[i], h);
By Bob Jenkins, 1996.  74512.261@compuserve.com.  You may use this
code any way you wish, private, educational, or commercial.
See http://ourworld.compuserve.com/homepages/bob_jenkins/evahash.htm
Use for hash table lookup, or anything where one collision in 2^32 is
acceptable.  Do NOT use for cryptographic purposes.
--------------------------------------------------------------------
static ub4 lookup( register ub1* k, register ub4 length, register ub4 level)
   register ub4 a,b,c,len;
   /* Set up the internal state */
   len = length;
   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
   c = level;           /* the previous hash value */
   /*---------------------------------------- handle most of the key */
   while (len >= 12)
   {
      a += (k[0] +((ub4)k[1]<<8) +((ub4)k[2]<<16) +((ub4)k[3]<<24));
      b += (k[4] +((ub4)k[5]<<8) +((ub4)k[6]<<16) +((ub4)k[7]<<24));
      c += (k[8] +((ub4)k[9]<<8) +((ub4)k[10]<<16)+((ub4)k[11]<<24));
      mix(a,b,c);
      k += 12; len -= 12;
   }
   /*------------------------------------- handle the last 11 bytes */
   c += length;
   switch(len)              /* all the case statements fall through */
   {
   case 11: c+=((ub4)k[10]<<24);
   case 10: c+=((ub4)k[9]<<16);
   case 9 : c+=((ub4)k[8]<<8);
      /* the first byte of c is reserved for the length */
   case 8 : b+=((ub4)k[7]<<24);
   case 7 : b+=((ub4)k[6]<<16);
   case 6 : b+=((ub4)k[5]<<8);
   case 5 : b+=k[4];
   case 4 : a+=((ub4)k[3]<<24);
   case 3 : a+=((ub4)k[2]<<16);
   case 2 : a+=((ub4)k[1]<<8);
   case 1 : a+=k[0];
     /* case 0: nothing left to add */
   }
   mix(a,b,c);
   /*-------------------------------------------- report the result */
   return c;
--------------------------------------------------------------------
mixc -- mixc 8 4-bit values as quickly and thoroughly as possible.
Repeating mix() three times achieves avalanche.
Repeating mix() four times eliminates all funnels and all
  characteristics stronger than 2^{-11}.
--------------------------------------------------------------------
#define mixc(a,b,c,d,e,f,g,h) \
   a^=b<<11; d+=a; b+=c; \
   b^=c>>2;  e+=b; c+=d; \
   c^=d<<8;  f+=c; d+=e; \
   d^=e>>16; g+=d; e+=f; \
   e^=f<<10; h+=e; f+=g; \
   f^=g>>4;  a+=f; g+=h; \
   g^=h<<8;  b+=g; h+=a; \
   h^=a>>9;  c+=h; a+=b; \
--------------------------------------------------------------------
checksum() -- hash a variable-length key into a 256-bit value
  k     : the key (the unaligned variable-length array of bytes)
  len   : the length of the key, counting by bytes
  state : an array of CHECKSTATE 4-byte values (256 bits)
The state is the checksum.  Every bit of the key affects every bit of
the state.  There are no funnels.  About 112+6.875len instructions.
If you are hashing n strings (ub1 **)k, do it like this:
  for (i=0; i<8; ++i) state[i] = 0x9e3779b9;
  for (i=0, h=0; i<n; ++i) checksum( k[i], len[i], state);
(c) Bob Jenkins, 1996.  74512.261@compuserve.com.  You may use this
code any way you wish, private, educational, or commercial, as long
as this whole comment accompanies it.
See http://ourworld.compuserve.com/homepages/bob_jenkins/evahash.htm
Use to detect changes between revisions of documents, assuming nobody
is trying to cause collisions.  Do NOT use for cryptography.
--------------------------------------------------------------------
#ifdef USING_CHECKSUM
static void  checksum(ub1* k, ub4 len, ub4* state)
   register ub4 a,b,c,d,e,f,g,h,length;
   /* Use the length and level; add in the golden ratio. */
   length = len;
   a=state[0]; b=state[1]; c=state[2]; d=state[3];
   e=state[4]; f=state[5]; g=state[6]; h=state[7];
   /*---------------------------------------- handle most of the key */
   while (len >= 32)
   {
      a += (k[0] +(k[1]<<8) +(k[2]<<16) +(k[3]<<24));
      b += (k[4] +(k[5]<<8) +(k[6]<<16) +(k[7]<<24));
      c += (k[8] +(k[9]<<8) +(k[10]<<16)+(k[11]<<24));
      d += (k[12]+(k[13]<<8)+(k[14]<<16)+(k[15]<<24));
      e += (k[16]+(k[17]<<8)+(k[18]<<16)+(k[19]<<24));
      f += (k[20]+(k[21]<<8)+(k[22]<<16)+(k[23]<<24));
      g += (k[24]+(k[25]<<8)+(k[26]<<16)+(k[27]<<24));
      h += (k[28]+(k[29]<<8)+(k[30]<<16)+(k[31]<<24));
      mixc(a,b,c,d,e,f,g,h);
      mixc(a,b,c,d,e,f,g,h);
      mixc(a,b,c,d,e,f,g,h);
      mixc(a,b,c,d,e,f,g,h);
      k += 32; len -= 32;
   }
   /*------------------------------------- handle the last 31 bytes */
   h += length;
   switch(len)
   {
   case 31: h+=(k[30]<<24);
   case 30: h+=(k[29]<<16);
   case 29: h+=(k[28]<<8);
   case 28: g+=(k[27]<<24);
   case 27: g+=(k[26]<<16);
   case 26: g+=(k[25]<<8);
   case 25: g+=k[24];
   case 24: f+=(k[23]<<24);
   case 23: f+=(k[22]<<16);
   case 22: f+=(k[21]<<8);
   case 21: f+=k[20];
   case 20: e+=(k[19]<<24);
   case 19: e+=(k[18]<<16);
   case 18: e+=(k[17]<<8);
   case 17: e+=k[16];
   case 16: d+=(k[15]<<24);
   case 15: d+=(k[14]<<16);
   case 14: d+=(k[13]<<8);
   case 13: d+=k[12];
   case 12: c+=(k[11]<<24);
   case 11: c+=(k[10]<<16);
   case 10: c+=(k[9]<<8);
   case 9 : c+=k[8];
   case 8 : b+=(k[7]<<24);
   case 7 : b+=(k[6]<<16);
   case 6 : b+=(k[5]<<8);
   case 5 : b+=k[4];
   case 4 : a+=(k[3]<<24);
   case 3 : a+=(k[2]<<16);
   case 2 : a+=(k[1]<<8);
   case 1 : a+=k[0];
   }
   mixc(a,b,c,d,e,f,g,h);
   mixc(a,b,c,d,e,f,g,h);
   mixc(a,b,c,d,e,f,g,h);
   mixc(a,b,c,d,e,f,g,h);
   /*-------------------------------------------- report the result */
   state[0]=a; state[1]=b; state[2]=c; state[3]=d;
   state[4]=e; state[5]=f; state[6]=g; state[7]=h;
#endif
int main()
for (int i=0; i<100; i++)
  cout << hash_bj(i) << endl;
return 0;
// MixedIntVars.cpp
#ifdef __GNUC__
#pragma implementation
#endif
MixedIntVars::MixedIntVars(const int numBits, const int numGenInts, 
					const int numDoubles)
	: a(0)
construct(numBits, numGenInts, numDoubles);
void MixedIntVars::resize(const int numBits, const int numGenInts,
                                        const int numDoubles)
a->bitVars.resize(numBits);
a->gintVars.resize(numGenInts);
a->doubleVars.resize(numDoubles);
a->NumBinaryVars = numBits;
a->NumIntegerVars = numBits+numGenInts;
a->NumVars = numBits+numGenInts+numDoubles;
}     
void MixedIntVars::set(const int ndx, double val)
if (ndx < a->NumBinaryVars)
   a->bitVars.put(ndx,(int)val);
else if (ndx < a->NumIntegerVars) {
   BasicArray<int> foo;
   (a->gintVars)[ndx - a->NumBinaryVars] = (int)val;
   }
else
   a->doubleVars[ndx - a->NumIntegerVars] = val;
void MixedIntVars::setBit(const int ndx, int val)
{ a->bitVars.put(ndx,val); }
void MixedIntVars::setInt(const int ndx, int val)
if (ndx < a->NumBinaryVars)
   a->bitVars.put(ndx,(int)val);
else if (ndx < a->NumIntegerVars)
   a->gintVars[ndx-a->NumBinaryVars] = (int)val;
void MixedIntVars::setGeneralInt(const int ndx, int val)
{ a->gintVars[ndx] = val; }
void MixedIntVars::setDouble(const int ndx, double val)
{ a->doubleVars[ndx] = val; }
double MixedIntVars::get(const int ndx)
if (ndx < a->NumBinaryVars)
   return (double) a->bitVars(ndx);
else if (ndx < a->NumIntegerVars)
   return (double) a->gintVars[ndx-a->NumBinaryVars];
else
   return a->doubleVars[ndx-a->NumIntegerVars];
int MixedIntVars::getBit(const int ndx)
{ return a->bitVars(ndx); }
int MixedIntVars::getInt(const int ndx)
if (ndx < a->NumBinaryVars)
   return a->bitVars(ndx);
else if (ndx < a->NumIntegerVars)
   return a->gintVars[ndx-a->NumBinaryVars];
return ERR;
int MixedIntVars::getGeneralInt(const int ndx)
{ return a->gintVars[ndx-a->NumBinaryVars]; }
double MixedIntVars::getDouble(const int ndx)
{ return a->doubleVars[ndx-a->NumIntegerVars]; }
int MixedIntVars::write(ostream& os) const
{ os << a->bitVars << a->gintVars << a->doubleVars; return OK; }
int MixedIntVars::read(istream& is)
{ is >> a->bitVars >> a->gintVars >> a->doubleVars; return OK; }
int MixedIntVars::write(PackBuffer& os) const
{ os << a->bitVars << a->gintVars << a->doubleVars; return OK; }
int MixedIntVars::read(UnPackBuffer& is)
{ is >> a->bitVars >> a->gintVars >> a->doubleVars; return OK; }
void MixedIntVars::construct(const int nbits, const int nints, const int ndlbs)
if (a)
   free();
a = new MixedIntVarsRep(nbits, nints, ndlbs);
void MixedIntVars::free()
{ if (a) delete a; }
int MixedIntVars::compare(const MixedIntVars& array) const
int bitval = a->bitVars.compare(array.a->bitVars);
if (bitval != 0) return bitval;
int intval = a->gintVars.compare(array.a->gintVars);
if (intval != 0) return intval;
return a->doubleVars.compare(array.a->doubleVars);
int MixedIntVars::operator==(const MixedIntVars& array) const
if (compare(array) == 0)
   return 1;
return 0;
MixedIntVars& MixedIntVars::operator=(const MixedIntVars& array)
if (this != &array) {
   free();
   construct(array.numIntegerVars(), array.numGeneralIntVars(), 
	     array.numDoubles());
   (*this) << array;
   }
return *this;
MixedIntVars& MixedIntVars::operator&=(const MixedIntVars& array)
if (array.a == a) return *this;
free();
a = array.a;
a->ref++;
return *this;
MixedIntVars& MixedIntVars::operator<<(const MixedIntVars& array)
a->bitVars << array.a->bitVars;
a->gintVars << array.a->gintVars;
a->doubleVars << array.a->doubleVars;
return *this;
// MultiLL.cpp
// Defines methods for the MultiLL class.
#ifdef __GNUC__
#endif
#ifndef _MSC_VER
#include <values.h>
#endif
#define OPEN -1
//=============================================================
// Constructor for MultiLL
//=============================================================
MultiLL::MultiLL() {}
//=============================================================
// Destructor for MultiLL
//=============================================================
MultiLL::~MultiLL() {}
//=============================================================
// Method:  set_up
// Purpose: Various initialization
//=============================================================
void MultiLL::set_up(int number_of_types,int number_of_entries_per)
 MAXTYPES     = number_of_types;
 // MAXTABLESIZE = number_of_entries_per*MAXTYPES+1;
MAXTABLESIZE = number_of_entries_per+1;
 resize();
 int i;
 for(i=0; i< MAXTABLESIZE; i++)
   {
    timestamp   = 0;
    Reserved[i] = 0;
    Next[i]     = OPEN;
    Prev[i]     = OPEN;
    table[i]    = OPEN;
   }
 for(i=0; i< MAXTYPES; i++)
   {
    First[i] = OPEN;
    Last[i]  = OPEN;
   }
//=============================================================
// Method:  
// Purpose: 
//          
//=============================================================
void MultiLL::resize()
 table.resize(MAXTABLESIZE);
 Reserved.resize(MAXTABLESIZE);
 Next.resize(MAXTABLESIZE);
 Prev.resize(MAXTABLESIZE);
 First.resize(MAXTYPES);
 Last.resize(MAXTYPES);
 timestamp.resize(MAXTABLESIZE);
//=============================================================
// returns the table index of the earliest free spot in table
//=============================================================
int MultiLL::next_free()
 size_type i=0;
 int free_index;
 // while((table[i] != OPEN)||(Reserved[i]==1)) i++;
 while(table[i] != OPEN) i++;
 if(i==table.size()){
   while(1)
 free_index=i;
 return free_index;
//=============================================================
// Method:  find_value
// Purpose: returns 1 if the value sought is found in the
//          chain referenced, returns 0 otherwise
//=============================================================
int MultiLL::find_value(int type_id,int value)
 int found_index=First[type_id];
 if(found_index != OPEN){
   while((found_index != OPEN)&&(table[found_index] != value))
       found_index=Next[found_index];
 return found_index;
//=============================================================
// Method:  insert
// Purpose: inserts a new value into available slot in
//          the value table and manages chains. returns insertion
//          index
//=============================================================
int MultiLL::insert(int type_id, int value, int expiration)
  int current;   
  if(First[type_id]==OPEN)
   First[type_id] = next_free();    // begin chain for this type at free slot
   current        = First[type_id];
   Prev[current]  = OPEN;           // null previous ptr
  else
   current=Last[type_id];           // maintain chain around last entry
   Next[current]=next_free();
   Prev[Next[current]]=current; // point next slot to current last 
   current=Next[current];
  table[current]=value;      // assign entry
  Last[type_id]=current;         // assign last in chain ptr
  //  Next[current]=next_free();
  Next[current]=OPEN;
  //  Reserved[Next[current]]=1;  
  timestamp[current]=expiration;
  return current;
//=============================================================
// Method:  remove_value
// Purpose: removes entry from value table 
//          and manages chain
//=============================================================
int MultiLL::remove_value(int type_id, int value)
 int candidate=find_value(type_id,value);
 if(candidate!=OPEN)
    if(candidate==First[type_id])
      {
	if(Next[candidate]!=OPEN)
	  {
	    First[type_id] = Next[candidate];
	  }
	else
	  {
	    First[type_id] = OPEN;
	    Last[type_id]  = OPEN;
	  }
      }
    else{
       if(candidate==Last[type_id]){
         Next[Prev[candidate]]=OPEN;
         Last[type_id]=Prev[candidate];
       }
       else{ 
	 Next[Prev[candidate]] = Next[candidate];
         Prev[Next[candidate]] = Prev[candidate];
       }
    }
    table[candidate]      = OPEN;
    Reserved[candidate]   = 0;  
    Next[candidate]       = OPEN;
    Prev[candidate]       = OPEN;
   }
 return candidate;
//=============================================================
// Method:  remove_index
// Purpose: removes entry at the given index from value table 
//          and manages chain
//=============================================================
void MultiLL::remove_index(int type_id, int remove_index)
 int candidate=remove_index;
 if(candidate!=OPEN)
    if(candidate==First[type_id])
      {  // first
       if(Next[candidate]!=OPEN) // Next not open
         Prev[Next[candidate]]=OPEN;
         First[type_id] = Next[candidate];
        else                      // next open
         First[type_id] = OPEN;
         Last[type_id]  = OPEN;
      }
    else{    // last
       if(candidate==Last[type_id]){
         Next[Prev[candidate]]=OPEN;
         Last[type_id]=Prev[candidate];
       }
       else{ // in the middle
	 Next[Prev[candidate]] = Next[candidate];
         Prev[Next[candidate]] = Prev[candidate];
       }
    }
    table[candidate]      = OPEN;
    Reserved[candidate]   = 0;  
    Next[candidate]       = OPEN;
    Prev[candidate]       = OPEN;
   }
//=============================================================
// Method:  
// Purpose: 
//          
//=============================================================
void MultiLL::clean_up(int current_iteration)
  int check_index;
  for(int i=0;i<MAXTYPES;i++)
    {
      check_index=First[i];
      if((check_index > -1) &&
	 (timestamp[check_index] <= current_iteration) &&
         (timestamp[check_index] > 0))
	  remove_index(i,check_index);
	  check_index=Next[check_index];
    }
//=============================================================
// Method:  
// Purpose: 
//          
//=============================================================
void MultiLL::show_list(int type_id)
 int candidate=First[type_id];
 while(candidate !=OPEN)
   {
     candidate=Next[candidate];
   }
 ucout << endl;
//=============================================================
// Method:  
// Purpose: 
//          
//=============================================================
int MultiLL::sublist_empty(int type_id)
 return First[type_id];
// Num2DArray.cpp
#ifdef __GNUC__
#endif
#define BINARYOP(opname,op1,pseudonym, op)\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const Num2DArray<T>& a2)\
if ((a1.nrows() != a2.nrows()) || (a1.ncols() != a2.ncols()))\
resize(a1.nrows(),a2.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op a2[i][j];\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const NumArray<T>& array)\
if (a1.ncols() != array.size())\
resize(a1.nrows(),a1.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op array[j];\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const T& val)\
resize(a1.nrows(),a1.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op val;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const Num2DArray<T>& a1)\
if ((nrows() != a1.nrows()) || (ncols() != a1.ncols()))\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 a1.a->Data[i][j];\
return *this;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const NumArray<T>& a1)\
if (ncols() != a1.size())\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 a1.data()[j];\
return *this;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const T& val)\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 val;\
return *this;\
BINARYOP(operator+=,+=,plus, + )
BINARYOP(operator-=,-=,minus, - )
BINARYOP(operator*=,*=,times, * )
BINARYOP(operator/=,/=,divide, / )
#undef BINARYOP
template <class T>
Num2DArray<T> Num2DArray<T>::operator-    ()
Num2DArray<T> res;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    res.a->Data[i][j] = - a->Data[i][j];
return res;
static Num2DArray<T> temp_mat;
static NumArray<T> temp_vec;
Num2DArray<T> operator%    (const Num2DArray<T> & m1, const Num2DArray<T> & m2)
temp_mat.resize(m1.nrows(), m2.ncols());
matmult(temp_mat, m1, m2);
return temp_mat;
NumArray<T> operator%    (const Num2DArray<T> & m, const NumArray<T> & v)
temp_vec.resize(m.nrows());
matmult(temp_vec, m, v);
return temp_vec;
NumArray<T> operator%    (const NumArray<T> & v, const Num2DArray<T> & m)
temp_vec.resize(m.ncols());
matmult(temp_vec,v,m);
return temp_vec;
void matmult(Num2DArray<T>& res, const Num2DArray<T> & m1, 
					const Num2DArray<T> & m2)
if (m1.ncols() != m2.nrows())
						m2.nrows()) );
if ((res.nrows() != m1.nrows()) || (res.ncols() != m2.ncols()))
T temp;
size_type M1Ncols = m1.ncols();
size_type M1Nrows = m1.nrows();
size_type M2Ncols = m2.ncols();
for (size_type i=0; i<M1Nrows; i++){
  for (size_type j=0; j<M2Ncols; j++){
    temp = m1[i][0] * m2[0][j];
    for (size_type k=1; k<M1Ncols; k++){
      temp += m1[i][k] * m2[k][j];
      }
    res[i][j] = temp;
    }
void matmult(NumArray<T>& res, const Num2DArray<T>& m, const NumArray<T>& v)
if (m.ncols() != v.size())
if (res.size() != m.nrows())
T temp;
size_type NRows = m.nrows();
size_type NCols = v.size();
for (size_type i=0; i<NRows; i++) {
  temp = m[i][0] * v[0];
  for (size_type j=1; j<NCols; j++)
    temp += m[i][j] * v[j];
  res[i] = temp;
void matmult(NumArray<T>& res, const NumArray<T> & v, const Num2DArray<T> & m)
if (m.nrows() != v.size())
if (res.size() != m.ncols())
T temp;
size_type NRows = v.size();
size_type NCols = m.ncols();
for (size_type i=0; i<NCols; i++) {
  temp = m[0][i] * v[0];
  for (size_type j=1; j<NRows; j++)
    temp += m[j][i] * v[j];
  res[i] = temp;
// OrderedList.cpp
#ifdef __GNUC__
#endif
#include <iostream.h>
// OrderedListItem methods
template <class T,class V>
OrderedListItem<T,V> *OrderedListItem<T,V>::unused = NULL;
template <class T,class V>
void OrderedListItem<T,V>::delete_unused()
OrderedListItem<T,V> *curr = unused;
OrderedListItem<T,V> *next;
while (curr) {
  next = curr->next;
  char* tmp = (char*) curr;
  delete [] tmp;
  curr = next;
unused = NULL;
template <class T,class V>
void* OrderedListItem<T,V>::operator new(size_t size)
if (!unused)
   return new char[size];
else {
   OrderedListItem<T,V> *ptr = unused;
   unused = unused->next;
   return ptr;
   }
template <class T,class V>
void OrderedListItem<T,V>::operator delete(void *p, size_t)
((OrderedListItem<T,V>*)p)->next = unused;
unused = (OrderedListItem<T,V>*)p;
// OrderedList methods
template <class T,class V>
int OrderedList<T,V>::counter=0;
template <class T,class V>
OrderedList<T,V>::~OrderedList()
extract_all();
counter--;
if (!counter)
   OrderedListItem<T,V>::delete_unused();
template <class T,class V>
void OrderedList<T,V>::extract_all()
while (!empty())
  extract(first);
template <class T, class V>
OrderedList<T,V>& OrderedList<T,V>::operator=(const OrderedList<T,V>& list)
extract_all();
OrderedListItem<T,V>* curr = list.head();
while (curr) {
  T tdata = curr->data();
  V tkey  = curr->key();
  add(tdata,tkey);
  curr = list.next(curr);
return *this;
// This is a stupid way of doing this.  I should simply update the key
// value and move the 'item'.
template <class T,class V>
void OrderedList<T,V>::update(OrderedListItem<T,V>* item, V& key)
insert(item->Data,key);
extract(item);
template <class T,class V>
int OrderedList<T,V>::empty() const
return (first == NULL ? TRUE : FALSE) ;
}      
template <class T,class V>
void OrderedList<T,V>::extract(OrderedListItem<T,V>* item)
if (empty()) {
   exit(-1);
   }
if (item->prev) 
   item->prev->next = item->next;
else
   first = item->next;
if (item->next)
   item->next->prev = item->prev;
else
   last = item->prev;
delete item;
Len--;
template <class T,class V>
OrderedListItem<T,V>* OrderedList<T,V>::insert( T& data, V& key)
OrderedListItem<T,V>* item = new OrderedListItem<T,V>(data,key);
OrderedListItem<T,V>* curr = last;
while (curr && (item->Key < curr->Key))
  curr = curr->prev;
if (curr) {
   item->prev = curr;
   if (curr->next)
      curr->next->prev = item;
   else
      last = item;
   item->next = curr->next;
   curr->next = item;
   }
else {			// insert at beginning of list
   item->prev = NULL;
   item->next = first;
   if (first)
      first->prev = item;
   first = item;
   if (!last) 
      last = item;
   }
Len++;
return item;
template <class T,class V>
OrderedListItem<T>* OrderedList<T,V>::find( V& key)
OrderedListItem<T>* curr = first;
while (curr) {
  if (key == curr->key()) break;
  curr = curr->next;
return curr;
}          
// OrderedSet.cpp
// Note: the value 'zero' is used to indicate an empty index, so
// the array is used beginning from 1.
#ifndef TEMPLATE_HACK
#ifdef __GNUC__
#endif
#endif
#include <iostream.h>
#include <stdlib.h>
template <class T>
OrderedSet<T>::OrderedSet()
 : Len(0), Data(1)
// Note: in order to make 'removes' effective, you need to be able to deal with
// 'holes' in the array.  This is messy, and I don't need this capability right
// now!  -- WEH
template <class T>
void OrderedSet<T>::remove( T& Value )
template <class T>
int OrderedSet<T>::add( const T& val, const int add_unique )
int ndx = index(val);
if (add_unique && (ndx != -1))
   return ndx;
if (Data.size() == Len)
   Data.resize(Len + max((Data.size() / 10),10));
Data[Len] = val;
Len++;
return(Len-1);
template <class T>
void OrderedSet<T>::add( const OrderedSet<T>& set, const int add_unique )
for (size_type i=0; i<set.Len; i++)
  if (!add_unique || !is_member(set.Data[i]))
     add(set.Data[i]);
template <class T>
int OrderedSet<T>::index(const T& val)
for (size_type i=0; i<Len; i++)
  if (val == Data[i])
     return i;
return -1;
template <class T>
T& OrderedSet<T>::first( OrderedSetIndex& index, int& status)
if (Len == 0) {
   status = FALSE;
   return Data[0];
index = 1;
status=TRUE;
return Data[0];
template <class T>
T& OrderedSet<T>::next( OrderedSetIndex& index, int& status)
if (status == FALSE) return Data[0];
if (index >= Len) {
   status = FALSE;
   return Data[0];
   }
return Data[index++];
template <class T>
int OrderedSet<T>::is_disjoint(const OrderedSet<T>& set)
for (size_type i=0; i<Len; i++)
  for (size_type j=0; j<set.Len; j++)
    if (Data[i] == set.Data[j]) return FALSE;
return TRUE;
template <class T>
void OrderedSet<T>::write(ostream& os) const
if (Len > 0) {
   os << Data[0];
   for (size_type i=1; i<Len; i++)
   }
template <class T>
void OrderedSet<T>::read(istream& /*is*/)
template <class T>
void OrderedSet<T>::write(PackBuffer& os) const
os << Len;
for (size_type i=0; i<Len; i++)
  os << Data[i];
template <class T>
void OrderedSet<T>::read(UnPackBuffer& is)
is >> Len;
if (Data.len() <= Len)
   Data.resize(max(1,Len));
for (size_type i=0; i<Len; i++)
  is >> Data[i];
// QueueArray.cpp
// Note: the value 'zero' is used to indicate an empty index, so
// the array is used beginning from 1.
// TODO: rework Data to be an array of pointers, which makes the internal
// copying more efficient.
#ifdef __GNUC__
#endif
#include <iostream.h>
#include <stdlib.h>
// Note, we are using internal indeces that are 1-based, indexing into
// zero based arrays.  This is because the smallest value that the 'next'
// array can represent is zero.
template <class T>
QueueArray<T>::QueueArray()
 : Len(0), First(1), Last(1)
{ Data.resize(10); next.resize(10); next[0] = 0;}
template <class T>
void QueueArray<T>::clear()
Len=0;
First = 1;
Last = 1;
next[0] = 0;
template <class T>
void QueueArray<T>::remove( T& Value )
if (Len == 0)
size_type curr = First;
Value = Data[curr];
// Move the First pointer down the list
if (next[curr] == 0) {
   //
   // The 'next' value is empty, so return to initial conditions for
   // code.
   //
   Len=0;
   First = 1;
   Last = 1;
   }
else {
   Len--;
   First = next[curr];
   }
// Setup the 'free list'
size_type tmp = next[0];
next[0] = curr;
next[curr] = tmp;
template <class T>
void QueueArray<T>::add( const T& val )
Len++;
size_type curr;
if (next[0] == 0)
   curr = Len;
else {
   //
   // Remove an element from the free list
   //
   curr = next[0];
   next[0] = next[curr];
   }
if (Data.size() == curr) {
   Data.resize(curr + max((Data.size() / 10),10));
   next.resize(curr + max((next.size() / 10),10));
   }
if (Len == 1)
   First = curr;
next[curr] = 0;
if (Len > 1)
   next[Last] = curr;
Data[curr] = val;
Last = curr;
template <class T>
void QueueArray<T>::write(ostream& os) const
if (Len > 0) {
   size_type curr = First;
   os << Data[curr];
   for (size_type i=1; i<Len; i++) {
     curr = next[curr] ;
     }
   }
template <class T>
void QueueArray<T>::read(istream& /*is*/)
template <class T>
void QueueArray<T>::write(PackBuffer& os) const
os << Len;
size_type curr = First;
for (size_type i=0; i<Len; i++) {
  os << Data[curr];
  curr = next[curr];
template <class T>
void QueueArray<T>::read(UnPackBuffer& is)
is >> Len;
if (Data.len() <= (Len+1))
   Data.resize(max(1,(Len+1)));
Len=0;
First = 1;
Last = 1;
for (size_type i=0; i<Len; i++) {
  is >> Data[Len];
  add(Data[Len]);
// Simple2DArray.cpp
#ifdef __GNUC__
#endif
#include <stdlib.h>
#include <assert.h>
#ifdef MIN
#undef MIN
#endif
#define MIN(a,b)	(a<b ? a : b)
// Simple2DArray
template <class T>
int Simple2DArray<T>::compare(const Simple2DArray<T>& array) const
if (array.a == a)
   return 0;
for (size_type i=0; i<MIN(a->Nrows,array.a->Nrows); i++)
  for (size_type j=0; j<MIN(a->Ncols,array.a->Nrows); j++)
    if (a->Data[i][j] < array.a->Data[i][j])
       return -1;
    else if (a->Data[i][j] > array.a->Data[i][j])
       return 1;
if ((array.a->Nrows == a->Nrows) && (array.a->Ncols == a->Ncols))
   return 0;
if ((array.a->Nrows < a->Nrows) || (array.a->Nrows < a->Nrows))
   return -1;
return 1;
template <class T>
int Simple2DArray<T>::operator==(const Simple2DArray<T>& array) const
if (array.a == a)
   return 1;
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
   return 0;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    if (a->Data[i][j] != array.a->Data[i][j])
       return 0;
return 1;
template <class T>
int Simple2DArray<T>::operator!=(const Simple2DArray<T>& array) const
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
   return 1;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    if (a->Data[i][j] != array.a->Data[i][j])
       return 1;
return 0;
template <class T>
int Simple2DArray<T>::write(PackBuffer& os) const
os << a->Nrows << a->Ncols;
if (a->Data) {
   for (size_type i=0; i<a->Nrows; i++)
     for (size_type j=0; j<a->Ncols; j++)
       os << a->Data[i][j];
   }
return OK;
template <class T>
int Simple2DArray<T>::write(ostream& os) const
if (a->Data) {
   for (size_type i=0; i<a->Nrows; i++) {
     for (size_type j=0; j<a->Ncols; j++)
     os << endl;
     }
   }
return OK;
template <class T>
int Simple2DArray<T>::read(UnPackBuffer& is)
size_type nrows,ncols;
is >> nrows >> ncols;
resize(nrows,ncols);
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    is >> a->Data[i][j];
return OK;
template <class T>
int Simple2DArray<T>::read(istream& /*is*/)
free();
// TODO
return OK;
// SimpleHashTable.cpp
#ifdef __GNUC__ 
#endif
template <class T>
SimpleHashTableItem<T>* SimpleHashTable<T>::insert(const T& key)
SimpleHashTableItem<T>* curritem 
	= (SimpleHashTableItem<T>*) AbstractHashTable::find(&key);
duplicate_flag = 0;
if (check_duplicates_flag && (curritem != NULL)) {
  if (compare(&key,curritem->key()) == 0) {		// it's already there
     curritem->ctr++;
     duplicate_flag=1;
     return curritem;
     }
SimpleHashTableItem* newitem = new SimpleHashTableItem(key);
if (!newitem)
AbstractHashTable::add(newitem);
return newitem;
extern int compare( T& , T& );
template <class T>
int SimpleHashTable<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
return ::compare(*key1, *key2);
template <class T>
SimpleHashTable<T>::~SimpleHashTable<T>()
int Size=size();
for (int i=0; i<Size; i++) {
  SimpleHashTableItem<T>* item = 
		(SimpleHashTableItem<T>*)(data.head()->data());
  int status;
  remove(item,status);
  //delete item;
template <class T>
void SimpleHashTable<T>::read_item(istream& is, AbstractHashTableItem*& item)
T key;
is >> key;
item = new SimpleHashTableItem<T>(key);
template <class T>
void SimpleHashTable<T>::write_item(ostream& os, AbstractHashTableItem* item) const
if (check_duplicates_flag)
((SimpleHashTableItem<T>*)item)->write(os);
// SimpleHeap.cpp
#ifdef __GNUC__
#endif
template <class T>
int SimpleHeap<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
if (*key1 < *key2) return -1;
if (*key1 > *key2) return 1;
return 0;
template <class T>
SimpleHeap<T>::~SimpleHeap<T>()
for (int i = size(); i>0; i--)
  deleteElement(i);
template <class T>
void SimpleHeap<T>::deleteElement(const int element)
SimpleHeapItem<T>* item = (SimpleHeapItem<T>*) member(element);
delete item;
// For right now, this is done with a linear search through the
// heap array.  A more efficient method could be designed, but I don't
// expect to use this method much, so...
template <class T>
SimpleHeapItem<T>* SimpleHeap<T>::find( T& key)
for (int i=1; i<= size(); i++)
  if (((SimpleHeapItem<T>*)member(i))->Key == key)
     return (SimpleHeapItem<T>*) member(i);
return NULL;
template <class T>
void SimpleHeap<T>::read_item(istream& is, AbstractHeapItem*& item)
T key;
is >> key;
item = new SimpleHeapItem<T>(key);
}        
// SimpleSplayTree.cpp
#ifdef __GNUC__
#endif
template <class T>
SimpleSplayTreeItem<T>* SimpleSplayTree<T>::insert(const T& key)
splay(key);
SimpleSplayTreeItem<T>* treeitem = (SimpleSplayTreeItem<T>*)top();
duplicate_flag = 0;
if (check_duplicates_flag && (treeitem != NULL)) {
   if (compare(&key,treeitem->key())==0) {	// it's already there
      treeitem->ctr++;
      duplicate_flag = 1;
      return treeitem;
      }
   }
SimpleSplayTreeItem* newroot = new SimpleSplayTreeItem(key);
if (newroot == NULL) 
AbstractSplayTree::add(newroot);
return newroot;
template <class T>
int SimpleSplayTree<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
if (*key1 < *key2) return -Sense;
if (*key1 > *key2) return Sense;
return 0;
template <class T>
SimpleSplayTree<T>::~SimpleSplayTree<T>()
int Size=size();
for (int i=0; i<Size; i++) {
  SimpleSplayTreeItem* item = top();
  int status;
  remove(item,status);
  delete item;
template <class T>
void SimpleSplayTree<T>::read_item(istream& is, AbstractSplayTreeItem*& item)
T key;
is >> key;
item = new SimpleSplayTreeItem<T>(key);
template <class T>
void SimpleSplayTree<T>::write_item(ostream& os, AbstractSplayTreeItem* item) const
if (check_duplicates_flag)
((SimpleSplayTreeItem*)item)->write(os);
// StackArray.cpp
#ifdef __GNUC__
#endif
#include <iostream.h>
#include <stdlib.h>
template <class T>
StackArray<T>::StackArray()
 : Len(0)
template <class T>
StackArray<T>::StackArray(BasicArray<T>& data)
 : Len(0)
{ Data &= data; }
template <class T>
void StackArray<T>::remove( T& Value )
if (Len == 0)
Value = Data[--Len];
template <class T>
void StackArray<T>::add( const T& val )
if (Data.size() == Len)
   Data.resize(max((Data.size() / 10),10));
Data[Len++] = val;
// TwoBitArray.C
// All internal arrays are indexed 0..n-1
#ifdef __GNUC__
#pragma implementation
#endif
#include <string.h>
int TwoBitArray::read(istream& s)
  size_type i;
  char c;
  if (Data) {// size is known
     for (i=0; i<array_len; i++) {
       s.get(c);
       while (s && ((c == ' ') || (c == '\t') || (c == '\n')))
         s.get(c);
       if (c == '0')      put(i,0);
       else if (c == '1') put(i,1);
       else if (c == '2') put(i,2);
       else if (c == '3') put(i,3);
       else {
	  break;
	  }
       }
     }
  else 			// size and sparseity is not known
  return OK ;
// comments.cpp
#ifdef __GNUC__
#pragma implementation
#endif
#include <iostream.h>
#define TRUE 1
#define FALSE 0
UTILIB_API istream& whitespace(istream& ins)
char c='\000';
ins.get(c);
while (ins) {
  if (! ((c == ' ') || (c == '\t') || (c == '\n')) ) {
     break;
     }
  ins.get(c);
if (ins)
   ins.putback(c);
return ins;
UTILIB_API istream& comment_lines(istream& ins, int& line_counter)
char c='\000';
int flag=TRUE;
ins >> whitespace;
while ((flag == TRUE) && ins) {
  ins.get(c);
  if (ins && (c != '#')) {
     ins.putback(c);
     flag = FALSE;
     continue;
     }
  while (ins && (c != '\n'))
    ins.get(c);
  line_counter++;
  ins >> whitespace;
return ins;
// CommonIO.cpp
#ifdef __GNUC__
#endif
#ifdef USING_MPI
#include <mpi.h>
#endif
#undef cout
#undef cerr
#undef cin
#ifndef NULL
#define NULL 0
#endif
{ cout << str << Flush; }
{ cerr << str << Flush; }
CommonIO global_CommonIO;
// Define static variables
int CommonIO::begin_end_counter = 0;
int CommonIO::Rank = -1;
int CommonIO::IO_Rank = -1;
int CommonIO::Size = 1;
int CommonIO::io_mapping = ON;
int CommonIO::io_buffering = 0;
int CommonIO::nref = 0;
int CommonIO::tagging = OFF;
int CommonIO::seqNum = 1;
int CommonIO::numDigits = 0;
int CommonIO::flush_flag = 1;
int CommonIO::header_flag = TRUE;
int CommonIO::stream_flag = -1;
// The strstreams used for mapping IO.
strstream CommonIO::StrCout;
strstream CommonIO::StrCerr;
ostream*  CommonIO::pStrCout = &CommonIO::StrCout;
ostream*  CommonIO::pStrCerr = &CommonIO::StrCerr;
// The CommonIO pointers to I/O streams to which the output eventually
// goes.  These either point to the global I/O streams or to streams that 
// the user specifies.
ostream* CommonIO::common_cout = &cout;
ostream* CommonIO::common_cerr = &cerr;
istream* CommonIO::common_cin  = &cin;
// 'Static' pointers to the global I/O streams
ostream* CommonIO::std_cout = &cout;
ostream* CommonIO::std_cerr = &cerr;
istream* CommonIO::std_cin  = &cin;
// The Map# streams are what is actually passed back to the user.
// These can point to either the std_# streams or the common_# streams.
ostream** CommonIO::MapCout = &CommonIO::common_cout;
ostream** CommonIO::MapCerr = &CommonIO::common_cerr;
istream** CommonIO::MapCin  = &CommonIO::common_cin;
ofstream CommonIO::common_ofstr;
// By default, IO_Rank is setup to the current rank, which means that every
// processor can do IO.
CommonIO::CommonIO()
nref++;
debug = 0;
#ifdef USING_MPI
int running;
MPI_Initialized(&running);
if (running && (rank() == -1)) {
   MPI_Comm_rank(MPI_COMM_WORLD,&Rank);
   MPI_Comm_size(MPI_COMM_WORLD,&Size);
   }
#else
Rank = 0;
#endif
IO_Rank = -1;
CommonIO::~CommonIO()
nref--;
flush_flag=1; 
if ((nref == 0) && (begin_end_counter > 0)) {
   //
   // Note:  when calling 'ErrAbort()', this line of the code should _not_ be
   // called.  However, under Solaris this does happen.  To debug 'core' files
   // you need to coment out this line in order to see where the abort() call
   // occured.
   //
   }
void CommonIO::reset_map()
if ((begin_end_counter > 0) && ((io_mapping == ON) || (io_buffering > 0))) {
   CommonIO::MapCout = &CommonIO::pStrCout;
   CommonIO::MapCerr = &CommonIO::pStrCerr;
   }
else {
   CommonIO::MapCout = &CommonIO::common_cout;
   CommonIO::MapCerr = &CommonIO::common_cerr;
   }
void CommonIO::begin()
begin_end_counter++;
if (io_buffering > 0) io_buffering++;
#ifdef USING_MPI
int running;
MPI_Initialized(&running);
if ((Rank == -1) && running) {
   MPI_Comm_rank(MPI_COMM_WORLD,&Rank);
   MPI_Comm_size(MPI_COMM_WORLD,&Size);
   }
#endif
reset_map();
void CommonIO::begin_buffered()
CommonIO::begin();
if (io_buffering == 0)		// begin() will increment if io_buffered>0
   io_buffering++;
void CommonIO::end_all()
{ flush(); reset_map(); begin_end_counter=0; }
void CommonIO::end()
if (io_buffering > 0) io_buffering--;
flush();
begin_end_counter--;
reset_map();
void CommonIO::reset()
IOflush();
CommonIO::common_cout = CommonIO::std_cout;
CommonIO::common_cerr = CommonIO::std_cerr;
CommonIO::common_cin  = CommonIO::std_cin;
// If we're running under MPI, or if the number of numDigits has been
// setup, then return a strstream, and add the rank/count formatting
// later.  Otherwise, simply return the global streams;  StrCout is
// only needed to provide formating of the output.
//Note: disabled the 'pass-through' I/O feature, since you can have situations
//where use get the ostream and then later setup tagging.  We could put 
ostream& CommonIO::o_stream(const int flag)
if (flag == 0)
   return **MapCout;
else
   return **MapCerr;
void CommonIO::IOflush()
// Perform flushing if:
//   begin_end_counter > 0   AND io_mapping == ON
// or
//   io_buffering == 0
if (io_buffering > 0) return;
if (begin_end_counter == 0) return;
if ((begin_end_counter > 0) && (io_mapping == OFF)) return;
// Do a little error checking here...
if (MapCout != &pStrCout)
if (!(StrCout.good()))
   StrCout.clear();
else
   flush_stream(StrCout,common_cout);
if (!(StrCerr.good()))
   StrCerr.clear();
else
   flush_stream(StrCerr,common_cerr);
void CommonIO::flush_stream(strstream& stream, ostream* tmp)
if (tagging == ON) {
   char c;
   stream.get(c);
   while (stream.good()) {
     if (header_flag == TRUE) {
	 if (numDigits > 0) {
            (*tmp) << '-';
	    (*tmp).setf(ios::right,ios::adjustfield);
	    (*tmp).width(numDigits);
	    (*tmp).fill('0');
	    (*tmp) << seqNum++;
	    (*tmp).unsetf(ios::adjustfield);
	    (*tmp).fill(' ');
	    }
         header_flag = FALSE;
         }
      if (c == '\n')
         header_flag = TRUE;
      (*tmp) << c;
      if ((header_flag == TRUE) && flush_flag) (*tmp).flush();
      stream.get(c);
      }
   //
   // Reset stream to prepare it for use again.
   //
   stream.clear();
   }
else {
   //
   // Send all IO in stream to the stream
   //
   (*tmp) << stream.rdbuf();
   //
   // Reset stream to prepare it for use again.
   //
   stream.clear();
   }
if (flush_flag) (*tmp).flush();
void CommonIO::set_ofile(const char* str)
CharString fname;
fname += str;
fname += rank();
common_ofstr.open(fname);
set_cout(&common_ofstr);
set_cerr(&common_ofstr);
// logEvent.C
// Routines for doing event logging/tracing of parallel codes using MPE.
#ifdef __GNUC__
#endif
#ifdef EVENT_LOGGING_PRESENT
CLASS_PARAMETER_DEF(logEvent,eventLog,0,0,MAXINT);
int logEvent::numberOfStates = 0;
void logEvent::open()
  uMPI::barrier();
  MPE_Start_log();
int logEvent::defineState(const char* description,const char* color)
  int stateNumber = numberOfStates++;
  if (uMPI::rank == 0)
    {
      char cString[256];
      const char* ptr1 = color;
      char* ptr2 = cString;
      while(*ptr1)
	*(ptr2++) = *(ptr1++);
      *(ptr2++) = ':';
      ptr1 = color;
      while(*ptr1)
	*(ptr2++) = *(ptr1++);
      *(ptr2++) = '\0';
      int startEvent = stateNumber*2;
      int endEvent   = startEvent + 1;
      MPE_Describe_state(startEvent,endEvent,(char*) description,cString);
    }
  return stateNumber;
void logEvent::close()
   if (uMPI::iDoIO)
#endif
// mpiUtil.C
//  Utility class to make using MPI a little easier.
// Jonathan Eckstein
#ifdef __GNUC__
#endif
#ifdef USING_MPI
#include <iostream.h>
MPI_Comm uMPI::comm = MPI_COMM_WORLD;
int uMPI::rank   = -1;
int uMPI::size   = 1;
int uMPI::ioProc = 0;
int uMPI::iDoIO  = 1;
int uMPI::errorCode = 0;
void uMPI::init(int* argcP,char*** argvP, MPI_Comm comm_)
  if (!running())
    {
      errorCode = MPI_Init(argcP,argvP);
      if (errorCode)
      comm=MPI_COMM_WORLD;
    }
  else
    comm=comm_;
  errorCode = MPI_Comm_rank(comm,&rank);
  if (errorCode) 
  errorCode = MPI_Comm_size(comm,&size);
  if (errorCode) 
  // MSE: modifications required for the case where the incoming comm is not
  // MPI_COMM_WORLD since MPI_IO is not guaranteed to be an attribute of comm.
  // If comm==MPI_COMM_WORLD or if MPI_IO==rank of the calling process, then
  // MPI_IO rank in MPI_COMM_WORLD can be mapped to rank in comm.  Otherwise, 
  // fall back on ioProc=0 default.
  int flag, result;
  int* mpiIOP;
  errorCode = MPI_Attr_get(MPI_COMM_WORLD,MPI_IO,&mpiIOP,&flag);
  if (errorCode || !flag)
  MPI_Comm_compare(comm, MPI_COMM_WORLD, &result);
  if (result==MPI_IDENT || result==MPI_CONGRUENT) // no mapping of MPI_IO reqd.
    ioProc = *mpiIOP;
  else { // MPI_IO can only be mapped to comm in special cases
    int world_rank;
    errorCode = MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);
    if (errorCode) 
    if (*mpiIOP == world_rank) // MPI_IO processor is this processor
      ioProc = rank; // MPI_IO in MPI_COMM_WORLD maps to rank in comm
    else
      ioProc = size; // no mapping of MPI_IO to comm is possible.  Assign size
                     // so that reduce works properly.
  int elected;
  reduce(&ioProc,&elected,1,MPI_INT,MPI_MIN,0);
  ioProc = elected;
  broadcast(&ioProc,1,MPI_INT,0);
  if ((ioProc < 0) || (ioProc >= size))
    ioProc = 0;
  iDoIO = (rank == ioProc);
  CommonIO::begin_tagging();
void uMPI::done()
  CommonIO::end_tagging();
  MPI_Finalize();
int uMPI::sizeOf(MPI_Datatype t)
  MPI_Aint extent;
  errorCode = MPI_Type_extent(t,&extent);
  if (errorCode)
  return extent;
void uMPI::killSendRequest(MPI_Request* request)
  if (*request != MPI_REQUEST_NULL)
    {
      MPI_Status trashStatus;
      if (!test(request,&trashStatus))
#ifndef COUGAR
	  cancel(request);
	  wait(request,&trashStatus);
#else
	  MPI_Request_free(request);
#endif
      *request = MPI_REQUEST_NULL;
    }
void uMPI::killRecvRequest(MPI_Request* request)
  if (*request != MPI_REQUEST_NULL)
    {
      MPI_Status trashStatus;
      if (!test(request,&trashStatus))
#ifndef COUGAR
	  cancel(request);
	  wait(request,&trashStatus);
#else
	  MPI_Request_free(request);
#endif
      *request = MPI_REQUEST_NULL;
    }
#ifdef EVENT_LOGGING_PRESENT
CLASS_PARAMETER_DEF(uMPI,messageLog,0,0,1);
void uMPI::logSend(int dest,int tag,int count,MPI_Datatype t)
  int typeSize;
  errorCode = MPI_Type_size(t,&typeSize);
  if (errorCode)
  MPE_Log_send(dest,tag,count*typeSize);
void uMPI::logRecv(MPI_Status* status)
  MPE_Log_receive(status->MPI_SOURCE,
		  status->MPI_TAG,
		  getCount(status,MPI_PACKED));
#endif
#endif
// nicePrint.C
// Helper functions for printing
// Jonathan Eckstein
#ifdef __GNUC__
#endif
#include <math.h>
#include <iostream.h>
int digitsNeededFor(double value)
  if (fabs(value) > 0.0)
    return max((int) floor(log10(fabs(value))) + 1,1);
  else
    return 1;
ostream& hyphens(ostream& stream,int n)
  stream.width(n);
  stream.fill('-');
  stream.fill(' ');
  return stream;
const char* plural(int count,const char* suffix)
  if (count == 1)
  else
    return suffix;
ostream& printPercent(ostream& stream,
		      double numerator, 
		      double denominator)
  stream.setf(ios::fixed,ios::floatfield);
  int oldPrecision = stream.precision(1);
  stream.width(5);
  if (denominator != 0)
    stream << 100*numerator/denominator;
  else if (numerator == 0)
    stream << 0.0;
  else
  stream.unsetf(ios::floatfield);
  stream.precision(oldPrecision);
  stream << '%';
  return stream;
// PackBuf.cpp
#ifdef __GNUC__
#endif
           
#include <iostream.h>
#include <memory.h>
#ifdef USING_MPI
#endif
void PackBuffer::resize(const int newsize)
if ((index+newsize) >= size) {
   size *= 2;
   char* tmp = new char [size];
   memcpy(tmp,buffer,index);
   if (buffer)
      delete buffer;
   buffer = tmp;
   }
#ifdef USING_MPI
#define PACKBUF(type,mpitype)	\
void PackBuffer::pack(const type* data, const int num) \
resize(PackSize(data[0],num)); \
MPI_Pack((void*)data, num, mpitype, buffer, size, &index, MPI_COMM_WORLD); \
#else
#define PACKBUF(type,mpitype)	\
void PackBuffer::pack(const type* /*data*/, const int /*num*/) \
#endif
PACKBUF(int,MPI_INT)
PACKBUF(unsigned_int,MPI_UNSIGNED)
PACKBUF(long,MPI_LONG)
PACKBUF(unsigned_long,MPI_UNSIGNED_LONG)
PACKBUF(short,MPI_SHORT)
PACKBUF(unsigned_short,MPI_UNSIGNED_SHORT)
PACKBUF(char,MPI_CHAR)
PACKBUF(unsigned_char,MPI_UNSIGNED_CHAR)
PACKBUF(double,MPI_DOUBLE)
PACKBUF(float,MPI_FLOAT)
#ifdef USING_MPI
void PackBuffer::pack(const bool* data, const int num)
resize(num*PackSize(data[0],1));
for (int i=0; i<num; i++) {
  char c;
  if (data[i])
     c = 'T';
  else
     c = 'F';
  MPI_Pack((void*)(&c), 1, MPI_CHAR, buffer, size, &index, MPI_COMM_WORLD);
#else
void PackBuffer::pack(const bool* /*data*/, const int /*num*/)
#endif
void UnPackBuffer::resize(const int newsize)
if (newsize != size) {
   size = newsize;
   if (buffer)
      delete buffer;
   buffer = new char [size];
   }
void UnPackBuffer::setup(char* buf_, int size_, int flag)
if (buffer && own_flag) {
   delete [] buffer;
   }
index=0; 
size=size_; 
buffer=buf_; 
own_flag=flag;
#ifdef USING_MPI
#define UNPACKBUF(type,mpitype)   \
void UnPackBuffer::unpack(type* data, const int num) \
MPI_Unpack(buffer, size, &index, (void*)data, num, mpitype, MPI_COMM_WORLD); \
#else
#define UNPACKBUF(type,mpitype)   \
void UnPackBuffer::unpack(type* /*data*/, const int /*num*/) \
#endif
UNPACKBUF(int,MPI_INT)
UNPACKBUF(unsigned_int,MPI_UNSIGNED)
UNPACKBUF(long,MPI_LONG)
UNPACKBUF(unsigned_long,MPI_UNSIGNED_LONG)
UNPACKBUF(short,MPI_SHORT)
UNPACKBUF(unsigned_short,MPI_UNSIGNED_SHORT)
UNPACKBUF(char,MPI_CHAR)
UNPACKBUF(unsigned_char,MPI_UNSIGNED_CHAR)
UNPACKBUF(double,MPI_DOUBLE)
UNPACKBUF(float,MPI_FLOAT)
#ifdef USING_MPI
void UnPackBuffer::unpack(bool* data, const int num)
for (int i=0; i<num; i++) {
  char c;
  MPI_Unpack(buffer, size, &index, (void*)(&c), 1, MPI_CHAR, MPI_COMM_WORLD); \
  if (c == 'T')
     data[i] = true;
  else
     data[i] = false;
#else
void UnPackBuffer::unpack(bool* /*data*/, const int /*num*/)
#endif
#ifdef USING_MPI
#define PACKSIZE(type,mpitype)	\
int PackSize(const type& /*data*/, const int num) \
int size; \
MPI_Pack_size(num, mpitype, MPI_COMM_WORLD, &size); \
return size; \
#else
#define PACKSIZE(type,mpitype)	\
int PackSize(const type& /*data*/, const int /*num*/) \
return 0;\
#endif
#ifdef USING_MPI
int PackSize(const bool& /*data*/, const int num)
int size; 
MPI_Pack_size(num, MPI_CHAR, MPI_COMM_WORLD, &size);
return size;
#else
int PackSize(const bool& /*data*/, const int /*num*/)
return 0;
#endif
PACKSIZE(int,MPI_INT)
PACKSIZE(unsigned_int,MPI_UNSIGNED)
PACKSIZE(long,MPI_LONG)
PACKSIZE(unsigned_long,MPI_UNSIGNED_LONG)
PACKSIZE(short,MPI_SHORT)
PACKSIZE(unsigned_short,MPI_UNSIGNED_SHORT)
PACKSIZE(char,MPI_CHAR)
PACKSIZE(unsigned_char,MPI_UNSIGNED_CHAR)
PACKSIZE(double,MPI_DOUBLE)
PACKSIZE(float,MPI_FLOAT)
// paramTable.C
//  Class that allows reading named numeric parameters from the command line
//  via -<paramName>=<value> or from a file via -param=<file>.
// Jonathan Eckstein
#ifdef __GNUC__
#endif
#include <iostream.h>
#include <fstream.h>
#include <string.h>
#include <strings.h>
#include <stdio.h>
#include <unistd.h>
#include <errmsg.h>
#ifdef USING_MPI
#endif
int parameter::numParameters = 0;
parameter* parameter::hashHeader[parameter::tableSize];
parameter::parameter(const char* name_,
		     double minValue_,
		     double value_,
		     double maxValue_) :
		     value(value_),
		     maxValue(maxValue_),
		     minValue(minValue_),
		     name(name_),
		     changeCounter(0)
		     
  if (numParameters++ == 0)
    for(int i=0; i<tableSize; i++)
      hashHeader[i] = 0;
  if ((minValue > maxValue) ||
      (value < minValue)    ||
      (value > maxValue))
		name,minValue,value,maxValue);
  int hashValue = hash(name);
  if (lookup(name,hashValue))
  prev = 0;
  next = hashHeader[hashValue];
  if (next)
    next->prev = this;
  hashHeader[hashValue] = this;
parameter::~parameter()
  if (prev)
    prev->next = next;
  else
    hashHeader[hash(name)] = next;
  if (next)
    next->prev = prev;
void parameter::changeValue(double newValue)
  if (newValue < minValue)
		name,newValue,minValue);
  else if (newValue > maxValue)
		name,newValue,maxValue);
  value = newValue;
  changeCounter++;
// Read in information on one processor.
void parameter::parseLine(int argc,char** argv,int minArgs,int maxArgs)
  int argCount = 0;
  for(int arg=1; arg<argc; arg++)
    {
      char* c = argv[arg];
      if (*c == '-')                            // Does this look like a param?
	  CharString name(strlen(c++));         // Make buffer for param name
	  {
	    char* n = name;
	    while ((*c) && (*c != '='))         // Copy name to separate buffer
	      *(n++) = *(c++);                  // stop at '=' or null
	    *n = '\0';
	  }
	  if ((*c) && !(*(++c)))                    
			(char*)name);
	    readFromFile(c);
	  else 
	    {
	      parameter* param = lookup(name);  // No, find param name
	      if (param)
		{                               // If found, set value
		  if (*c)
		    param->changeValue(convert(c,name));
		  else
		    param->changeValue(1);      // If no value given, set to 1
	      else
	    }						
      else
	argCount++;
    }
  if (argCount < minArgs)
		minArgs,plural(minArgs));
  if (argCount > maxArgs)
		maxArgs,plural(maxArgs));
// To read from a file
void parameter::readFromFile(const char* fileName)
  istream* s;
  if (fileName && *fileName)              // Open a file, if specified.
    {
      s = new ifstream(fileName);
      if (!s->good())
		    fileName,getcwd(0,256));
    }
  else
    {
      s = &cin;
    }
  char buffer[4096];
  while(!(s->eof())) 
    {
      *s >> whitespace;
      if (s->eof())
	break;
      *s >> buffer;
      if (*buffer == '*')
	for(char c='\0'; (c != '\n') && !(s->eof()); s->get(c));
      else 
	  parameter* param = lookup(buffer);
	  if (!param)
	  *s >> whitespace >> buffer;
	  if (s->eof())
	  param->changeValue(convert(buffer,param->name));
    }
  if (s != &cin)
    delete s;
// To convert values from string to float.
double parameter::convert(const char* buffer, const char* errorKey)
  double value;
    return 1;
    return 0;
		errorKey,buffer);
  return value;
// To handle reading in on (possibly) multiple processors.
void parameter::readAll(int argc,char** argv,int minArgs,int maxArgs)
#ifndef USING_MPI
  parseLine(argc,argv,minArgs,maxArgs);
#else
  if (!uMPI::running())
    {
      parseLine(argc,argv,minArgs,maxArgs);
      return;
    }
  double* buffer  = new double[numParameters];
  int*    ibuffer = new int[numParameters];
  int i = 0;
  int list;
  if (uMPI::iDoIO)
    {
      parseLine(argc,argv,minArgs,maxArgs);
      //double* cursor = buffer;
      for(list=0; list<tableSize; list++)
	for(parameter* param=hashHeader[list]; param; param=param->next)
	  {
	    buffer[i]  = param->value;
	    ibuffer[i] = param->changeCounter;
	    i++;
	  }
    }
  uMPI::broadcast(buffer,numParameters,MPI_DOUBLE,uMPI::ioProc);
  uMPI::broadcast(ibuffer,numParameters,MPI_INT,uMPI::ioProc);
  i = 0;
  if (!uMPI::iDoIO)
    for(list=0; list<tableSize; list++)
      for(parameter* param=hashHeader[list]; param; param=param->next)
	  param->value = buffer[i];
	  param->changeCounter = ibuffer[i];
	  i++;
  delete[] buffer;
  delete[] ibuffer;
#endif
	    
	    
// Hash function lifted from Kernighan and Richie.
unsigned int parameter::hash(const char* name_)
  unsigned int hashValue = 0;
  while(*name_)
    hashValue = *(name_++) + 31*hashValue;
  return hashValue % (unsigned int) tableSize;
parameter* parameter::lookup(const char* name_,int hashValue_)
  parameter *ptr;
  for(ptr = hashHeader[hashValue_];
      ptr && strcmp(name_,ptr->name);
      ptr = ptr->next);
  return ptr;
// sync_io.cpp
// IO file containing sync information for printing with multiple
// processors
// Currently, this software only works if the MPI flag is set
#ifdef STDLIB_MPI
#endif
#define PRINT_MARKER_REQUEST    102
#define PRINT_MARKER_RETURN     103
#define HOST_NODE 0
#ifndef FALSE
#define FALSE	0
#endif
#ifndef FALSE
#define TRUE	1
#endif
#ifndef NULL
#define NULL 0
#endif
static int sync_print_flag=FALSE;
static int print_marker_status=FALSE;
void set_sync_print(const int flag)
sync_print_flag=flag;
void clear_print_marker_queue()
#ifdef STDLIB_MPI
if ((mpMaxNodes() > 1) && (sync_print_flag==TRUE) && (mpMyID() == HOST_NODE)) {
   while (mpATest(PRINT_MARKER_REQUEST) == TRUE) {
     int tmp;
     mpRecv(PRINT_MARKER_REQUEST,NULL,0);
     tmp = mpLastProcessor();
     if (print_marker_status != HOST_NODE) {
        mpRecv(PRINT_MARKER_RETURN,NULL,0);
        if (mpLastProcessor() != print_marker_status) {
	   (*bbums_cerr).flush();
	   }
        }
     print_marker_status = tmp;
     mpASend(PRINT_MARKER_REQUEST,NULL,0,tmp);
     }
   }
#endif
void get_print_marker()
#ifdef STDLIB_MPI
if ((mpMaxNodes() > 1) && (sync_print_flag == TRUE)) {
  if (mpMyID() == HOST_NODE) {
     //
     // Handle all other requests first
     //
     clear_print_marker_queue();
     // 
     // Get the marker if I don't have it already
     //
     if (print_marker_status == HOST_NODE)
        return;
     mpRecv(PRINT_MARKER_RETURN,NULL,0);
     if (mpLastProcessor() != print_marker_status) {
        (*bbums_cerr).flush();
        }
     print_marker_status = HOST_NODE;
     }
  else {
    if (print_marker_status == FALSE) {
       mpSend(PRINT_MARKER_REQUEST,NULL,0,HOST_NODE);
       mpRecv(PRINT_MARKER_REQUEST,NULL,0);
       print_marker_status = TRUE;
       }
    }
#endif
void return_print_marker()
#ifdef STDLIB_MPI
if ((mpMaxNodes() > 1) && (sync_print_flag == TRUE))
   if ((mpMyID() != 0) && (print_marker_status == TRUE)){
      mpASend(PRINT_MARKER_RETURN,NULL,0,HOST_NODE);
      print_marker_status = FALSE;
      }
#endif
/* Cholesky Decomposition
 * This code assumes that A is symmetric positive definite.  It generates
 *	a lower triangular G s.t. A = G*G'.
 * This code assumes that the memory in G has been allocated contiguously.
#include <math.h>
#ifdef USE_LINPACK
/* Note:  This code only utilizes the lower triangular parts of A and G.  
	The user can call this routine with the same matrix for G as for A
	as long as the memory for A has been allocated contiguously.
int cholesky(DoubleMatrix& A, DoubleMatrix& G, int n, double* rcond)
int info;
int i,j;
if (A != G) 
   for (i=0; i<n; i++)
     for (j=0; j<=i; j++)
       G[i][j] = A[i][j];
if (rcond != NULL) {
   DoubleVector Z(n);
   dpoco_(&(G[0][0]), &n, &n, rcond, Z.data(), &info);
   }
else
   dpofa_(&(G[0][0]), &n, &n, &info);
if (info != 0) return ERR;
return OK;
#else
/* Note:  This code only utilizes the upper triangular part of G.  The user
	can call this routine with the same matrix for G as for A.
int cholesky(DoubleMatrix& A, DoubleMatrix& G, int n)
int k, i;
for (k=0; k<n; k++) {
  {double tmp=0.0;
   int p;
   for (p=0; p<(k-1); p++)
     tmp += A[k][p] * A[k][p];
   G[k][k] = sqrt( A[k][k] - tmp );
  for (i=k; i<n; i++) {
    double tmp=0.0;
    int p;
    for (p=0; p<(k-1); p++)
      tmp += A[i][p] * A[k][p];
    G[i][k] = (A[i][k] - tmp) / A[k][k];
    }
return 0;
#endif
/**  Stuff for testing the code.
static double staticA[5][5] = {	{ 4,  6,   8,  10,  12},
				{ 6, 25,  32,  39,  46},
				{ 8, 32,  77,  92, 107},
				{10, 39,  92, 174, 200},
				{12, 46, 107, 200, 330}};
main()
int i,j, status;
double** A;
double rcond;
A = dmatrix(0,4,0,4);
for (i=0; i<5; i++) {
  for (j=0; j<5; j++) {
    A[i][j] = staticA[i][j];
status = cholesky(A,A,5,&rcond);
for (i=0; i<5; i++) {
  for (j=0; j<5; j++) {
    }
// _math.cpp
// Miscellaneous routines which work on arrays and vectors
#ifdef __GNUC__
#pragma implementation
#endif
//D.E. Knuth, The Art of Computer Programming
//Volume 2, Seminumerical Algorithms (2d ed.)
//ISBN 0-201-03822-6 (v. 2)
//Algorithm P (Shuffling), page 139.
//Knuth gives additional references, including where this algorithm was
//first published. See p. 140.
void shuffle(BitArray& vec, RNG* rng)
size_type j;
Uniform urnd(rng);
int tempj;
for (size_type i = 0; i<vec.size(); i++) {
  j = Discretize(urnd(), i, vec.size()-1);
  tempj = vec(j);
  vec.put(j,vec(i));
  vec.put(i,tempj);
// median.C
// Developed using ideas from Corman, Lieseron and Rivest
// This code uses a (user supplied) work space to avoid modifying the
// original array.
static int rand_select(double* x, int p, int r, int i, int* ws, DUniform& drnd);
static int partition(double* x, int p, int r, int* ws)
double X = x[ws[p]];
int i = p-1;
int j=r+1;
while (1) {
  while (X< x[ws[--j]]);
  while (x[ws[++i]] < X);
  if (i<j) {
     int tmp = ws[i];
     ws[i] = ws[j];
     ws[j] = tmp;
     }
  else
     return j;
static int rand_partition(double* x, int p, int n, int* ws, DUniform& drnd)
drnd.low(p);
drnd.high(n);
int i = drnd();
int tmp = ws[i];
ws[i] = ws[p];
ws[p] = tmp;
return partition(x,p,n,ws);
size_type argmedian(double* x, size_type n, int* ws, RNG* rng)
int delete_flag=FALSE;
if (!ws) {
   ws = new int [n];
   delete_flag=TRUE;
   }
for (size_type i=0; i<n; i++)
  ws[i] = i;
if (!rng)
   rng = &default_rng;
DUniform drnd(rng);
int ans = rand_select(x,0,n-1,(n+1)/2,ws,drnd);
if (delete_flag)
   delete [] ws;
return ans;
double median(double* x, size_type n, int* ws, RNG* rng)
{ return x[argmedian(x,n, ws, rng)]; }
static int rand_select(double* x, int p, int r, int i, int* ws, DUniform& drnd)
if (p == r) return ws[p];
int q = rand_partition(x,p,r,ws,drnd);
int k = q-p+1;				// Size of the LHS of the partition
if (i <= k)
   return rand_select(x,p,q,i,ws,drnd);
else
   return rand_select(x,q+1,r,i-k,ws,drnd);
#ifdef USING_OLD_CODE
// OLD CODE
#ifdef OLD_MEDIAN
/* median.cpp
 * Adapted from Numerical Recipies routine mdian2.
 * The mediand command sorts the vector!
 * The argmedd routine does not work!
#include <math.h>
#include <stdio.h>
#define BIG 1.0e30
#define AFAC 1.5
#define AMP 1.5
double mediand(double* x, int n)
int med;
if (n == 1)
   return x[0];
sortd(x,n);
med = n/2;
if (n%2 == 0)
   return x[med];
else
   return ((x[med]+x[med+1])*0.5);
int argmedd(double* x, int n)
int np,nm,ne,j;
double xx,sumx,sum,eps,stemp,dum,aa;
int xm_ndx, xp_ndx;	/* Indeces of points closest to the median */
double ap, am;		/* Lower and upper bounds on the median */
double a;		/* value of the answer */
int ans;		/* Index to the answer */
a = x[n/2];
am = -(ap=BIG);
eps = fabs(a);
for (;;) {
  sum = sumx = 0.0;
  np = nm = ne = 0;
  ans = xm_ndx = xp_ndx = -1;
  for (j=0; j<n; j++) {
    xx=x[j];
    if (xx == a) {
       ne++;
       ans = j;
       }
    else {
       if (xx > a) {
          ++np;
          if ((xp_ndx == -1) || (xx < x[xp_ndx])) xp_ndx=j;
          }
       else {  /* xx < a */
          ++nm;
          if ((xm_ndx == -1) || (xx > x[xm_ndx])) xm_ndx=j;
          }
       sum += dum=1.0/(eps+fabs(xx-a));
       sumx += xx*dum;
       }
    }
fflush(stdout);
  stemp=(sumx/sum)-a;
  if ( ((ne == 0) && ((np-nm) >= 2)) || ((np-nm) >= (1+ne)) ) {
     am=a;
     aa =  stemp < 0.0 ? x[xp_ndx] : x[xp_ndx]+stemp*AMP;
     if (aa > ap) 
        aa=0.5*(a+ap);
     eps=AFAC*fabs(aa-a);
     a=aa;
     }
  else if ( ((ne == 0) && (nm-np >= 2)) || (nm-np >= 1+ne) ){
     ap=a;
     aa = stemp > 0.0 ? x[xm_ndx] : x[xm_ndx]+stemp*AMP;
     if (aa < am)
        aa=0.5*(a+am);
     eps=AFAC*fabs(aa-a);
     a=aa;
     }
  else {
     if (n % 2 == 0) {
        if ((ne > 0) && (np > nm))
           return ans;
 	else
	   return xm_ndx;
     else {
	if (ne > 0)
	   return ans;
	else
	   return (np > nm ? xp_ndx : xm_ndx);
     }
#undef BIG
#undef AFAC
#undef AMP
#endif
#endif
int main()
DoubleVector vec(101);
IntVector ws(101);
LCG* rng = new LCG(100);
for (int i=0; i<10; i++) {
  int ans=0;
  for (int j=0; j<vec.len(); j++)
    vec[j] = j;
  shuffle(vec,rng);
  ans = argmedian(vec,vec.len(),ws);
  //if (vec[ans] != 49)
  //   cout << vec[ans] << endl;
return 0;
// python_main.cpp
// This C++ file extends the functionality of the embed15.i file included
// with SWIG to enable the inclusion of multiple modules defined by the user.
// embed15.i
// SWIG file embedding the Python interpreter in something else.
// This file is based on Python-1.5.  It will not work with
// earlier versions.
// This file makes it possible to extend Python and all of its
// built-in functions without having to hack it's setup script.
This module provides support for building a new version of the
Python executable.  This will be necessary on systems that do
not support shared libraries and may be necessary with C++
extensions.  This file contains everything you need to build
a new version of Python from include files and libraries normally
installed with the Python language.
This module will automatically grab all of the Python modules
present in your current Python executable (including any special
purpose modules you have enabled such as Tkinter).   Thus, you
may need to provide additional link libraries when compiling.
This library file only works with Python 1.5.  A version 
compatible with Python 1.4 is available as embed14.i and
a Python1.3 version is available as embed13.i.    As far as
I know, this module is C++ safe.
#include <Python.h>
#ifdef __cplusplus
#endif
void SWIG_init();  /* Forward reference */
#ifdef __cplusplus
#endif
void initutilibc();
#define _PyImport_Inittab swig_inittab
/* Grab Python's inittab[] structure */
#ifdef __cplusplus
#endif
extern int Py_Main(int, char **);
#include <config.c>
#undef _PyImport_Inittab 
/* Now define our own version of it.
   Hopefully someone does not have more than 1000 built-in modules */
struct _inittab _SwigImport_Inittab[1000];       
static int  swig_num_modules = 0;
/* Function for adding modules to Python */
void swig_add_module(char *name, void (*initfunc)()) {
	_SwigImport_Inittab[swig_num_modules].name = name;
	_SwigImport_Inittab[swig_num_modules].initfunc = initfunc;
	swig_num_modules++;
	_SwigImport_Inittab[swig_num_modules].name = (char *) 0;
	_SwigImport_Inittab[swig_num_modules].initfunc = 0;
}				
/* Function to add all of Python's build in modules to our interpreter */
static void swig_add_builtin() {
	int i = 0;
	while (swig_inittab[i].name) {
		swig_add_module(swig_inittab[i].name, swig_inittab[i].initfunc);
  	        i++;
        //
        // Specify the user-defined modules here!!!!
        //
	// Provide a hook for extensions that add additional modules
	augment_pyutilib_modules();
extern struct _inittab *PyImport_Inittab;
int python_main(int argc, char **argv) {
	swig_add_builtin();
	PyImport_Inittab = _SwigImport_Inittab;
	return Py_Main(argc,argv);
#ifdef __cplusplus
#endif
// pyutilib.cpp
int main(int argc, char** argv)
return pyutilib_main(argc, argv);
 * FILE : utilib_wrap.c
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * Do not make changes to this file--changes will be lost!
#define SWIGCODE
#undef _DEBUG
/* Implementation : PYTHON */
#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif
#ifdef __cplusplus
#endif
extern void SWIG_MakePtr(char *, void *, char *);
extern void SWIG_RegisterMapping(char *, char *, void *(*)(void *));
extern char *SWIG_GetPtr(char *, void **, char *);
extern void SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
extern PyObject *SWIG_newvarlink(void);
#ifdef __cplusplus
#endif
#define SWIG_init    initutilibc
#include <iostream.h>
#include <fstream.h>
static char* read_common_cin(int n)
char* str = new char [n+1];
int i=0;
while (cin && (i<n))
  cin.get(str[i++]);
str[i] = '\000';
return str;
RealVector foo()
RealVector* tmp = new RealVector;
return *tmp;
static PyObject *_wrap_bitwise_or(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    BitArray * _arg1;
    BitArray * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    _result = (int )bitwise_or(*_arg0,*_arg1,*_arg2);
    return _resultobj;
static PyObject *_wrap_bitwise_xor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    BitArray * _arg1;
    BitArray * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    _result = (int )bitwise_xor(*_arg0,*_arg1,*_arg2);
    return _resultobj;
static PyObject *_wrap_calc_filesize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    char * _arg0;
    self = self;
        return NULL;
    _result = (int )calc_filesize(_arg0);
    return _resultobj;
static PyObject *_wrap_CPUSeconds(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    self = self;
        return NULL;
    _result = (double )CPUSeconds();
    return _resultobj;
static PyObject *_wrap_WallClockSeconds(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    self = self;
        return NULL;
    _result = (double )WallClockSeconds();
    return _resultobj;
static PyObject *_wrap_ElapsedCPUSeconds(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    self = self;
        return NULL;
    _result = (double )ElapsedCPUSeconds();
    return _resultobj;
static PyObject *_wrap_ElapsedWallClockSeconds(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    self = self;
        return NULL;
    _result = (double )ElapsedWallClockSeconds();
    return _resultobj;
static PyObject *_wrap_InitializeTiming(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    self = self;
        return NULL;
    _result = (int )InitializeTiming();
    return _resultobj;
static PyObject *_wrap_round(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    double  _arg0;
    self = self;
        return NULL;
    _result = (int )round(_arg0);
    return _resultobj;
static PyObject *_wrap_shuffle(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _arg0;
    RNG * _arg1 = &default_rng;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    shuffle(*_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_subshuffle(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _arg0;
    RNG * _arg1;
    int  _arg2;
    int  _arg3;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    subshuffle(*_arg0,_arg1,_arg2,_arg3);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_sum(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )sum(*_arg0);
    return _resultobj;
static PyObject *_wrap_length(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )length(*_arg0);
    return _resultobj;
static PyObject *_wrap_dist(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    BasicArray_double * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (double )dist(*_arg0,*_arg1);
    return _resultobj;
static PyObject *_wrap_covariance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    double ** _arg0;
    int  _arg1;
    int  _arg2;
    double ** _arg3;
    char * _argc0 = 0;
    char * _argc3 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    _result = (int )covariance(_arg0,_arg1,_arg2,_arg3);
    return _resultobj;
static PyObject *_wrap_argmedian(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    double * _arg0;
    int  _arg1;
    int * _arg2 = 0;
    RNG * _arg3 = 0;
    char * _argc0 = 0;
    char * _argc2 = 0;
    char * _argc3 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    _result = (int )argmedian(_arg0,_arg1,_arg2,_arg3);
    return _resultobj;
static PyObject *_wrap_median(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    double * _arg0;
    int  _arg1;
    int * _arg2 = 0;
    RNG * _arg3 = 0;
    char * _argc0 = 0;
    char * _argc2 = 0;
    char * _argc3 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    _result = (double )median(_arg0,_arg1,_arg2,_arg3);
    return _resultobj;
static PyObject *_wrap_concat(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _result;
    BasicArray_double * _arg0;
    BasicArray_double * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = new BasicArray_double (concat(*_arg0,*_arg1));
    return _resultobj;
static PyObject *_wrap_trimmed_mean(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    double  _arg1 = 0.1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )trimmed_mean(*_arg0,_arg1);
    return _resultobj;
static PyObject *_wrap_mean(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )mean(*_arg0);
    return _resultobj;
static PyObject *_wrap_var(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    int  _arg1 = FALSE;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )var(*_arg0,_arg1);
    return _resultobj;
static PyObject *_wrap_mad(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    BasicArray_double * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (double )mad(*_arg0,*_arg1);
    return _resultobj;
static PyObject *_wrap_rowscale(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Basic2DArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    rowscale(*_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_argmin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )argmin(*_arg0);
    return _resultobj;
static PyObject *_wrap_min(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )min(*_arg0);
    return _resultobj;
static PyObject *_wrap_argmax(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )argmax(*_arg0);
    return _resultobj;
static PyObject *_wrap_max(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )max(*_arg0);
    return _resultobj;
static PyObject *_wrap_cout_print(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _arg0;
    self = self;
        return NULL;
    cout_print(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_cerr_print(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _arg0;
    self = self;
        return NULL;
    cerr_print(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_Discretize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    double  _arg0;
    int  _arg1;
    int  _arg2;
    self = self;
        return NULL;
    _result = (int )Discretize(_arg0,_arg1,_arg2);
    return _resultobj;
static PyObject *_wrap_foo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RealVector * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = new RealVector (foo());
    return _resultobj;
#define new_BitArray() (new BitArray())
static PyObject *_wrap_new_BitArray(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (BitArray *)new_BitArray();
    return _resultobj;
#define delete_BitArray(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BitArray(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_BitArray(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_resize(_swigobj,_swigarg0)  (_swigobj->resize(_swigarg0))
static PyObject *_wrap_BitArray_resize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BitArray_resize(_arg0,_arg1);
    return _resultobj;
#define BitArray_len(_swigobj)  (_swigobj->len())
static PyObject *_wrap_BitArray_len(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BitArray_len(_arg0);
    return _resultobj;
#define BitArray_calc_nbits(_swigobj)  (_swigobj->calc_nbits())
static PyObject *_wrap_BitArray_calc_nbits(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BitArray_calc_nbits(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_nbits(_swigobj)  (_swigobj->nbits())
static PyObject *_wrap_BitArray_nbits(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BitArray_nbits(_arg0);
    return _resultobj;
#define BitArray_nrefs(_swigobj)  (_swigobj->nrefs())
static PyObject *_wrap_BitArray_nrefs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BitArray_nrefs(_arg0);
    return _resultobj;
#define BitArray_data(_swigobj)  (_swigobj->data())
static PyObject *_wrap_BitArray_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _result;
    BitArray * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (char *)BitArray_data(_arg0);
    return _resultobj;
#define BitArray_set(_swigobj,_swigarg0)  (_swigobj->set(_swigarg0))
static PyObject *_wrap_BitArray_set(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    int  _arg1 = -1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BitArray_set(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_reset(_swigobj,_swigarg0)  (_swigobj->reset(_swigarg0))
static PyObject *_wrap_BitArray_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    int  _arg1 = -1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BitArray_reset(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_flip(_swigobj,_swigarg0)  (_swigobj->flip(_swigarg0))
static PyObject *_wrap_BitArray_flip(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    int  _arg1 = -1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BitArray_flip(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_put(_swigobj,_swigarg0,_swigarg1)  (_swigobj->put(_swigarg0,_swigarg1))
static PyObject *_wrap_BitArray_put(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _arg0;
    int  _arg1;
    int  _arg2;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BitArray_put(_arg0,_arg1,_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BitArray_compare(_swigobj,_swigarg0)  (_swigobj->compare(_swigarg0))
static PyObject *_wrap_BitArray_compare(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    BitArray * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )BitArray_compare(_arg0,*_arg1);
    return _resultobj;
#define BitArray_at(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->at(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_BitArray_at(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BitArray * _result;
    BitArray * _arg0;
    int  _arg1 = 0;
    int  _arg2 = -1;
    EnumDataOwned  _arg3 = (DataNotOwned);
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = new BitArray (BitArray_at(_arg0,_arg1,_arg2,_arg3));
    return _resultobj;
#define BitArray_write(_swigobj,_swigarg0)  (_swigobj->write(_swigarg0))
static PyObject *_wrap_BitArray_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    ostream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )BitArray_write(_arg0,*_arg1);
    return _resultobj;
#define BitArray_read(_swigobj,_swigarg0)  (_swigobj->read(_swigarg0))
static PyObject *_wrap_BitArray_read(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    istream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )BitArray_read(_arg0,*_arg1);
    return _resultobj;
static int  BitArray___call__(BitArray *self,int  i) {
	return self->operator()(i);
static PyObject *_wrap_BitArray___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BitArray * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BitArray___call__(_arg0,_arg1);
    return _resultobj;
#define new_CharString() (new CharString())
static PyObject *_wrap_new_CharString(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CharString * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (CharString *)new_CharString();
    return _resultobj;
#define delete_CharString(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_CharString(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CharString * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_CharString(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define CharString_resize(_swigobj,_swigarg0)  (_swigobj->resize(_swigarg0))
static PyObject *_wrap_CharString_resize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CharString * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CharString_resize(_arg0,_arg1);
    return _resultobj;
#define CharString_len(_swigobj)  (_swigobj->len())
static PyObject *_wrap_CharString_len(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CharString * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CharString_len(_arg0);
    return _resultobj;
#define CharString_data(_swigobj)  (_swigobj->data())
static PyObject *_wrap_CharString_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    charptr  _result;
    CharString * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (charptr )CharString_data(_arg0);
    return _resultobj;
#define CharString_nrefs(_swigobj)  (_swigobj->nrefs())
static PyObject *_wrap_CharString_nrefs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CharString * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CharString_nrefs(_arg0);
    return _resultobj;
#define CharString_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)  (_swigobj->set_subvec(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
static PyObject *_wrap_CharString_set_subvec(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CharString * _result;
    CharString * _arg0;
    int  _arg1;
    int  _arg2;
    CharString * _arg3;
    int  _arg4 = 0;
    char * _argc0 = 0;
    char * _argc3 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    CharString & _result_ref = CharString_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
    _result = (CharString *) &_result_ref;
    return _resultobj;
#define CharString_write(_swigobj,_swigarg0)  (_swigobj->write(_swigarg0))
static PyObject *_wrap_CharString_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CharString * _arg0;
    ostream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )CharString_write(_arg0,*_arg1);
    return _resultobj;
#define CharString_read(_swigobj,_swigarg0)  (_swigobj->read(_swigarg0))
static PyObject *_wrap_CharString_read(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CharString * _arg0;
    istream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )CharString_read(_arg0,*_arg1);
    return _resultobj;
static char  CharString___getitem__(CharString *self,int  i) {
	return self->operator[](i);
        }
static PyObject *_wrap_CharString___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char  _result;
    CharString * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (char )CharString___getitem__(_arg0,_arg1);
    return _resultobj;
static void  CharString___setitem__(CharString *self,int  i,char  val) {
	self->operator[](i) = val;
        }
static PyObject *_wrap_CharString___setitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CharString * _arg0;
    int  _arg1;
    char  _arg2;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    CharString___setitem__(_arg0,_arg1,_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define new_BasicArray_int() (new BasicArray_int())
static PyObject *_wrap_new_BasicArray_int(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_int * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (BasicArray_int *)new_BasicArray_int();
    return _resultobj;
#define delete_BasicArray_int(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BasicArray_int(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_int * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_BasicArray_int(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BasicArray_int_resize(_swigobj,_swigarg0)  (_swigobj->resize(_swigarg0))
static PyObject *_wrap_BasicArray_int_resize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_int * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_int_resize(_arg0,_arg1);
    return _resultobj;
#define BasicArray_int_len(_swigobj)  (_swigobj->len())
static PyObject *_wrap_BasicArray_int_len(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_int * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_int_len(_arg0);
    return _resultobj;
#define BasicArray_int_data(_swigobj)  (_swigobj->data())
static PyObject *_wrap_BasicArray_int_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    intptr  _result;
    BasicArray_int * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (intptr )BasicArray_int_data(_arg0);
    return _resultobj;
#define BasicArray_int_nrefs(_swigobj)  (_swigobj->nrefs())
static PyObject *_wrap_BasicArray_int_nrefs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_int * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_int_nrefs(_arg0);
    return _resultobj;
#define BasicArray_int_set_data(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->set_data(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_BasicArray_int_set_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_int * _result;
    BasicArray_int * _arg0;
    int  _arg1;
    int * _arg2;
    EnumDataOwned  _arg3 = (DataNotOwned);
    char * _argc0 = 0;
    char * _argc2 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    BasicArray_int & _result_ref = BasicArray_int_set_data(_arg0,_arg1,_arg2,_arg3);
    _result = (BasicArray_int *) &_result_ref;
    return _resultobj;
#define BasicArray_int_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)  (_swigobj->set_subvec(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
static PyObject *_wrap_BasicArray_int_set_subvec(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_int * _result;
    BasicArray_int * _arg0;
    int  _arg1;
    int  _arg2;
    BasicArray_int * _arg3;
    int  _arg4 = 0;
    char * _argc0 = 0;
    char * _argc3 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    BasicArray_int & _result_ref = BasicArray_int_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
    _result = (BasicArray_int *) &_result_ref;
    return _resultobj;
static int  BasicArray_int___getitem__(BasicArray_int *self,int  i) {
	return self->operator[](i);
        }
static PyObject *_wrap_BasicArray_int___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_int * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_int___getitem__(_arg0,_arg1);
    return _resultobj;
static void  BasicArray_int___setitem__(BasicArray_int *self,int  i,int  val) {
	self->operator[](i) = val;
        }
static PyObject *_wrap_BasicArray_int___setitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_int * _arg0;
    int  _arg1;
    int  _arg2;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BasicArray_int___setitem__(_arg0,_arg1,_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define new_BasicArray_double() (new BasicArray_double())
static PyObject *_wrap_new_BasicArray_double(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (BasicArray_double *)new_BasicArray_double();
    return _resultobj;
#define delete_BasicArray_double(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BasicArray_double(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_BasicArray_double(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define BasicArray_double_resize(_swigobj,_swigarg0)  (_swigobj->resize(_swigarg0))
static PyObject *_wrap_BasicArray_double_resize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_double * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_double_resize(_arg0,_arg1);
    return _resultobj;
#define BasicArray_double_len(_swigobj)  (_swigobj->len())
static PyObject *_wrap_BasicArray_double_len(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_double_len(_arg0);
    return _resultobj;
#define BasicArray_double_data(_swigobj)  (_swigobj->data())
static PyObject *_wrap_BasicArray_double_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    doubleptr  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (doubleptr )BasicArray_double_data(_arg0);
    return _resultobj;
#define BasicArray_double_nrefs(_swigobj)  (_swigobj->nrefs())
static PyObject *_wrap_BasicArray_double_nrefs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    BasicArray_double * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )BasicArray_double_nrefs(_arg0);
    return _resultobj;
#define BasicArray_double_set_data(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->set_data(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_BasicArray_double_set_data(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _result;
    BasicArray_double * _arg0;
    int  _arg1;
    double * _arg2;
    EnumDataOwned  _arg3 = (DataNotOwned);
    char * _argc0 = 0;
    char * _argc2 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    BasicArray_double & _result_ref = BasicArray_double_set_data(_arg0,_arg1,_arg2,_arg3);
    _result = (BasicArray_double *) &_result_ref;
    return _resultobj;
#define BasicArray_double_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)  (_swigobj->set_subvec(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
static PyObject *_wrap_BasicArray_double_set_subvec(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _result;
    BasicArray_double * _arg0;
    int  _arg1;
    int  _arg2;
    BasicArray_double * _arg3;
    int  _arg4 = 0;
    char * _argc0 = 0;
    char * _argc3 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc3) {
        return NULL;
        }
    }
    BasicArray_double & _result_ref = BasicArray_double_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
    _result = (BasicArray_double *) &_result_ref;
    return _resultobj;
static double  BasicArray_double___getitem__(BasicArray_double *self,int  i) {
	return self->operator[](i);
        }
static PyObject *_wrap_BasicArray_double___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BasicArray_double * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )BasicArray_double___getitem__(_arg0,_arg1);
    return _resultobj;
static void  BasicArray_double___setitem__(BasicArray_double *self,int  i,double  val) {
	self->operator[](i) = val;
        }
static PyObject *_wrap_BasicArray_double___setitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BasicArray_double * _arg0;
    int  _arg1;
    double  _arg2;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    BasicArray_double___setitem__(_arg0,_arg1,_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void *SwigSimpleArray_intToBasicArray_int(void *ptr) {
    SimpleArray_int *src;
    BasicArray_int *dest;
    src = (SimpleArray_int *) ptr;
    dest = (BasicArray_int *) src;
    return (void *) dest;
#define new_SimpleArray_int() (new SimpleArray_int())
static PyObject *_wrap_new_SimpleArray_int(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SimpleArray_int * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (SimpleArray_int *)new_SimpleArray_int();
    return _resultobj;
#define SimpleArray_int_compare(_swigobj,_swigarg0)  (_swigobj->compare(_swigarg0))
static PyObject *_wrap_SimpleArray_int_compare(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_int * _arg0;
    SimpleArray_int * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_int_compare(_arg0,*_arg1);
    return _resultobj;
#define SimpleArray_int_write(_swigobj,_swigarg0)  (_swigobj->write(_swigarg0))
static PyObject *_wrap_SimpleArray_int_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_int * _arg0;
    ostream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_int_write(_arg0,*_arg1);
    return _resultobj;
#define SimpleArray_int_read(_swigobj,_swigarg0)  (_swigobj->read(_swigarg0))
static PyObject *_wrap_SimpleArray_int_read(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_int * _arg0;
    istream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_int_read(_arg0,*_arg1);
    return _resultobj;
static void *SwigSimpleArray_doubleToBasicArray_double(void *ptr) {
    SimpleArray_double *src;
    BasicArray_double *dest;
    src = (SimpleArray_double *) ptr;
    dest = (BasicArray_double *) src;
    return (void *) dest;
#define new_SimpleArray_double() (new SimpleArray_double())
static PyObject *_wrap_new_SimpleArray_double(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    SimpleArray_double * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (SimpleArray_double *)new_SimpleArray_double();
    return _resultobj;
#define SimpleArray_double_compare(_swigobj,_swigarg0)  (_swigobj->compare(_swigarg0))
static PyObject *_wrap_SimpleArray_double_compare(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_double * _arg0;
    SimpleArray_double * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_double_compare(_arg0,*_arg1);
    return _resultobj;
#define SimpleArray_double_write(_swigobj,_swigarg0)  (_swigobj->write(_swigarg0))
static PyObject *_wrap_SimpleArray_double_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_double * _arg0;
    ostream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_double_write(_arg0,*_arg1);
    return _resultobj;
#define SimpleArray_double_read(_swigobj,_swigarg0)  (_swigobj->read(_swigarg0))
static PyObject *_wrap_SimpleArray_double_read(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    SimpleArray_double * _arg0;
    istream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )SimpleArray_double_read(_arg0,*_arg1);
    return _resultobj;
static void *SwigNumArray_intToSimpleArray_int(void *ptr) {
    NumArray_int *src;
    SimpleArray_int *dest;
    src = (NumArray_int *) ptr;
    dest = (SimpleArray_int *) src;
    return (void *) dest;
static void *SwigNumArray_intToBasicArray_int(void *ptr) {
    NumArray_int *src;
    BasicArray_int *dest;
    src = (NumArray_int *) ptr;
    dest = (BasicArray_int *) src;
    return (void *) dest;
#define new_IntVector() (new NumArray_int())
static PyObject *_wrap_new_IntVector(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_int * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (NumArray_int *)new_IntVector();
    return _resultobj;
#define IntVector_plus(_swigobj,_swigarg0,_swigarg1)  (_swigobj->plus(_swigarg0,_swigarg1))
static PyObject *_wrap_IntVector_plus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_int * _arg0;
    NumArray_int * _arg1;
    NumArray_int * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    IntVector_plus(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define IntVector_minus(_swigobj,_swigarg0,_swigarg1)  (_swigobj->minus(_swigarg0,_swigarg1))
static PyObject *_wrap_IntVector_minus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_int * _arg0;
    NumArray_int * _arg1;
    NumArray_int * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    IntVector_minus(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define IntVector_times(_swigobj,_swigarg0,_swigarg1)  (_swigobj->times(_swigarg0,_swigarg1))
static PyObject *_wrap_IntVector_times(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_int * _arg0;
    NumArray_int * _arg1;
    NumArray_int * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    IntVector_times(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define IntVector_divide(_swigobj,_swigarg0,_swigarg1)  (_swigobj->divide(_swigarg0,_swigarg1))
static PyObject *_wrap_IntVector_divide(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_int * _arg0;
    NumArray_int * _arg1;
    NumArray_int * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    IntVector_divide(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void *SwigNumArray_doubleToSimpleArray_double(void *ptr) {
    NumArray_double *src;
    SimpleArray_double *dest;
    src = (NumArray_double *) ptr;
    dest = (SimpleArray_double *) src;
    return (void *) dest;
static void *SwigNumArray_doubleToBasicArray_double(void *ptr) {
    NumArray_double *src;
    BasicArray_double *dest;
    src = (NumArray_double *) ptr;
    dest = (BasicArray_double *) src;
    return (void *) dest;
#define new_RealVector() (new NumArray_double())
static PyObject *_wrap_new_RealVector(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_double * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (NumArray_double *)new_RealVector();
    return _resultobj;
#define RealVector_plus(_swigobj,_swigarg0,_swigarg1)  (_swigobj->plus(_swigarg0,_swigarg1))
static PyObject *_wrap_RealVector_plus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_double * _arg0;
    NumArray_double * _arg1;
    NumArray_double * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    RealVector_plus(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define RealVector_minus(_swigobj,_swigarg0,_swigarg1)  (_swigobj->minus(_swigarg0,_swigarg1))
static PyObject *_wrap_RealVector_minus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_double * _arg0;
    NumArray_double * _arg1;
    NumArray_double * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    RealVector_minus(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define RealVector_times(_swigobj,_swigarg0,_swigarg1)  (_swigobj->times(_swigarg0,_swigarg1))
static PyObject *_wrap_RealVector_times(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_double * _arg0;
    NumArray_double * _arg1;
    NumArray_double * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    RealVector_times(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define RealVector_divide(_swigobj,_swigarg0,_swigarg1)  (_swigobj->divide(_swigarg0,_swigarg1))
static PyObject *_wrap_RealVector_divide(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NumArray_double * _arg0;
    NumArray_double * _arg1;
    NumArray_double * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    RealVector_divide(_arg0,*_arg1,*_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define new_CommonIO() (new CommonIO())
static PyObject *_wrap_new_CommonIO(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CommonIO * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (CommonIO *)new_CommonIO();
    return _resultobj;
#define delete_CommonIO(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_CommonIO(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CommonIO * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_CommonIO(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    self = self;
        return NULL;
    CommonIO::reset();
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define CommonIO_debug_set(_swigobj,_swigval) (_swigobj->debug = _swigval,_swigval)
static PyObject *_wrap_CommonIO_debug_set(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CommonIO * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CommonIO_debug_set(_arg0,_arg1);
    return _resultobj;
#define CommonIO_debug_get(_swigobj) ((int ) _swigobj->debug)
static PyObject *_wrap_CommonIO_debug_get(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CommonIO * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CommonIO_debug_get(_arg0);
    return _resultobj;
static int _wrap_CommonIO__numDigits_set(PyObject *val) {
    int  tval;
    tval = (int )PyInt_AsLong(val);
    if (PyErr_Occurred()) {
        return 1; 
    }
    CommonIO::numDigits = tval;
    return 0;
static PyObject *_wrap_CommonIO__numDigits_get() {
    PyObject * pyobj;
    pyobj = PyInt_FromLong((long) CommonIO::numDigits);
    return pyobj;
#define CommonIO_verbosity(_swigobj,_swigarg0)  (_swigobj->verbosity(_swigarg0))
static PyObject *_wrap_CommonIO_verbosity(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CommonIO * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )CommonIO_verbosity(_arg0,_arg1);
    return _resultobj;
#define CommonIO_setDebug(_swigobj,_swigarg0)  (_swigobj->setDebug(_swigarg0))
static PyObject *_wrap_CommonIO_setDebug(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CommonIO * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    CommonIO_setDebug(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_setIORank(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _arg0;
    self = self;
        return NULL;
    CommonIO::setIORank(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_setIOFlush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _arg0;
    self = self;
        return NULL;
    CommonIO::setIOFlush(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_rank(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    self = self;
        return NULL;
    _result = (int )CommonIO::rank();
    return _resultobj;
static PyObject *_wrap_CommonIO_io_rank(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    self = self;
        return NULL;
    _result = (int )CommonIO::io_rank();
    return _resultobj;
static PyObject *_wrap_CommonIO_numProcs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    self = self;
        return NULL;
    _result = (int )CommonIO::numProcs();
    return _resultobj;
static PyObject *_wrap_CommonIO_outs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    ostream & _result_ref = CommonIO::outs();
    _result = (ostream *) &_result_ref;
    return _resultobj;
static PyObject *_wrap_CommonIO_errs(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    ostream & _result_ref = CommonIO::errs();
    _result = (ostream *) &_result_ref;
    return _resultobj;
static PyObject *_wrap_CommonIO_ins(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    istream * _result;
    char _ptemp[128];
    self = self;
        return NULL;
    istream & _result_ref = CommonIO::ins();
    _result = (istream *) &_result_ref;
    return _resultobj;
static PyObject *_wrap_CommonIO_set_streams(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _arg0;
    ostream * _arg1;
    istream * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    if (_argc2) {
        return NULL;
        }
    }
    CommonIO::set_streams(_arg0,_arg1,_arg2);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_set_cout(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    CommonIO::set_cout(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_set_cerr(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    CommonIO::set_cerr(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_set_cin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    istream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    CommonIO::set_cin(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_set_ofile(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    char * _arg0;
    self = self;
        return NULL;
    CommonIO::set_ofile(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_begin_tagging(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _arg0 = 0;
    self = self;
        return NULL;
    CommonIO::begin_tagging(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_end_tagging(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    self = self;
        return NULL;
    CommonIO::end_tagging();
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_flush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    self = self;
        return NULL;
    CommonIO::flush();
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyObject *_wrap_CommonIO_sync_stdio(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    self = self;
        return NULL;
    CommonIO::sync_stdio();
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static int _wrap_CommonIO__std_cout_set(PyObject *val) {
    char * tval;
    ostream * temp;
    tval = (char *) PyString_AsString(val);
    if (PyErr_Occurred()) {
        return 1; 
    }
    if (tval) {
        return 1;
        }
    }
    CommonIO::std_cout = temp;
    return 0;
static PyObject *_wrap_CommonIO__std_cout_get() {
    PyObject * pyobj;
    char ptemp[128];
    pyobj = PyString_FromString(ptemp);
    return pyobj;
static int _wrap_CommonIO__std_cerr_set(PyObject *val) {
    char * tval;
    ostream * temp;
    tval = (char *) PyString_AsString(val);
    if (PyErr_Occurred()) {
        return 1; 
    }
    if (tval) {
        return 1;
        }
    }
    CommonIO::std_cerr = temp;
    return 0;
static PyObject *_wrap_CommonIO__std_cerr_get() {
    PyObject * pyobj;
    char ptemp[128];
    pyobj = PyString_FromString(ptemp);
    return pyobj;
static int _wrap_CommonIO__std_cin_set(PyObject *val) {
    char * tval;
    istream * temp;
    tval = (char *) PyString_AsString(val);
    if (PyErr_Occurred()) {
        return 1; 
    }
    if (tval) {
        return 1;
        }
    }
    CommonIO::std_cin = temp;
    return 0;
static PyObject *_wrap_CommonIO__std_cin_get() {
    PyObject * pyobj;
    char ptemp[128];
    pyobj = PyString_FromString(ptemp);
    return pyobj;
#define RNG_asLong(_swigobj)  (_swigobj->asLong())
static PyObject *_wrap_RNG_asLong(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    unsigned long  _result;
    RNG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (unsigned long )RNG_asLong(_arg0);
    return _resultobj;
#define RNG_reset(_swigobj)  (_swigobj->reset())
static PyObject *_wrap_RNG_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RNG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    RNG_reset(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define RNG_asFloat(_swigobj)  (_swigobj->asFloat())
static PyObject *_wrap_RNG_asFloat(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    float  _result;
    RNG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (float )RNG_asFloat(_arg0);
    return _resultobj;
#define RNG_asDouble(_swigobj)  (_swigobj->asDouble())
static PyObject *_wrap_RNG_asDouble(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RNG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )RNG_asDouble(_arg0);
    return _resultobj;
#define CRandVar_generator(_swigobj)  (_swigobj->generator())
static PyObject *_wrap_CRandVar_generator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RNG * _result;
    CRandVar * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (RNG *)CRandVar_generator(_arg0);
    return _resultobj;
static double  CRandVar___call__(CRandVar *self) {
		return self->operator()();
static PyObject *_wrap_CRandVar___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    CRandVar * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )CRandVar___call__(_arg0);
    return _resultobj;
static void  CRandVar_set_generator(CRandVar *self,RNG * p) {
		self->generator(p);
static PyObject *_wrap_CRandVar_set_generator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CRandVar * _arg0;
    RNG * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    CRandVar_set_generator(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void *SwigPM_LCGToRNG(void *ptr) {
    PM_LCG *src;
    RNG *dest;
    src = (PM_LCG *) ptr;
    dest = (RNG *) src;
    return (void *) dest;
#define new_PM_LCG(_swigarg0) (new PM_LCG(_swigarg0))
static PyObject *_wrap_new_PM_LCG(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PM_LCG * _result;
    int  _arg0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (PM_LCG *)new_PM_LCG(_arg0);
    return _resultobj;
#define PM_LCG_reseed(_swigobj,_swigarg0)  (_swigobj->reseed(_swigarg0))
static PyObject *_wrap_PM_LCG_reseed(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PM_LCG * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    PM_LCG_reseed(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define PM_LCG_getSeed(_swigobj)  (_swigobj->getSeed())
static PyObject *_wrap_PM_LCG_getSeed(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    PM_LCG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (int )PM_LCG_getSeed(_arg0);
    return _resultobj;
#define PM_LCG_reset(_swigobj)  (_swigobj->reset())
static PyObject *_wrap_PM_LCG_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PM_LCG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    PM_LCG_reset(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define PM_LCG_asLong(_swigobj)  (_swigobj->asLong())
static PyObject *_wrap_PM_LCG_asLong(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    unsigned long  _result;
    PM_LCG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (unsigned long )PM_LCG_asLong(_arg0);
    return _resultobj;
#define PM_LCG_asDouble(_swigobj)  (_swigobj->asDouble())
static PyObject *_wrap_PM_LCG_asDouble(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    PM_LCG * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )PM_LCG_asDouble(_arg0);
    return _resultobj;
#define PM_LCG_write(_swigobj,_swigarg0)  (_swigobj->write(_swigarg0))
static PyObject *_wrap_PM_LCG_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    PM_LCG * _arg0;
    ostream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )PM_LCG_write(_arg0,*_arg1);
    return _resultobj;
#define PM_LCG_read(_swigobj,_swigarg0)  (_swigobj->read(_swigarg0))
static PyObject *_wrap_PM_LCG_read(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    PM_LCG * _arg0;
    istream * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    if (_argc1) {
        return NULL;
        }
    }
    _result = (int )PM_LCG_read(_arg0,*_arg1);
    return _resultobj;
static void *SwigUniformToCRandVar(void *ptr) {
    Uniform *src;
    CRandVar *dest;
    src = (Uniform *) ptr;
    dest = (CRandVar *) src;
    return (void *) dest;
#define new_Uniform(_swigarg0,_swigarg1,_swigarg2) (new Uniform(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_Uniform(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Uniform * _result;
    RNG * _arg0 = 0;
    double  _arg1 = 0.0;
    double  _arg2 = 1.0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (Uniform *)new_Uniform(_arg0,_arg1,_arg2);
    return _resultobj;
#define Uniform_low(_swigobj)  (_swigobj->low())
static PyObject *_wrap_Uniform_low(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Uniform * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Uniform_low(_arg0);
    return _resultobj;
#define Uniform_high(_swigobj)  (_swigobj->high())
static PyObject *_wrap_Uniform_high(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Uniform * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Uniform_high(_arg0);
    return _resultobj;
#define new_Normal(_swigarg0,_swigarg1,_swigarg2) (new Normal(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_Normal(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Normal * _result;
    RNG * _arg0 = 0;
    double  _arg1 = 0.0;
    double  _arg2 = 1.0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (Normal *)new_Normal(_arg0,_arg1,_arg2);
    return _resultobj;
#define Normal_mean_set(_swigobj,_swigval) (_swigobj->mean = _swigval,_swigval)
static PyObject *_wrap_Normal_mean_set(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Normal * _arg0;
    double  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Normal_mean_set(_arg0,_arg1);
    return _resultobj;
#define Normal_mean_get(_swigobj) ((double ) _swigobj->mean)
static PyObject *_wrap_Normal_mean_get(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Normal * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Normal_mean_get(_arg0);
    return _resultobj;
#define Normal_stddev_set(_swigobj,_swigval) (_swigobj->stddev = _swigval,_swigval)
static PyObject *_wrap_Normal_stddev_set(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Normal * _arg0;
    double  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Normal_stddev_set(_arg0,_arg1);
    return _resultobj;
#define Normal_stddev_get(_swigobj) ((double ) _swigobj->stddev)
static PyObject *_wrap_Normal_stddev_get(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Normal * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (double )Normal_stddev_get(_arg0);
    return _resultobj;
static void *SwigTriangularToCRandVar(void *ptr) {
    Triangular *src;
    CRandVar *dest;
    src = (Triangular *) ptr;
    dest = (CRandVar *) src;
    return (void *) dest;
#define new_Triangular(_swigarg0,_swigarg1,_swigarg2) (new Triangular(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_Triangular(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Triangular * _result;
    RNG * _arg0 = 0;
    double  _arg1 = 1.0;
    int  _arg2 = (2);
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (Triangular *)new_Triangular(_arg0,_arg1,_arg2);
    return _resultobj;
#define Triangular_generator(_swigobj)  (_swigobj->generator())
static PyObject *_wrap_Triangular_generator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RNG * _result;
    Triangular * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    _result = (RNG *)Triangular_generator(_arg0);
    return _resultobj;
#define Triangular_truncation(_swigobj,_swigarg0)  (_swigobj->truncation(_swigarg0))
static PyObject *_wrap_Triangular_truncation(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Triangular * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    Triangular_truncation(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define ostream_flush(_swigobj)  (_swigobj->flush())
static PyObject *_wrap_ostream_flush(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ostream_flush(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void  ostream_write(ostream *self,char * str) { (*self) << str; }
static PyObject *_wrap_ostream_write(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ostream * _arg0;
    char * _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ostream_write(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void *SwigofstreamToostream(void *ptr) {
    ofstream *src;
    ostream *dest;
    src = (ofstream *) ptr;
    dest = (ostream *) src;
    return (void *) dest;
#define new_ofstream(_swigarg0) (new ofstream(_swigarg0))
static PyObject *_wrap_new_ofstream(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ofstream * _result;
    char * _arg0;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (ofstream *)new_ofstream(_arg0);
    return _resultobj;
#define ofstream_open(_swigobj,_swigarg0)  (_swigobj->open(_swigarg0))
static PyObject *_wrap_ofstream_open(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ofstream * _arg0;
    char * _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ofstream_open(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define ofstream_close(_swigobj)  (_swigobj->close())
static PyObject *_wrap_ofstream_close(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ofstream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ofstream_close(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void delete_ofstream(ofstream *self) {
  self->flush();
  self->close();
static PyObject *_wrap_delete_ofstream(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ofstream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    delete_ofstream(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static void *SwigifstreamToistream(void *ptr) {
    ifstream *src;
    istream *dest;
    src = (ifstream *) ptr;
    dest = (istream *) src;
    return (void *) dest;
#define new_ifstream(_swigarg0) (new ifstream(_swigarg0))
static PyObject *_wrap_new_ifstream(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ifstream * _result;
    char * _arg0;
    char _ptemp[128];
    self = self;
        return NULL;
    _result = (ifstream *)new_ifstream(_arg0);
    return _resultobj;
#define ifstream_open(_swigobj,_swigarg0)  (_swigobj->open(_swigarg0))
static PyObject *_wrap_ifstream_open(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ifstream * _arg0;
    char * _arg1;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ifstream_open(_arg0,_arg1);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
#define ifstream_close(_swigobj)  (_swigobj->close())
static PyObject *_wrap_ifstream_close(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ifstream * _arg0;
    char * _argc0 = 0;
    self = self;
        return NULL;
    if (_argc0) {
        return NULL;
        }
    }
    ifstream_close(_arg0);
    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
static PyMethodDef utilibcMethods[] = {
	 { NULL, NULL }
static PyObject *SWIG_globals;
#ifdef __cplusplus
#endif
SWIGEXPORT(void,initutilibc)() {
	 PyObject *m, *d;
	 SWIG_globals = SWIG_newvarlink();
	 d = PyModule_GetDict(m);
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
class A {
public:
  int a;
int main()
//BasicArray<char> tmp1(10);
//SimpleArray<char> tmp2(10);
BitArray tmp;
// classref.cpp
// Test vector reference counting operations
#ifdef NON_ANSI
#include <string.h>
#include <fstream.h>
#else
#include <cstring>
#include <fstream>
#endif
int main(int argc, char* argv[])
BasicArray<IntVector> a(50);
   //
   // This loop should cause an abort
   //
   for (int i=1; i<a.size(); i++) 
     a[i] &= a[0];
   }
   BasicArray<int>::set_ref_limit(100);
   //
   // This loop should be OK.
   //
   for (int i=1; i<a.size(); i++) 
     a[i] &= a[0];
   a[0].resize(10);
   a[0] = 1;
   }
   BasicArray<int>::set_ref_limit(100);
   a[0].resize(10);
   a[0].freeze_memory();
   //
   // This loop should be OK
   //
   for (int i=1; i<a.size(); i++) 
     a[i] &= a[0];
   a[0] = 1;
   }
   BasicArray<int>::set_ref_limit(100);
   a[0].resize(10);
   a[0].freeze_memory();
   //
   // This loop should be OK
   //
   for (int i=1; i<a.size(); i++) 
     a[i] &= a[0];
   a[0] = 1;
   //
   // This should cause an error
   //
   a[1].resize(1);
   }
   BasicArray<int>::set_ref_limit(100);
   a[0].resize(10);
   a[0].freeze_memory();
   //
   // This loop should be OK
   //
   for (int i=1; i<a.size(); i++) 
     a[i] &= a[0];
   a[0] = 1;
   IntVector b(2);
   b = 2;
   //
   // This should be OK.
   //
   a[1] &= b;
   }
return 0;
#include <iostream>
using namespace std;
template <class T, class V>
void compare(T& x, V& y)
cout << endl;
bool dotest(double tmp)
if (tmp < 0.0) return true;
else return false;
int main()
Ereal<double> foo = -6;
Ereal<double> bar = 7;
Ereal<double> infhi = Ereal<double>::positive_infinity;
Ereal<double> inflo = Ereal<double>::negative_infinity;
compare(foo,foo);
compare(bar,bar);
compare(infhi,infhi);
compare(inflo,inflo);
compare(foo,bar);
compare(bar,foo);
compare(foo,infhi);
compare(infhi,foo);
compare(bar,infhi);
compare(infhi,bar);
compare(inflo,foo);
compare(foo,inflo);
compare(inflo,bar);
compare(bar,inflo);
compare(inflo,infhi);
compare(infhi,inflo);
double tmp = 20;
compare(tmp,foo);
compare(foo,tmp);
compare(tmp,bar);
compare(bar,tmp);
compare(tmp,infhi);
compare(infhi,tmp);
compare(tmp,inflo);
compare(inflo,tmp);
double tmp2 = -20;
compare(tmp2,foo);
compare(foo,tmp2);
compare(tmp2,bar);
compare(bar,tmp2);
compare(tmp2,infhi);
compare(infhi,tmp2);
compare(tmp2,inflo);
compare(inflo,tmp2);
// hash.cpp
GLOBAL_PARAMETER_DEF(debug,0,0,MAXDOUBLE);
template <class T>
class A {
public:
  A() {}
  size_type hash(size_type table_size) const
	size_type tmp = (*hash_fn)(val,table_size);
	return tmp;
	//return (*hash_fn)(val,table_size);
  int compare(const A<T>* tmp) const;
  T val;
  int write(ostream& os) const
	{os << val; return OK;}
  int read(istream& is)
	{is >> val; return OK;}
  A<T>& operator=(A<T>& tmp)
	{val = tmp.val; return *this;}
  static size_type (*hash_fn)(const T&, const size_type);
template <class T>
istream& operator>>(istream& is, A<T>& key)
{key.read(is); return is;}
template <class T>
ostream& operator<<(ostream& os, A<T>& key)
{key.write(os); return os;}
template <class T>
size_type (*A<T>::hash_fn)(const T&, const size_type) = 0;
template <class T>
int A<T>::compare(const A<T>* tmp) const
int foo = ::compare(val,tmp->val);
return foo;
void fill_table(SimpleHashTable<int>& table)
int tmp;
for (int i=0; i<1000; i++) {
  tmp = i*i*i;
  table.add(tmp);
void fill_table(GenericHashTable<A<int> >& table)
A<int>* tmp;
for (int i=0; i<1000; i++) {
  tmp = new A<int>;
  tmp->val = i*i*i;
  table.add(*tmp);
  tmp = new A<int>;
  tmp->val = i*i*i;
  table.add(*tmp);
void fill_table(GenericHashTable<A<CharString> >& table)
A<CharString>* tmp;
tmp = new A<CharString>;
hash_data >> tmp->val;
while (hash_data) {
  table.add(*tmp);
  tmp = new A<CharString>;
  hash_data >> tmp->val;
template <class T>
void do_stest(const CharString& msg, SimpleHashTable<T>& table)
cout << msg << endl;
fill_table(table);
if (debug()) {
   cout << table << endl;
   SimpleHashTableItem<T>* item = table.first();
   while (item) {
     cout << (*item->key()) << endl;
     item = table.next(item);
     }
   }
table.statistics(cout);
template <class T>
void do_test(const CharString& msg, GenericHashTable<A<T> >& table)
cout << msg << endl;
fill_table(table);
if (debug()) {
   cout << table << endl;
   GenericHashTableItem<A<T> >* item = table.first();
   while (item) {
     cout << item->key()->val << endl;
     item = table.next(item);
     }
   }
table.statistics(cout);
int main(int argc, char** argv)
parameter::readAll(argc, argv);
// SimpleHashTable<int>
SimpleHashTable<int> test_int;
// GenericHashTable<A<int>>
GenericHashTable<A<int> > foo_int;
foo_int.clear();
A<int>::hash_fn = hash_fn1;
// GenericHashTable<A<CharString>>
GenericHashTable<A<CharString> > foo;
foo.clear();
A<CharString>::hash_fn = hash_fn1;
foo.clear();
A<CharString>::hash_fn = hash_fn2;
foo.clear();
A<CharString>::hash_fn = hash_fn3;
// iotest.cpp
// Test the CommonIO class.
#ifdef NON_ANSI
#include <stdio.h>
#include <stdlib.h>
#include <fstream.h>
#else
#include <cstdio>
#include <cstdlib>
#include <fstream>
#endif
class A : public CommonIO {
public:
A() : a(0) {}
int a;
class B : public A {
public:
B() : b(1) {}
int b;
void foo()
CommonIO::begin();
A a;
B b;
//a.setIOFlush(1);
a.foo();
b.foob();
a.debug = 1;
a.foo();
b.debug = 1;
b.foo();
b.foob();
b.debug = 2;
b.foo();
b.foob();
CommonIO::end();
int main(int argc, char* argv[])
#ifdef USING_MPI
uMPI::init(&argc, &argv);
#endif
foo();
char tmp[256];
ofstream ofstr(tmp);
CommonIO::set_streams(&ofstr,&ofstr,&stdcin);
foo();
CommonIO::reset();
ofstr.close();
CommonIO::begin_tagging(5);
foo();
CommonIO::end_tagging();
CommonIO::begin_buffered();
foo();
CommonIO::end();
CommonIO::begin_buffered();
CommonIO::begin_tagging(5);
ofstr.open(tmp);
CommonIO::set_streams(&ofstr,&ofstr,&stdcin);
foo();
CommonIO::end_tagging();
CommonIO::end();
ofstr.close();
#ifdef USING_MPI
uMPI::done();
#endif
//#define NEW
#define ARRAY BitArray
#define LEN 256
#ifdef NON_ANSI
#include <stream.h>
#else
#include <stream>
#endif
static size_t total=0;
#ifdef NEW
#ifdef NON_ANSI
#include <stddef.h>
#include <new.h>
#include <malloc.h>
#else
#include <cstddef>
#include <new>
#include <cmalloc>
#endif
#ifdef COUGAR
void *operator new(size_t size) throw(__EDG_STD_NAMESPACE::bad_alloc)
#else
void *operator new(size_t size)
#endif
total += size;
return ::new (void*) [size];
#endif
extern int profile_total_bytes_used;
int heap_size();
VOID init_heap_malloc();
VOID init_malloc_sigheap();
int largest_free_block(unsigned int *link, int *largest_free);
int heap_info(int *fragments, int *total_free, int *largest_free,
    int *total_used);
VOID lputs_links();
VOID print_links();
static int last_fragments=0, last_total_free=0, last_largest_free=0;
static int last_total_used=0, last_profile=0;
void info(int flag=0)
int hsize = 0;
hsize = heap_size();
int fragments, total_free, largest_free, total_used;
int ret = heap_info(&fragments, &total_free, &largest_free, &total_used);
   ucout << endl;
if (flag) {
   ucout << endl;
   }
last_fragments=fragments;
last_total_free=total_free;
last_largest_free=largest_free;
last_total_used=total_used;
last_profile=profile_total_bytes_used;
int main()
//CharString tmp;
BasicArray<char> foo;
info();
info();
info();
ARRAY a1(LEN);
info();
ARRAY a2(LEN);
info();
ARRAY a3(LEN);
info();
ARRAY a4(LEN);
info(1);
ucout.flush();
// olist.cpp
// Test routine for ordered lists
void write(OrderedList<void*,double>& olist)
OrderedListItem<void*,double>* item=olist.head();
while (item) {
      item = olist.next(item);
      }
ucout << endl;
int main()
while (1) {
OrderedList<void*,double>* olist = new OrderedList<void*,double>();
void* ptr;
double key;
key=1.0;
olist->add(ptr,key);
write(*olist);
key=2.0;
olist->add(ptr,key);
write(*olist);
key=3.0;
olist->add(ptr,key);
write(*olist);
delete olist;
return 0;
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
#ifdef USING_MPI
#endif
class c1
public:
  CLASS_PARAMETER(param1);
  CLASS_PARAMETER(param2);
  void snortate();
CLASS_PARAMETER_DEF(c1,param1,0,50,100);
CLASS_PARAMETER_DEF(c1,param2,0,60,100);
GLOBAL_PARAMETER_DEF(param3,0,1,1);
int main(int argc,char** argv)
#ifdef USING_MPI
  uMPI::init(&argc,&argv);
  parameter::readAll(argc,argv,1,2);
#endif
  c1 object;
  object.snortate();
#ifdef USING_MPI
  uMPI::done();
#endif
return 0;
void c1::snortate()
// rngtest.cpp
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
extern int utilib_num_primes;
int main()
int dummy = utilib_num_primes;
cout << dummy;
PM_LCG foo;
for (int i=0; i<1000; i++)
  ucout << foo.asLong() << endl;
foo.reset();
for (int i=0; i<1000; i++)
  ucout << foo.asLong() << endl;
foo.reseed(0);
for (int i=0; i<1000; i++)
  ucout << foo.asLong() << endl;
// sort.cpp
// Test sort/order/rank operations
#ifdef NON_ANSI
#include <fstream.h>
#else
#include <fstream>
#endif
class A
public:
  int a;
int  compare_A(A& a1, A& a2)
if (a1.a  < a2.a) return -1;
if (a1.a  > a2.a) return  1;
return 0;
int main()
SimpleArray<double> a(10);
for (int i=0; i<10; i++) a[i] = 5*i*i - i*i*i;
SimpleArray<int> tmp(10);
order(tmp,a);
SimpleArray<int> tmp2;
rank(tmp2,a);
//BasicArray<A> tmp3(10);
//sort(tmp3,compare_A);
return 0;
// stltest.cpp
// Test vector operations
#define USING_STL
#include <fstream>
#include <vector>
using namespace std;
int main()
vector<int> test_a(10);
IntVector a(10);
for (int i=0; i<10; i++) a[i] = i;
a.resize(15);
a.resize(5);
IntVector A;
A = a;
a[0] = -1;
A &= a;
A[0] = 10;
IntVector A2;
A2 &= A;
a.resize(8);
int bar=0;
int foo=01;
a -= 1;
a = a.operator-();
IntVector AA;
AA = a;
AA *= 2;
a += AA;
ucout << endl;
ofstr << a;
ofstr.close();
a = 0;
ifstr >> a;
ifstr.close();
a.append(a);
ucout << endl;
NumArray<int> foo1;
NumArray<int> foo2;
foo1 &= foo2;
foo1.resize(3);
foo1 = 1;
NumArray<int> bar1(10);
NumArray<int> bar2(10);
bar1=1;
bar2=2;
bar2[2]=0;
bar1.set_subvec(3,4,bar2,2);
BitArray b(10);
BitArray B;
{for (int i=0; i<10; i++) b.set(i);}
b.resize(15);
b.resize(5);
B = b;
b.reset(0);
ucout << endl;
CharString str(10);
CharString STR(10);
{for (int i=0; i<10; i++) str[i] = (char)((int)'a' + i);}
str.resize(15);
str.resize(5);
STR = str;
str[0] = 'A';
return 0;
#ifdef NON_ANSI
#include <stdio.h>
#include <time.h>
#include <math.h>
#else
#include <cstdio>
#include <ctime>
#include <cmath>
using namespace std;
#endif
int main()
long int start;
double startme;
double startw;
double x=10.0;
int i;
FILE* foo;
start = clock();
startme = CPUSeconds();
startw  = WallClockSeconds();
for (i=0; i<10000; i++) {
  x += 1/x;
  fclose(foo);
start = clock() - start;
startme = CPUSeconds() - startme;
startw  = WallClockSeconds();
return 0;
// Test of the triangular distributions
void test_crandvar(CRandVar* rv, double lower, double upper, IntVector& vec,
				int num)
vec=0;
double total=0.0;
for (int i=0; i<num; i++) {
  double tmp = (*rv)();
  if (tmp < lower)
  if (tmp > upper)
  total += tmp;
  vec[(int)((tmp-lower)/(upper-lower)*vec.size())]++;
void test_triang(Triangular* rv, double lower, double upper, IntVector& vec,
				int num)
vec=0;
double total=0.0;
for (int i=0; i<num; i++) {
  double tmp = (*rv)(lower,upper);
  if (tmp < lower)
  if (tmp > upper)
  total += tmp;
  vec[(int)((tmp-lower)/(upper-lower)*vec.size())]++;
int main()
PM_LCG rng;
Triangular trv(&rng);
Uniform urv(&rng);
IntVector vec(20);
test_crandvar(&urv,0.0,1.0,vec,1000000);
ucout << vec << endl;
test_crandvar(&trv,-1.0,1.0,vec,1000000);
ucout << vec << endl;
vec.resize(21);
test_triang(&trv,-0.5,1.0,vec,1000000);
ucout << vec << endl;
trv.truncation(PROBABILITY_BALANCED_TRIANGULAR);
test_triang(&trv,-0.5,1.0,vec,1000000);
ucout << vec << endl;
trv.truncation(EXPECTATION_BALANCED_TRIANGULAR);
test_triang(&trv,-0.5,1.0,vec,1000000);
ucout << vec << endl;
return OK;
#ifdef NON_ANSI
#include <math.h>
#include <iostream.h>
#include <stdlib.h>
#include <stdio.h>
#else
#include <cmath>
#include <iostream>
#include <cstdlib>
#include <cstdio>
#endif
int main()
  double upr=1.0,lwr=0.0,delta,x=0.8;
  double randvar,dist[101],mom=0.0;
  int i,rvar,maxdist=0;
  //  Triang_bal *tb;
  //  tb = new Triang_bal(new LCG(100));
  //  delta = 0.4;
  //  tb->set_base(delta,lwr,upr,x);
  Triang_trunc *tb;
  tb = new Triang_trunc(new LCG(100));
  delta = 0.4;
  tb->set_base(delta,lwr,upr,x);
  //  Triang *tb;
  //  tb = new Triangular(new LCG(100));
  //  delta=0.2;
  for(i=0; i<=100; i++)
    dist[i]=0.0;
  for(i=0; i<1000000; i++) {
    randvar=(*tb)();
    rvar=floor((x+delta*randvar)*100.0);
    dist[rvar]=dist[rvar]+1.0;
    if(dist[rvar]>(double)maxdist)
      maxdist++;
  for(i=0; i<=100; i++) {
    dist[i]=dist[i]/(double)maxdist;
    mom=mom+dist[i]*((double)i/100.0-0.8);
void foo()
BasicArray<int> tmp;
int main()
foo();
int main()
Tuple1<int> a(3);
ucout << a << endl;
ucout << b << endl;
ucout << e << endl;
// vectest.cpp
// Test vector operations
#ifdef NON_ANSI
#include <fstream.h>
#else
#include <fstream>
#endif
int main()
IntVector a(10);
for (int i=0; i<10; i++) a[i] = i;
a.resize(15);
a.resize(5);
IntVector A;
A = a;
a[0] = -1;
A &= a;
A[0] = 10;
IntVector A2;
A2 &= A;
a.resize(8);
int bar=0;
int foo=01;
a -= 1;
a = a.operator-();
IntVector AA;
AA = a;
AA *= 2;
a += AA;
ucout << endl;
ofstr << a;
ofstr.close();
a = 0;
ifstr >> a;
ifstr.close();
a.append(a);
ucout << endl;
NumArray<int> foo1;
NumArray<int> foo2;
foo1 &= foo2;
foo1.resize(3);
foo1 = 1;
NumArray<int> bar1(10);
NumArray<int> bar2(10);
bar1=1;
bar2=2;
bar2[2]=0;
bar1.set_subvec(3,4,bar2,2);
BitArray b(10);
BitArray B;
{for (int i=0; i<10; i++) b.set(i);}
b.resize(15);
b.resize(5);
B = b;
b.reset(0);
ucout << endl;
CharString str(10);
CharString STR(10);
{for (int i=0; i<10; i++) str[i] = (char)((int)'a' + i);}
str.resize(15);
str.resize(5);
STR = str;
str[0] = 'A';
return 0;
// cppMessage.cpp
// This routine is primarily used to avoid using cout and stdout IO
// at the same time.  Of course, using this implies that you're 
// using C++, even though the errmsg.h routines offer a C interface.
// However, I'm only using C++ these days...
#include <iostream.h>
#include <stdlib.h>
#ifdef USING_MPI
#include <mpi.h>
#endif
#ifdef USING_MPI
int mpiActive;
MPI_Initialized(&mpiActive);
if (mpiActive) {
   int rank;
   MPI_Comm_rank(MPI_COMM_WORLD,&rank);
   }
#endif
if (flush_flag)
   ucout << Flush;
if (CommonIO_end) {
   //
   // Turn off CommonIO before aborting.
   //
   cppMessage_abort();
   }
void cppMessage_abort()
{  CommonIO::end_all(); }
#include <iostream.h>
#include <stdlib.h>
#ifdef USING_MPI
#include <mpi.h>
#endif
#ifdef USING_MPI
  int mpiActive;
  MPI_Initialized(&mpiActive);
  if (mpiActive)
    {
      int rank;
      MPI_Comm_rank(uMPI::comm,&rank);
    }
#endif
#ifdef USING_MPI
  if (mpiActive)
    MPI_Abort(MPI_COMM_WORLD,1);	// MPI_Abort always uses MPI_COMM_WORLD
#endif
  exit(1);
// memdebug.cpp
// Macros that can be used to debug memory allocation
#if defined(USING_MEMDEBUG)
#include <stddef.h>
#include <stdlib.h>
#include <new.h>
int memdebug::nbytes = 0;
int memdebug::n_news = 0;
int memdebug::n_dels = 0;
int memdebug::num    = 0;
BasicArray_CharString memdebug::name(10);
IntVector memdebug::num_new(10);
IntVector memdebug::num_del(10);
IntVector memdebug::memory_allocated(10);
IntVector memdebug::memory_deleted(10);
IntVector memdebug::last_total(10);
void memdebug::print_summary(ostream& os)
os << endl;
os << endl;
for (int i=0; i<num; i++) {
			<< (((double)memory_allocated[i])/num_new[i]) << endl;
			//<< (((double)memory_deleted[i])/num_del[i]) << endl;
void my_new_handler()
ucout << Flush;
abort();
#ifdef COUGAR
void *operator new(size_t size) throw(__EDG_STD_NAMESPACE::bad_alloc)
#else
void *operator new(size_t size)
#endif
memdebug::nbytes += size;
memdebug::n_news++;
return ::new (void*) [size];
void operator delete(void* ptr)
memdebug::n_dels++;
free(ptr);
#endif
 * seconds.cpp
 * This file wraps architecture-dependent timer routines.  Both CPU time
 * and wall clock (elapsed) time are provided.
 * This file was derived from the seconds.C timing routines developed by
 * Scott Kohn for LPARX.
 * Note:  this is now a C++ file to enable automatic initialization of 
 * the WallClock_init variable.  
 * Michael S. Eldred
 *   Jan 2000   Added default returns to CPUSeconds & WallClockSeconds so that
 *              they would at least compile on unsupported platforms.  Also
 *              improved timer definitions for SGI and DEC.  Note that a 
 *              CPUParentChildSeconds function could be added which mimics 
 *              RWTimer's use of the C clock() function from <time.h>.  Then 
 *              CPUSeconds would be renamed to CPUParentSeconds.
 * INCLUDES
#include <iostream.h>
#ifndef STDLIB_MPI
#include <time.h>
#ifdef UWIN
#define CLK_TCK CLOCKS_PER_SEC
#endif
#ifdef _MSC_VER
#include <time.h>
#else
#include <sys/time.h>
#include <sys/times.h>
#include <unistd.h>
#endif
#if defined(SUNOS) || defined(SOLARIS) || defined(PVM) || defined(SGI) || defined(OSF)
#include <sys/resource.h>
#include <sys/timeb.h>
#include <sys/types.h>
// by providing an additional reference point, round-off can be minimized.  
// This is accomplished by differencing large, similar integers _before_ the 
// conversion to a double which avoids roundoff in the conversion.
static struct timeb WallClock_init;
static int dummy = ftime(&WallClock_init);
#endif
#ifdef RS6K
#include <sys/m_param.h>
#define CLK_TCK CLKTICK
#endif
#ifdef COUGAR
#include <nx.h>
#endif
#if (defined(CRAYC90) && defined(MULTITASK))
#pragma _CRI taskcommon CPU_start_time
#pragma _CRI taskcommon WallClock_start_time
#endif
static double CPU_start_time=0.0;
static double WallClock_start_time=0.0;
#define MILLISECONDS (1.0e-3)
#define MICROSECONDS (1.0e-6)
 * Initialize Timing
 * Initialize the timing routines.  We get the starting time and use this as a
 * baseline for elapsed time measurements.
 * NOTE: time estimates can be corrupted if multiple calls (e.g., DAKOTA & 
 *       SGOPT) are made to this function and the Elapsed routines are used.
 *       For this reason, DAKOTA uses the absolute timing routines and tracks 
 *       elapsed times internally.
#ifdef CM5
   CMMD_node_timer_clear(CM5_MP_TIMER_NUMBER);
   CMMD_node_timer_start(CM5_MP_TIMER_NUMBER);
#endif
   CPU_start_time = CPUSeconds();
   WallClock_start_time = WallClockSeconds();
   return 0;
 * CPUSeconds
#if defined(KSR)
   return(user_seconds());
#elif defined(SUNOS) || defined(SOLARIS) || defined(PVM) || defined(SGI) || defined(OSF)
   struct rusage usage;
   long sec, usec;
   double res;
   (void) getrusage(RUSAGE_SELF, &usage);
   sec  = usage.ru_utime.tv_sec  + usage.ru_stime.tv_sec ;
   usec = usage.ru_utime.tv_usec + usage.ru_stime.tv_usec;
   res = sec + MICROSECONDS*usec;
   return res;
/* Previously part of the WallClockSeconds routine, this routine has been moved
   here (as an alternate timer) since the SGI man pages state that this is in 
   fact a CPU timer.
#elif defined(SGI)
   struct tms usage;
   long wallclock = times(&usage);
   return(((double) wallclock)/((double) CLK_TCK));
#elif defined(CM5)
   CMMD_node_timer_stop(CM5_MP_TIMER_NUMBER);
   double busy = CMMD_node_timer_busy(CM5_MP_TIMER_NUMBER);
   CMMD_node_timer_start(CM5_MP_TIMER_NUMBER);
   return(busy);
#elif defined(iPSC860)
#ifndef iPSC860SIMULATOR
   return(dclock());
#else
   return(MILLISECONDS*mclock());
#endif
#elif defined(nCUBE2)
   return(MICROSECONDS*amicclk());
#elif defined(PARAGON) || defined(COUGAR)
   return(dclock());
#elif defined(SPX)
   struct tms usage;
   (void) times(&usage);
   return(((double) (usage.tms_utime+usage.tms_stime))/((double) CLK_TCK));
#elif defined(_MSC_VER)
   clock_t t = clock();
   return ((double)t)/CLOCKS_PER_SEC; 
   /* WEH - I'm not exactly sure that this measures the CPU time 
	    for a process under NT. */
/* WEH - provide a default times utility???
   struct tms usage;
   (void) times(&usage);
   return(((double) (usage.tms_utime+usage.tms_stime))/((double) CLK_TCK));
#else
   return 0.0; // so that function at least compiles on an unsupported platform
#endif
 * ElapsedCPUSeconds
return(CPUSeconds() - CPU_start_time);
 * WallClockSeconds
#if defined(CM5)
   CMMD_node_timer_stop(CM5_MP_TIMER_NUMBER);
   double elapsed = CMMD_node_timer_elapsed(CM5_MP_TIMER_NUMBER);
   CMMD_node_timer_start(CM5_MP_TIMER_NUMBER);
   return(elapsed);
#elif defined(iPSC860)
#ifndef iPSC860SIMULATOR
   return(dclock());
#else
   return(MILLISECONDS*mclock());
#endif
#elif defined(nCUBE2)
   return(MICROSECONDS*amicclk());
#elif defined(PARAGON) || defined(COUGAR)
   return(dclock());
#elif defined(SPX)
   struct tms usage;
   long wallclock = times(&usage);
   return(((double) wallclock)/((double) CLK_TCK));
#elif defined(_MSC_VER)
   struct tm * tm_str;
   time_t t=0;
   long int nsecs;
   tm_str = localtime(&t);
   /* Compute seconds since Jan 1, 1990 */
   if (tm_str == 0) return -999.0;
   nsecs = tm_str->tm_sec + 60*(tm_str->tm_min + 
	   60*(tm_str->tm_hour + 24*(tm_str->tm_yday + 
	   365*(tm_str->tm_year - 90))));
   return (double) nsecs;
#elif defined(KSR)
   return(all_seconds());
#elif defined(SUNOS) || defined(SOLARIS) || defined(PVM) || defined(SGI) || defined(OSF)
   struct timeb tb;
   double res;
   (void) ftime(&tb);
   res = (tb.time - WallClock_init.time)
     + MILLISECONDS*(tb.millitm - WallClock_init.millitm);
   return res;
#if (defined(PVM))
   struct timeb tb;
   (void) ftime(&tb);
   return(tb.time + MILLISECONDS*tb.millitm); // since tb.time is a large
   // integer, the conversion to double can drop significant figures, which 
   // is compounded by the fact that 2 of these similar doubles are differenced
   // in the elapsed routines.
#endif
#else
   return 0.0; // so that function at least compiles on an unsupported platform
#endif
 * ElapsedWallClockSeconds
return(WallClockSeconds() - WallClock_start_time);
 * CurrentTime
 * Measures the number of seconds from some arbitrary starting point.
 * Useful for initializing RNGs
#if defined(CM5)
   CMMD_node_timer_stop(CM5_MP_TIMER_NUMBER);
   double elapsed = CMMD_node_timer_elapsed(CM5_MP_TIMER_NUMBER);
   CMMD_node_timer_start(CM5_MP_TIMER_NUMBER);
   return(elapsed);
#elif defined(iPSC860)
#ifndef iPSC860SIMULATOR
   return(dclock());
#else
   return(MILLISECONDS*mclock());
#endif
#elif defined(nCUBE2)
   return(MICROSECONDS*amicclk());
#elif defined(PARAGON) || defined(COUGAR)
   return(dclock());
#elif defined(SPX)
   struct tms usage;
   long wallclock = times(&usage);
   return(((double) wallclock)/((double) CLK_TCK));
#elif defined(_MSC_VER)
   struct tm * tm_str;
   time_t t=0;
   long int nsecs;
   tm_str = localtime(&t);
   /* Compute seconds since Jan 1, 1990 */
   if (tm_str == 0) return -999.0;
   nsecs = tm_str->tm_sec + 60*(tm_str->tm_min + 
	   60*(tm_str->tm_hour + 24*(tm_str->tm_yday + 
	   365*(tm_str->tm_year - 90))));
   return (double) nsecs;
#elif defined(KSR)
   return(all_seconds());
#elif defined(SUNOS) || defined(SOLARIS) || defined(PVM) || defined(SGI) || defined(OSF)
   struct timeb tb;
   double res;
   (void) ftime(&tb);
   res = tb.time + MILLISECONDS*tb.millitm;
   return res;
#if (defined(PVM))
   struct timeb tb;
   (void) ftime(&tb);
   return(tb.time + MILLISECONDS*tb.millitm); // since tb.time is a large
   // integer, the conversion to double can drop significant figures, which 
   // is compounded by the fact that 2 of these similar doubles are differenced
   // in the elapsed routines.
#endif
#else
   return 0.0; // so that function at least compiles on an unsupported platform
#endif
 * ElapsedWallClockSeconds
#endif STDLIB_MPI
// stdafx.cpp : source file that includes just the standard includes
//	utilib.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
// utilib.cpp : Defines the entry point for the DLL application.
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
    switch (ul_reason_for_call)
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
// AbstractHashTable.h
 * \class AbstractHashTable
 * Implements and abstract class for defining the core operations of a
 * hash table with chaining.  This hash table uses buckets with a fixed depth,
 * which may have problems with poor hashing functions.
 * Note: the 'next' method doesn't work if ignore_duplicate==false
 * and there exist duplicates in the hash table.  The could probably be
 * fixed by using a iterator construct, though, instead of this method.
 * Consequently, ignore_duplicate==true by default.
#ifndef __AbstractHashTable_h
#define __AbstractHashTable_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
#include <string.h>
#include <stdio.h>
template <class T, class KEY>
class UTILIB_API AbstractHashTable
public:
	/// The type of the hash indeces
  typedef size_t size_type;
	/// The type of a list of hash elements
  typedef ListItem<T*>* hash_element;
public:
	/// Constructor.
	/// Constructor.
	/// Dummy destructor
  virtual ~AbstractHashTable()
		clear();
		ListItem<T*>::delete_unused();
	/// Returns \c true if the list is empty and \c false otherwise.
  bool      empty() const {return (data.len() == 0);}
	/// Returns \c true if the list is empty and \c false otherwise.
  operator bool()   const {return (data.len() != 0);}
	/// Returns the number of elements in the hash table.
  int      size()  const {return data.len();}
	/**
	 * Return the item in the hash table with the given key.
	 * Returns null if the table is empty or if the item is not in
	 * the tree.
	 */
  virtual T* find(KEY& key) const;
	/// Return the ``first'' element in the hash table.
  virtual T* first() const
		if (data.len() == 0) return ((T*)0);
		return data.head()->data(); 
	/// Add a key to the hash table.
  virtual void add(KEY& key)
		{insert(&key);}
	/**
	 * Add a key to the hash table and return the hash table item 
	 * that contains it.
	 */
  virtual void add(KEY& key, T*& item)
		{item = insert(&key);}
	/**
         * Remove a hash table item with the given key.
         * The status flag is \c true if the key was found and \c false
         * otherwise.
         */
  virtual void remove( KEY& key, bool& status)
		T* tmp = find(key);
		if (tmp) extract(tmp,status);
		else     status = false;
        /**
         * Remove a hash table item.
         * The status flag is \c true if the item was found and \c false
         * otherwise.
         */
  virtual void remove(T*& item, bool& status)
                if (!item)
                   status = false;
                else {
                   extract(item,status);
                   item = NULL;
                   }
                }
        /**
         * Removes a hash table item and returns the item's key.
         * The status flag is \c true if the item was found and \c false
         * otherwise.
         */
  virtual void remove(T*& item, KEY& key, bool& status)
                {
                if (!item)
                   status = false;
                else {
                   key = *(item->key());
                   extract(item,status);
                   item = NULL;
                   }
                }
	///
  virtual T* next(T* item);
	/// Write the hash table to an output stream.
  int      write(ostream& os) const;
	/// Read a hash table from an input stream.
  int      read(istream& is);
	/// Empty the hash table
  void clear();	
	/// TODO.
  void     statistics(ostream& os);
  bool& ignore_duplicates()
		{return ignore_duplicates_flag;}
 protected:
	///
  virtual size_type hash(KEY& key, size_type table_size) const
	if (curr_hashfn)
	   return (*curr_hashfn)(key,table_size);
	else
	   return hash_fn(key,table_size);
	/// Adds a hash table item to the tree.
  virtual T* insert(KEY* key);
	/// Adds a hash table item to the tree.
  void    insert(T* item, const bool resize_OK=true);
	/**
	 * Remove a hash table item.
	 * The status flag is \c true if the item was found and \c false
	 * otherwise.
	 */
  virtual void    extract(T* item, bool& status);
	/// TODO.
  void resize(const int newsize=-1);
	/// Find an item in the hash table.
  T* find(T* item) const
	{return find(*(item->key()));}
	/// pointers to actual data values
  LinkedList<T*> data;
	/// The hash table, which points at list item elements
  BasicArray<ListItem<T*>*> table;
	/// The size of the bucket in the hash table;
  BasicArray<int> bucket_size;
	/// Resize the table if (# vals)/(table.size()*max_bucket_size) > max_ratio
  double max_ratio;
	/// Resize the table if the chain in a bucket exceeds this value.
  int	max_bucket_size;
	///
  bool ignore_duplicates_flag;
	/// Note: assumes long is at least 32 bits.
   static const int __stl_num_primes;
	///
   static const unsigned long __stl_prime_list[__stl_num_primes];
	///
   size_type (*curr_hashfn)(KEY&,size_type);
template <class T, class KEY>
const int AbstractHashTable<T,KEY>::__stl_num_primes = 28;
template <class T, class KEY>
const unsigned long AbstractHashTable<T,KEY>::__stl_prime_list[] =
  	53,         97,           193,         389,       769,
  	1543,       3079,         6151,        12289,     24593,
  	49157,      98317,        196613,      393241,    786433,
  	1572869,    3145739,      6291469,     12582917,  25165843,
  	50331653,   100663319,    201326611,   402653189, 805306457,
  	1610612741, 3221225473ul, 4294967291ul
template <class T, class KEY>
inline ostream& operator<<(ostream& output, const AbstractHashTable<T,KEY>& 
					table)
{ table.write(output); return(output); }
template <class T, class KEY>
inline istream& operator>>(istream& input, AbstractHashTable<T,KEY>& table)
{ table.read(input); return(input); }
template <class T, class KEY>
AbstractHashTable<T,KEY>::AbstractHashTable(const char* /*nameBuff*/):
  table(__stl_prime_list[0]),
  bucket_size(__stl_prime_list[0]),
  max_ratio(0.75),
  max_bucket_size(16),
  ignore_duplicates_flag(true),
  curr_hashfn(0)
{ bucket_size=0; table = (ListItem<T*>*)NULL; }
template <class T, class KEY>
AbstractHashTable<T,KEY>::AbstractHashTable(size_type initial_size, 
						const char* /*nameBuff*/) :
  table(initial_size),
  bucket_size(initial_size),
  max_ratio(0.75),
  max_bucket_size(16),
  ignore_duplicates_flag(true),
  curr_hashfn(0)
{ bucket_size=0; table = (ListItem<T*>*)NULL; }
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::find(KEY& key) const
size_type index = hash(key, table.size());
if (bucket_size[index] == 0)
   return ((T*)NULL);
hash_element curr = table[index];
int i=0;
for (; curr && (i<bucket_size[index]); i++) {
  if (curr->data()->compare(&key) == 0)
     break;
  curr = data.next(curr);
if ((curr == NULL) || (i == bucket_size[index]))
   return NULL;
return curr->data();
// This code is virtually identical to 'find', only we return the 
// hash table item for the 'next' element in the 'data' linked list.
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::next(T* item)
size_type index = hash(*(item->key()),table.size());
if (bucket_size[index] == 0)
   return ((T*)NULL);
hash_element curr = table[index];
int i=0;
for (; i<bucket_size[index]; i++) {
  if (item->compare(curr->data()->key()) == 0)
     break;
  curr = data.next(curr);
curr = data.next(curr);
if (curr == NULL)
   return NULL;
return curr->data();
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::insert(KEY* key)
T* item = new T(key);
if (!item)
insert(item);
return item;
template <class T, class KEY>
void AbstractHashTable<T,KEY>::insert(T* item, const bool resize_OK)
bool resize_flag=false;
size_type index;
if ( !(ignore_duplicates_flag && (find(item) != NULL)) ) {
   index = hash(*(item->key()),table.size());
   table[index] = data.insert(item, table[index]);
   bucket_size[index]++;
   if (bucket_size[index] > max_bucket_size)
      resize_flag=true;
   }
if (resize_OK == false) return;
if ( (resize_flag == true) || 
     (max_ratio < (((double)data.size())/((double)table.size()*max_bucket_size))) )
   resize();
template <class T, class KEY>
void AbstractHashTable<T,KEY>::extract(T* item, bool& status)
hash_element curr;
status = false;
if ((curr = data.find(item)) != NULL) {
   size_type index = hash(*(item->key()),table.size());
   if (curr == table[index]) {
      if (bucket_size[index] > 1)
         table[index] = data.next(table[index]);
      else
         table[index] = NULL;
      }
   data.remove(curr);
   bucket_size[index]--;
   status = true;
   delete item;
   }
template <class T, class KEY>
void AbstractHashTable<T,KEY>::statistics(ostream& os)
size_type buckets = table.len();
size_type total_slots = buckets * max_bucket_size;
BasicArray<int> arry(max_bucket_size);
arry = 0;
for(size_type i = 0; i < buckets; i++) 		// For each bucket
  arry[bucket_size[i]]++; 			//  Bump array per slots used
// Print out general info
double pct_full = ((double)(data.size()))/total_slots;
char str[16];
if (data.size() > 0) {                        // Print out slot usage
   for(int i = 0; i < max_bucket_size; i++) {
     pct_full = (double)(arry[i]*100) / (double)buckets;
    }
template <class T, class KEY>
void AbstractHashTable<T,KEY>::clear()
bucket_size = 0;
while (data) {
  T* tmp = data.head()->data();
  delete tmp;
  data.remove(data.head());
table = (ListItem<T*>*)NULL;
template <class T, class KEY>
void AbstractHashTable<T,KEY>::resize(const int newsize)
int tmp = newsize;
int ctr=0;
bool flag=true;
while (flag) {
   if (tmp == -1) {
      int i=0;
      while (i < __stl_num_primes) {
        if (__stl_prime_list[i] > table.size())
           break;
        i++;
        }
      if (__stl_prime_list[i] <= table.size())
      tmp = __stl_prime_list[i];
      }
      
   table.resize(tmp);
   table = (ListItem<T*>*)NULL;
   bucket_size.resize(tmp);
   bucket_size = 0;
   int ndata = data.size();
   for (int i=0; i<ndata; i++) {
     T* tmp_item=NULL;
     data.remove(tmp_item);
     if (data.size() != (ndata-1))
     insert(tmp_item,false);
     if (data.size() != ndata)
     }
   //
   // Check to see if the bucket sizes are 'small enough'
   //
   flag = false;
   for (size_type j=0; j<bucket_size.size(); j++) {
     if (bucket_size[j] > max_bucket_size) {
        flag=true;
        ctr++;
	break;
        }
     }
   if (ctr == 5) {
      }
   else 
      tmp=-1;
   }
template <class T, class KEY>
int AbstractHashTable<T,KEY>::write(ostream& os) const
os << data.size() << endl;
hash_element curr = data.head();
while (curr) {
  curr->data()->write(os);
  os << endl;
  curr = data.next(curr);
return OK;
// BUGGY!!!
template <class T, class KEY>
int AbstractHashTable<T,KEY>::read(istream& is)
clear();
size_type Size;
is >> Size;
for (size_type i=0; i<Size; i++) {
  T* item;
  item->read(is);
  insert(item);
return OK;
#endif
// AbstractHashTable.h
 * \class AbstractHashTable
 * Implements and abstract class for defining the core operations of a
 * hash table with chaining.  This hash table uses buckets with a fixed depth,
 * which may have problems with poor hashing functions.
 * Note: the 'next' method doesn't work if ignore_duplicate==false
 * and there exist duplicates in the hash table.  The could probably be
 * fixed by using a iterator construct, though, instead of this method.
 * Consequently, ignore_duplicate==true by default.
#ifndef __AbstractHashTable_h
#define __AbstractHashTable_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
#include <string.h>
#include <stdio.h>
// Externs of a list of primes that are good for hash tables
extern int 		utilib_num_primes;
extern unsigned long 	utilib_prime_list[];
template <class T, class KEY>
class UTILIB_API AbstractHashTable
public:
	/// The type of the hash indeces
  typedef size_t size_type;
	/// The type of a list of hash elements
  typedef ListItem<T*>* hash_element;
public:
	/// Constructor.
	/// Constructor.
	/// Dummy destructor
  virtual ~AbstractHashTable()
		clear();
		ListItem<T*>::delete_unused();
	/// Returns \c true if the list is empty and \c false otherwise.
  bool      empty() const {return (data.len() == 0);}
	/// Returns \c true if the list is empty and \c false otherwise.
  operator bool()   const {return (data.len() != 0);}
	/// Returns the number of elements in the hash table.
  int      size()  const {return data.len();}
	/**
	 * Return the item in the hash table with the given key.
	 * Returns null if the table is empty or if the item is not in
	 * the tree.
	 */
  virtual T* find(KEY& key) const;
	/// Return the ``first'' element in the hash table.
  virtual T* first() const
		if (data.len() == 0) return ((T*)0);
		return data.head()->data(); 
	/// Add a key to the hash table.
  virtual void add(KEY& key)
		{insert(&key);}
	/**
	 * Add a key to the hash table and return the hash table item 
	 * that contains it.
	 */
  virtual void add(KEY& key, T*& item)
		{item = insert(&key);}
	/**
         * Remove a hash table item with the given key.
         * The status flag is \c true if the key was found and \c false
         * otherwise.
         */
  virtual void remove( KEY& key, bool& status)
		T* tmp = find(key);
		if (tmp) extract(tmp,status);
		else     status = false;
        /**
         * Remove a hash table item.
         * The status flag is \c true if the item was found and \c false
         * otherwise.
         */
  virtual void remove(T*& item, bool& status)
                if (!item)
                   status = false;
                else {
                   extract(item,status);
                   item = NULL;
                   }
                }
        /**
         * Removes a hash table item and returns the item's key.
         * The status flag is \c true if the item was found and \c false
         * otherwise.
         */
  virtual void remove(T*& item, KEY& key, bool& status)
                {
                if (!item)
                   status = false;
                else {
                   key = *(item->key());
                   extract(item,status);
                   item = NULL;
                   }
                }
	///
  virtual T* next(T* item);
	/// Write the hash table to an output stream.
  int      write(ostream& os) const;
	/// Read a hash table from an input stream.
  int      read(istream& is);
	/// Empty the hash table
  void clear();	
	/// TODO.
  void     statistics(ostream& os);
  bool& ignore_duplicates()
		{return ignore_duplicates_flag;}
  	///
  bool using_prime_ht;
 protected:
	///
  virtual size_type hash(KEY& key, size_type table_size) const
	if (curr_hashfn)
	   return (*curr_hashfn)(key,table_size);
	else
	   return hash_fn(key,table_size);
	/// Adds a hash table item to the tree.
  virtual T* insert(KEY* key);
	/// Adds a hash table item to the tree.
  void    insert(T* item, const bool resize_OK=true);
	/**
	 * Remove a hash table item.
	 * The status flag is \c true if the item was found and \c false
	 * otherwise.
	 */
  virtual void    extract(T* item, bool& status);
	/// TODO.
  void resize(const int newsize=-1);
	/// Find an item in the hash table.
  T* find(T* item) const
	{return find(*(item->key()));}
	/// pointers to actual data values
  LinkedList<T*> data;
	/// The hash table, which points at list item elements
  BasicArray<ListItem<T*>*> table;
	/// The size of the bucket in the hash table;
  BasicArray<int> bucket_size;
	/// Resize the table if (# vals)/(table.size()) > max_load
  double max_load;
	///
  bool ignore_duplicates_flag;
	///
  size_type (*curr_hashfn)(KEY&,size_type);
template <class T, class KEY>
inline ostream& operator<<(ostream& output, const AbstractHashTable<T,KEY>& 
					table)
{ table.write(output); return(output); }
template <class T, class KEY>
inline istream& operator>>(istream& input, AbstractHashTable<T,KEY>& table)
{ table.read(input); return(input); }
template <class T, class KEY>
AbstractHashTable<T,KEY>::AbstractHashTable(const char* /*nameBuff*/):
  using_prime_ht(true),
  table(utilib_prime_list[0]),
  bucket_size(utilib_prime_list[0]),
  max_load(3.0),
  ignore_duplicates_flag(true),
  curr_hashfn(0)
{ bucket_size=0; table = (ListItem<T*>*)NULL; }
template <class T, class KEY>
AbstractHashTable<T,KEY>::AbstractHashTable(size_type initial_size, 
						const char* /*nameBuff*/) :
  using_prime_ht(true),
  table(initial_size),
  bucket_size(initial_size),
  max_load(3.0),
  ignore_duplicates_flag(true),
  curr_hashfn(0)
{ bucket_size=0; table = (ListItem<T*>*)NULL; }
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::find(KEY& key) const
size_type index = hash(key, table.size());
if (bucket_size[index] == 0)
   return ((T*)NULL);
hash_element curr = table[index];
int i=0;
for (; curr && (i<bucket_size[index]); i++) {
  if (curr->data()->compare(&key) == 0)
     break;
  curr = data.next(curr);
if ((curr == NULL) || (i == bucket_size[index]))
   return NULL;
return curr->data();
// This code is virtually identical to 'find', only we return the 
// hash table item for the 'next' element in the 'data' linked list.
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::next(T* item)
size_type index = hash(*(item->key()),table.size());
if (bucket_size[index] == 0)
   return ((T*)NULL);
hash_element curr = table[index];
int i=0;
for (; i<bucket_size[index]; i++) {
  if (item->compare(curr->data()->key()) == 0)
     break;
  curr = data.next(curr);
curr = data.next(curr);
if (curr == NULL)
   return NULL;
return curr->data();
template <class T, class KEY>
T* AbstractHashTable<T,KEY>::insert(KEY* key)
T* item = new T(key);
if (!item)
insert(item);
return item;
template <class T, class KEY>
void AbstractHashTable<T,KEY>::insert(T* item, const bool resize_OK)
bool resize_flag=false;
size_type index;
if ( !(ignore_duplicates_flag && (find(item) != NULL)) ) {
   index = hash(*(item->key()),table.size());
   table[index] = data.insert(item, table[index]);
   bucket_size[index]++;
   }
if (resize_OK == false) return;
if ( (resize_flag == true) || 
     (max_load < (((double)data.size())/((double)table.size()))) )
   resize();
template <class T, class KEY>
void AbstractHashTable<T,KEY>::extract(T* item, bool& status)
hash_element curr;
status = false;
if ((curr = data.find(item)) != NULL) {
   size_type index = hash(*(item->key()),table.size());
   if (curr == table[index]) {
      if (bucket_size[index] > 1)
         table[index] = data.next(table[index]);
      else
         table[index] = NULL;
      }
   data.remove(curr);
   bucket_size[index]--;
   status = true;
   delete item;
   }
template <class T, class KEY>
void AbstractHashTable<T,KEY>::statistics(ostream& os)
char str[128];
os << str << endl;
size_type buckets = table.len();
int tnbuckets=0;
for (int j=0; j<16; j++) {
  int nbuckets=0;
  int nobjs=0;
  for (size_type i=0; i < buckets; i++) {
    if (bucket_size[i] == j) {
       nbuckets++;
       nobjs += j;
       }
  tnbuckets+=nobjs;
  os << str << endl;
int nbuckets=0;
int nobjs=0;
for (size_type i=0; i < buckets; i++) {
  if (bucket_size[i] >= 16) {
     nbuckets++;
     nobjs += bucket_size[i];
     }
tnbuckets+=nobjs;
os << str << endl;
template <class T, class KEY>
void AbstractHashTable<T,KEY>::clear()
bucket_size = 0;
while (data) {
  T* tmp = data.head()->data();
  delete tmp;
  data.remove(data.head());
table = (ListItem<T*>*)NULL;
template <class T, class KEY>
void AbstractHashTable<T,KEY>::resize(const int newsize)
int tmp = newsize;
bool flag=true;
while (flag) {
   if (tmp == -1) {
      if (using_prime_ht) {
         int i=0;
         while (i < utilib_num_primes) {
           if (utilib_prime_list[i] > table.size())
              break;
           i++;
           }
         if (utilib_prime_list[i] <= table.size())
         tmp = utilib_prime_list[i];
         }
      else {
         tmp = table.size()*2;
         }
      }
      
   table.resize(tmp);
   table = (ListItem<T*>*)NULL;
   bucket_size.resize(tmp);
   bucket_size = 0;
   int ndata = data.size();
   for (int i=0; i<ndata; i++) {
     T* tmp_item=NULL;
     data.remove(tmp_item);
     if (data.size() != (ndata-1))
     insert(tmp_item,false);
     if (data.size() != ndata)
     }
   //
   // We might need to loop until the table is big enough, so
   // we set the flag variable for now...
   //
   flag = false;
   }
template <class T, class KEY>
int AbstractHashTable<T,KEY>::write(ostream& os) const
os << data.size() << endl;
hash_element curr = data.head();
while (curr) {
  curr->data()->write(os);
  os << endl;
  curr = data.next(curr);
return OK;
// BUGGY!!!
template <class T, class KEY>
int AbstractHashTable<T,KEY>::read(istream& is)
clear();
size_type Size;
is >> Size;
for (size_type i=0; i<Size; i++) {
  T* item;
  item->read(is);
  insert(item);
return OK;
#endif
// AbstractHeap.h
 * \class AbstractHeap
 * An abstract C++ heap that uses an array of \c AbstractHeapItem's.
 * This class is based on a generic heap class initially develop by
 * Jonathan Eckstein (Rutgers).
#ifndef __AbstractHeap_h
#define __AbstractHeap_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif
class UTILIB_API AbstractHeap;
 * \enum OrderSense
 * Bias used for comparisons in a dynamic ADT.
#ifndef ORDERSENSE
#define ORDERSENSE
enum OrderSense
   increasing=1,  /**< Order from least to greatest */
   decreasing=-1, /**< Order from greatest to least */
   minimal=1,
   maximal=-1
 #endif
 * \class AbstractHeapItem
 * An abstract heap item.
class UTILIB_API AbstractHeapItem
  friend AbstractHeap;
protected:
	/// Returns the key to this item.
  virtual void* key() {return (void*)0;}
	/// The location of the heap item in the array.
  int element;
	/// Empty constructor.
  AbstractHeapItem() : element(0) {}
class UTILIB_API AbstractHeap 
public:
	/// Default size of the heap.
  enum { defaultSize    = 256 };
	/// TODO
  enum { defaultQuantum = 256 };
	/// Constructor, which allows the heap to be named.
       int initSize = defaultSize, 
       int quantumChoice = defaultQuantum);
	/// Destructor.
  virtual ~AbstractHeap();
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  int empty() const
		{return (used == 0);}
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  operator int() const
		{return (used != 0);}
	/// Returns the number of items in the heap.
  int size() const
		{ return used; }
        /// Return the value of \c Sense.
  OrderSense sense() {return Sense;}
	/// Set the value of \c Sense.
  void setSense(OrderSense sense_) {Sense=sense_;}
	/// Write the heap to an output stream.
  int write(ostream& os) const;
	/// Read a heap from an input stream.
  int read(istream& is);
	/// TODO
  int prune();
protected:
	/// Specifies the ordering within the tree: increasing or decreasing.
  OrderSense Sense;
	/// Return the top of the heap.
  AbstractHeapItem* top() 
    	{ 
      	if (used <= 0) 
        return tree[1]; 
        }
	/// Return a specific element of the heap.
  AbstractHeapItem* member(int element) const
		{ return tree[element]; }
	/// Add an item to the heap.
  void add(AbstractHeapItem* item);
	/**
	 * Remove a heap item from the heap.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(AbstractHeapItem* item, int& status);
	/// TODO.
  int refloatElement(int element);
        /**
         * Compare \a key with the current key, returning a value that is
         * consistent with the
         * \if GeneratingLaTeX standard comparison semantics (see Section~\ref{compare} \endif
         */
  virtual int compare(const void* key, const void* key2) = 0;
	/// Write a single heap item to an output stream.
  virtual void write_item(ostream& os, AbstractHeapItem* item) const = 0;
	/// Read a single heap item from an input stream.
  virtual void read_item(istream& is, AbstractHeapItem*& item) = 0;
	/// TODO.
  virtual int  prunable(AbstractHeapItem* /*item*/) {return 0;}
	/// TODO.
  virtual void deleteElement(const int element) = 0;
	/// TODO.
  virtual void moveEffect(AbstractHeapItem* /*item*/) {}
	/// TODO.
  virtual void addEffect(AbstractHeapItem* /*item*/) {}
	/// TODO.
  virtual void removeEffect(AbstractHeapItem* item)
		{item->element=0;}
	/// TODO.
  virtual void pruneEffect(AbstractHeapItem* /*item*/) {}
private:
	/// The number of items in the heap.
  int    used;
	/// The size of the \c tree array.
  int    allocated;
	/// The quantity by which the \c tree array is increased.
  int    quantum;
	/// The array that contains the heap.
  AbstractHeapItem** tree;
	/// The name of the heap.
  const char*  name;
	/// TODO.
  void swap(int a,int b);
	/// TODO.
  int floatUp(int element);
	/// TODO.
  int sinkDown(int element);
inline ostream& operator<<(ostream& output, const AbstractHeap& heap)
{ heap.write(output); return(output); }
inline istream& operator>>(istream& input, AbstractHeap& heap)
{ heap.read(input); return(input); }
#endif
// AbstractSplayTree.h
 * \class AbstractSplayTree
 * A top-down splay tree with sizes.  This is adapted from code
 * developed by D. Sleator, which itself is adapted from simple
 * top-down splay, at the bottom of 669 of 
 * \if GeneratingLaTeX Sleator and Tarjan~\cite{SleTar85}. \endif
 * Sleator's code can be aquired from
 *   http://www-cgi.cs.cmu.edu/afs/cs/user/sleator/www/home.html
#ifndef __AbstractSplayTree_h
#define __AbstractSplayTree_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif
class UTILIB_API AbstractSplayTree;
 * \enum OrderSense
 * Bias used for comparisons in a dynamic ADT.
#ifndef ORDERSENSE
#define ORDERSENSE
enum OrderSense
  increasing=1, /**< Order from least to greatest */
  decreasing=-1, /**< Order from greatest to least */
  minimal=1,
  maximal=-1
#endif
 * \class AbstractSplayTreeItem
 * A simple container class that is used by \c AbstractSplayTree.
 * This class definition provides the basic mechanisms for splay tree items
 * that are needed to define an abstract splay tree.
class UTILIB_API AbstractSplayTreeItem
  friend AbstractSplayTree;
public:
	/// Returns the size of the subtree.
  int Size() {return size;}
	/// Returns the left subtree.
  AbstractSplayTreeItem* Left() {return left;}
	/// Returns the right subtree.
  AbstractSplayTreeItem* Right() {return right;}
protected:
	/// Returns a generic pointer to a key object.
  virtual void* Key() {return (void*)0;}
	/// Pointer to the left subtree.
  AbstractSplayTreeItem *left;
	/// Pointer to the right subtree.
  AbstractSplayTreeItem *right;
	/// The size of the subtree below this item and including this item.
  int size;
	/// Empty constructor.
  AbstractSplayTreeItem() : left(0), right(0), size(0) {}
class UTILIB_API AbstractSplayTree 
public:
	/// Constructor, which specifies a name for the tree.
	/// Destructor.
  virtual ~AbstractSplayTree() {}
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  int empty() const
		{return (counter == 0);}
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  operator int() const
		{return (counter != 0);}
	/// Returns the size of the splay tree.
  int size() const
		{ return counter; }
        /// Return the value of \c Sense.
  OrderSense sense() {return Sense;}
	/// Set the value of \c Sense.
  void setSense(OrderSense sense_) {Sense=sense_;}
	/// Write the splay tree to an output stream.
  int write(ostream& os);
	/// Read the splay tree from an input stream.
  int read(istream& is);
	/// Returns the rank of the top (0...size-1)
  int rank()
		{return (t->left ? t->left->size : 0);}
	/// Empty out a splay tree.
  void clear();
protected:
	/// Delete \a item from the splay tree.
  virtual void delete_item(AbstractSplayTreeItem* item) = 0;
	/**
	 * Return the item in the splay tree with rank \a r.
	 * Returns a null item if a bad rank value is passed in.
	 */
  AbstractSplayTreeItem* find_rank(int r);
	/**
	 * Return the item in the splay tree with the given key.
	 * Returns null if the tree is empty or if the item is not
	 * in the tree.
	 */
  AbstractSplayTreeItem* find(const void* key)
		splay(key);
		if (!t) return t;
		if (compare(key,t->Key()) == 0) return t;
		else                            return (AbstractSplayTreeItem*)0;
	/// Return the top of the splay tree.
  AbstractSplayTreeItem* top()
		{return t;}
	/// Adds a splay tree item to the tree.
  void add(AbstractSplayTreeItem* item);
	/**
	 * Removes a splay tree item.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(AbstractSplayTreeItem* item, int& status);
        /**
         * Compare two key objects, returning a value that is
         * consistent with the
         * \if GeneratingLaTeX standard comparison semantics (see Section~\ref{compare} \endif
         */
  virtual int compare(const void* key1, const void* key2) = 0;
	/// Write a single splay tree item to an output stream.
  virtual void write_item(ostream& os, AbstractSplayTreeItem* item) = 0;
	/// Read a single splay tree item from an input stream.
  virtual void read_item(istream& is, AbstractSplayTreeItem*& item) = 0;
//  void print_tree(ostream& os, int d, AbstractSplayTreeItem* item);
	/// Perform a splay operation starting from the root of the tree.
  void splay(const void* key)
		{t = splay(key,t);}
	/// The current root of the splay tree.
  AbstractSplayTreeItem* t;
        /// Specifies the ordering within the tree: increasing or decreasing.
  OrderSense Sense;
	/**
	 * Search for an item with a given key on a tree rooted at \a item.  
	 * If an item is found in the tree, it is splayed to the root.
	 * Otherwise, the item put at the root is the last one before \c NULL 
	 * that would have been reached in a normal binary search.  
	 * (It is a neighbor of i in the tree.)  This method of splaying 
	 * is very convenient for facilitating a variety of other operations.
	 */
  AbstractSplayTreeItem* splay(const void* key, AbstractSplayTreeItem* item);
	/// The name of the class instance.
  const char* name;
	/// The number of items in the tree.
  int counter;
inline UTILIB_API ostream& operator<<(ostream& output, AbstractSplayTree& tree)
{ tree.write(output); return(output); }
inline UTILIB_API istream& operator>>(istream& input, AbstractSplayTree& tree)
{ tree.read(input); return(input); }
#endif
// Basic2DArray.h
 * \class Basic2DArray
 * A 2D array data type that manages the allocation and
 * deallocation of memory.  Note that 2DArrays are different from Arrays
 * of Arrays, though they are quite similar.  This class is similar to a
 * dense matrix class, and it should probably be replaced with a real dense
 * matrix facility.
#ifndef __Basic2DArray_h
#define __Basic2DArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <stdlib.h>
#include <assert.h>
#else
#include <iostream>
#include <cstdlib>
#include <cassert>
#endif
#ifndef SWIG
 * \def TwoDArraySanityChecking
 * If the macro TwoDArraySanityChecking=1 then some routine sanity checks will 
 * be performed when accessing vectors.  Sanity checking generally degrades 
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with TwoDArraySanityChecking=0 to 
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(TwoDArraySanityChecking)
#define TwoDArraySanityChecking    1
#endif
template <class T>
class UTILIB_API Basic2DArray;
template <class T>
class UTILIB_API Simple2DArray;
template <class T>
class UTILIB_API Num2DArray;
 * \class Basic2DArrayRep
 * The internal class that is used to manage the data for
 * \c Basic2DArray's and their derived classes.
template <class T>
class UTILIB_API Basic2DArrayRep {
  friend class Basic2DArray<T>;
  friend class Simple2DArray<T>;
  friend class Num2DArray<T>;
protected:
	/// Empty constructor.
  Basic2DArrayRep() {ref=1; Nrows=0; Ncols=0; Data=0;}
	/// The pointer to the data.
  T** Data; 
	/// Number of 2D arrays that are referencing this \b Basic3DArrayRep instance
  int ref;
	/// Number of rows.
  size_type Nrows;
	/// Number of columns.
  size_type Ncols;
	/// The ownership category for the main data array.
  EnumDataOwned own_data;
	/// The ownership category for the data that the main array points to.
  EnumDataOwned own_ptrs;
#endif // SWIG
#ifdef SWIG
template <class T>
class Basic2DArray
#else
template <class T>
class UTILIB_API Basic2DArray
#endif
public:
	/// Null constructor.
  Basic2DArray()
		{construct(0,0,(T*)0);}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Basic2DArray(const BasicArray<T>& array, const size_type nrows=1, 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,array.size()/nrows,array,own);}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c d object.
	 */
  Basic2DArray(const size_type nrows, const size_type ncols, T *d=((T*)0), 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,ncols,d,own);}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Basic2DArray(const size_type nrows, const size_type ncols, 
		const BasicArray<T>& array, 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,ncols,array,own);}
	/// Copy constructor.
  Basic2DArray(const Basic2DArray& array)
		{construct(array.a->Nrows,array.a->Ncols,array.a->Data,
				AcquireOwnership);}
	/// Destructor.
  virtual ~Basic2DArray()
	{free();}
	/// Resize the 2D array.
  int resize(const size_type nrows, const size_type ncols);
	/// Returns the number of rows in the 2D array
  size_type nrows() const
	{return a->Nrows;}
	/// Returns the number of columns in the 2D array
  size_type ncols() const
	{return a->Ncols;}
	/// Coersion operator that returns the internal array of pointers.
  operator T** () const
	{return a->Data;}
	/// Returns the internal array of pointers.
  T** data() const
	{return a->Data;}
	/// Returns the number of references to the internal array.
  int nrefs() const
	{return a->ref;}
	/// Returns the i-th row of the 2D array
  T* operator[](const int i);
	/// Returns the i-th row of the 2D array
  T* operator[](const int i) const;
	/// Returns the i-th row of the 2D array
  T* operator[](const size_type i);
	/// Returns the i-th row of the 2D array
  T* operator[](const size_type i) const;
	/// Returns the element from the row-th row and col-th column
  T& operator()(const size_type row, const size_type col);
	/// Returns the element from the row-th row and col-th column
  const T& operator()(const size_type row, const size_type col) const;
	/// Copies the \b array object by constructing a new \b Basic2DArray
  Basic2DArray<T>& operator=(const Basic2DArray<T>& array);
	/// Copies the pointer from the \b array object
  Basic2DArray<T>& operator&=(const Basic2DArray<T>& array);
	/// Copies the 2D array without memory allocation
  Basic2DArray<T>& operator<<(const Basic2DArray<T>& array);
	/// Set all elements of the array to \b val.
  Basic2DArray<T>& operator=(const T& val);
	/// Set all rows of the 2D array to \b val.
  Basic2DArray<T>& operator=(const BasicArray<T>& val);
	/**
	 * Method to explicitly set the internal data array.
	 * The current array is resized to length \a len, and pointers in the
	 * array are setup to point into the \a data array.
	 */
  Basic2DArray<T>& set_data(const size_type len, T* data,
                                const EnumDataOwned o=DataNotOwned);
	/// Method to explicitly set the internal data array using a \a BasicArray object.
  Basic2DArray<T>& set_data(const BasicArray<T>& array,
                                const EnumDataOwned o=DataNotOwned)
		{return set_data(array.size(),array,o);}
/* BUG??  Where are these defined?
  friend Basic2DArray<T> T(const BasicArray<T>& array);
	/// HUH???
  friend Basic2DArray<T> T(const Basic2DArray<T>& array);
protected:
	/// Pointer to the 2D array representation.
  Basic2DArrayRep<T>* a;
	/// Constructor method that provides the array of data elements
  void construct(const size_type nrows, const size_type ncols, T *d, 
		const EnumDataOwned o=DataNotOwned);
	/// Constructor method that provides the complete 2D array
  void construct(const size_type nrows, const size_type ncols, T** d, 
		const EnumDataOwned o=DataNotOwned);
	/// Method used to free up the 2D array
  void free();
template <class T>
inline T* Basic2DArray<T>::operator[](const int idx)
#if (TwoDArraySanityChecking==1)
if ((idx < 0) || ((size_type)idx >= a->Nrows))
#endif
return a->Data[idx];
template <class T>
inline T* Basic2DArray<T>::operator[](const int idx) const
#if (TwoDArraySanityChecking==1)
if ((idx < 0) || ((size_type)idx >= a->Nrows))
#endif
return a->Data[idx];
template <class T>
inline T* Basic2DArray<T>::operator[](const size_type idx)
#if (TwoDArraySanityChecking==1)
if (idx >= a->Nrows)
#endif
return a->Data[idx];
template <class T>
inline T* Basic2DArray<T>::operator[](const size_type idx) const
#if (TwoDArraySanityChecking==1)
if (idx >= a->Nrows)
#endif
return a->Data[idx];
template <class T>
inline T& Basic2DArray<T>::operator()(const size_type row, const size_type col)
#if (TwoDArraySanityChecking==1)
if ((row >= a->Nrows) || (col >= a->Ncols))
#endif
return a->Data[row][col];
template <class T>
inline const T& Basic2DArray<T>::operator()(const size_type row, const size_type col) const
#if (TwoDArraySanityChecking==1)
if ((row >= a->Nrows) || (col >= a->Ncols))
#endif
return a->Data[row][col];
template <class T>
void Basic2DArray<T>::construct(const size_type nrows, const size_type ncols, T * d, 
					const EnumDataOwned o)
a = new Basic2DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T [ncols] ;
            assert(a->Data[i] != 0);
            }
	 size_type ndx=0;
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             a->Data[ii][jj] = d[ndx++];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         T* tmp = d;
         for (size_type i=0; i<ncols; i++) {
            a->Data[i] = tmp;
            tmp+= ncols;
            }
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic2DArray<T>::construct(const size_type nrows, const size_type ncols, T **d, 
					const EnumDataOwned o)
a = new Basic2DArrayRep<T>;
assert(a != 0);
a->Nrows = nrows;
a->Ncols = ncols;
if (d == NULL) {
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   }
else {
   if (o == AcquireOwnership) {
      if (nrows > 0)  {
         a->Data = new T* [nrows] ;
	 assert(a->Data != 0);
         for (size_type i=0; i<nrows; i++) {
            a->Data[i] = new T [ncols] ;
            assert(a->Data[i] != 0);
            }
         for (size_type ii=0; ii<nrows; ii++)
           for (size_type jj=0; jj<ncols; jj++)
             a->Data[ii][jj] = d[ii][jj];
         }
      else
         a->Data = NULL;
      a->own_ptrs = AcquireOwnership;
      a->own_data = AcquireOwnership;
      }
   else {
      a->Data=d;
      a->own_ptrs = DataNotOwned;
      a->own_data = DataNotOwned;
      }
   }
template <class T>
void Basic2DArray<T>::free()
if (--a->ref == 0) {
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++)
           delete [] a->Data[i];
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   delete a;
   }
template <class T>
int Basic2DArray<T>::resize(const size_type nrows, const size_type ncols)
// Maybe we get lucky.
if ((ncols == a->Ncols) && (nrows == a->Nrows))
   return OK;
// Need to completely replace old data.
if ((ncols != a->Ncols) && (nrows != a->Nrows)) {
   //
   // Delete old data (if owned)
   //
   if ((a->Data) && (a->Nrows>0)) {
      if (a->own_data && (a->Ncols > 0)) {
         for (size_type i=0; i<a->Nrows; i++)
           delete [] a->Data[i];
         }
      if (a->own_ptrs)
         delete [] a->Data;
      }
   //
   // Make new data
   //
   if (nrows > 0) {
      a->Data = new T* [nrows] ;
      assert(a != 0);
      for (size_type i=0; i<nrows; i++) {
         a->Data[i] = new T [ncols] ;
         assert(a->Data[i] != 0);
         }
      }
   else
      a->Data = NULL;
   a->own_ptrs = AcquireOwnership;
   a->own_data = AcquireOwnership;
   a->Nrows = nrows;
   a->Ncols = ncols;
   return OK;
   }
// We need to simply resize the number of rows.
if (nrows != a->Nrows) {
   T **d=NULL;
   if (nrows > 0) {
      d = new T* [nrows];
      assert(d != 0);
      // 
      // Note:  the new memory is not initialized beyond what the constructors
      // do.
      //
      if (a->Nrows > 0) {
         for (size_type i=0; i<min(nrows,a->Nrows); i++)
           d[i] = a->Data[i];
         }
      }
   if (a->Data && a->own_ptrs && (a->Nrows > 0))
      delete [] a->Data;
   a->Data = d;
   a->Nrows = nrows;
   }
// We need to simply resize the number of columns
if (ncols != a->Ncols) {
   if (ncols > 0) {
      for (size_type j=0; j<a->Nrows; j++) {
        T* d=NULL;
        d = new T [ncols];
        assert(d != 0);
        // 
        // Note:  the new memory is not initialized beyond what the constructors
        // do.
        //
        if (a->Ncols > 0) {
           for (size_type i=0; i<min(ncols,a->Ncols); i++)
             d[i] = a->Data[j][i];
           }
        if (a->Data && a->own_data && (a->Ncols > 0))
           delete [] a->Data[j];
        a->Data[j] = d;
        }
      }
   else 
      if (a->Data && a->own_data && (a->Ncols > 0))
         for (size_type i=0; i<a->Nrows; i++) {
           delete [] a->Data[i];
           a->Data[i] = NULL;
           }
   a->Ncols = ncols;
   }
return OK;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const Basic2DArray<T>& array)
if (this != &array) {
   free();
   construct(array.nrows(),array.ncols(),array.data(),AcquireOwnership);
   }
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator<<(const Basic2DArray<T>& array)
if (array.a == a)
   return *this;
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = array.a->Data[i][j];
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator&=(const Basic2DArray<T>& array)
if (array.a == a) return *this;
free();
a = array.a;
a->ref++;
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const T& val)
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = ( T ) val;
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::operator=(const BasicArray<T>& val)
if (a->Ncols != val.size())
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    a->Data[i][j] = val[j];
return *this;
template <class T>
Basic2DArray<T>& Basic2DArray<T>::set_data(const size_type len, T * data, const EnumDataOwned o)
#if TwoDArraySanityChecking==1
if ( (nrows()*ncols()) != len)
			(nrows()*ncols()),len));
#endif
if (a->own_data && (a->Ncols > 0)) {
   for (size_type i=0; i<a->Nrows; i++)
     delete [] a->Data[i];
   }
size_type ndx=0;
for (size_type i=0; i<a->Nrows; i++) {
  a->Data[i] = &(data[ndx]);
  ndx += a->Ncols;
// BUG: I need to fix the model of ownership here.
a->own_data = DataNotOwned;
return *this;
#endif
// Basic3DArray.h
// Definitions for a basic 3D array data type that manages the allocation and
// deallocation of memory.  Note that 3DArrays are different from Arrays
// of 2D Arrays, though they are quite similar.
// William Hart
#ifndef __Basic3DArray_h
#define __Basic3DArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
#if !defined(Basic3DArrayT)
#ifdef USING_TEMPLATES
#define Basic3DArrayT(T) Basic3DArray<##T##>
#else
#define Basic3DArrayT(T) Basic3DArray_##T
#endif
#endif
// If the macro TwoDArraySanityChecking=1 then some routine sanity checks will 
// be performed when accessing vectors.  Sanity checking generally degrades 
// performance.  The default is is to perform sanity checking.
// -O is used, you can define some files with TwoDArraySanityChecking=0 to 
// acheive better performance, while using the default debugging mode in the
// rest of the code.
#if !defined(TwoDArraySanityChecking)
#define TwoDArraySanityChecking    1
#endif
template <class T>
class UTILIB_API Basic3DArray;
template <class T>
class UTILIB_API Simple3DArray;
template <class T>
class UTILIB_API Num3DArray;
// The internal class that is used to manage the data for
// Basic3DArray's and their derived classes.
// Ownership Categories
// DataNotOwned     - Data owned by some other Simple3DArray
// AcquireOwnership - Data originally copied from another Simple3DArray
// AssumeOwnership  - Data pointer points to another Simple3DArray's data
template <class T>
class UTILIB_API   Basic3DArrayRep {
  friend class Basic3DArray<T>;
  friend class Simple3DArray<T>;
  friend class Num3DArray<T>;
protected:
  Basic3DArrayRep() {ref=1; Nrows=0; Ncols=0; Data=0;}
  T** Data; 
  int ref;
  size_type Nrows;
  size_type Ncols;
  EnumDataOwned own_data;
  EnumDataOwned own_ptrs;
// The main body of the Basic3DArray class.
template <class T>
class UTILIB_API Basic3DArray
public:
  Basic3DArray()
		{construct(0,0,(T*)0);}
  Basic3DArray(const BasicArray<T>& array, const size_type nrows=1, 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,array.size()/nrows,array,own);}
  Basic3DArray(const size_type nrows, const size_type ncols, T *d=((T*)0), 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,ncols,d,own);}
  Basic3DArray(const size_type nrows, const size_type ncols, const BasicArray<T>& array, 
		const EnumDataOwned own=DataNotOwned)
		{construct(nrows,ncols,array,own);}
  Basic3DArray(const Basic3DArray& array)
		{construct(array.nrows(),array.ncols(),array.data(),
				AcquireOwnership);}
  virtual ~Basic3DArray()
	{free();}
  int resize(const size_type nrows, const size_type ncols);
  size_type nrows() const
	{return a->Nrows;}
  size_type ncols() const
	{return a->Ncols;}
  operator T** () const
	{return a->Data;}
  T** data() const
	{return a->Data;}
  int nrefs() const
	{return a->ref;}
  T* operator[](const size_type );
  const T* operator[](const size_type ) const;
  T& operator()(const size_type row, const size_type col);
  const T& operator()(const size_type row, const size_type col) const;
  Basic3DArray<T>& operator=(const Basic3DArray<T>& array); // construct & copy
  Basic3DArray<T>& operator&=(const Basic3DArray<T>& array);// copy ptr
  Basic3DArray<T>& operator<<(const Basic3DArray<T>& array);// copy 3Darray
  Basic3DArray<T>& operator=(const T& val);		// 3Darray set to val
  Basic3DArray<T>& operator=(const BasicArray<T>& val);	// rows set to val
  Basic3DArray<T>& set_data(const size_type len, T* data,
                                const EnumDataOwned o=DataNotOwned);
  Basic3DArray<T>& set_data(const BasicArray<T>& array,
                                const EnumDataOwned o=DataNotOwned)
		{return set_data(array.size(),array,o);}
  friend Basic3DArray<T> T(const BasicArray<T>& array);
  friend Basic3DArray<T> T(const Basic3DArray<T>& array);
protected:
  Basic3DArrayRep<T>* a;
  void construct(const size_type nrows, const size_type ncols, T *d, 
		const EnumDataOwned o=DataNotOwned);
  void construct(const size_type nrows, const size_type ncols, T** d, 
		const EnumDataOwned o=DataNotOwned);
  void free();
template <class T>
inline T* Basic3DArray<T>::operator[](const size_type idx)
#if (TwoDArraySanityChecking==1)
if ((idx < 0) || (idx >= a->Nrows))
#endif
return a->Data[idx];
template <class T>
inline const T* Basic3DArray<T>::operator[](const size_type idx) const
#if (TwoDArraySanityChecking==1)
if ((idx < 0) || (idx >= a->Nrows))
#endif
return a->Data[idx];
template <class T>
inline T& Basic3DArray<T>::operator()(const size_type row, const size_type col)
#if (TwoDArraySanityChecking==1)
if ((row < 0) || (row >= a->Nrows) || (col < 0) || (col >= a->Ncols))
#endif
return a->Data[row][col];
template <class T>
inline const T& Basic3DArray<T>::operator()(const size_type row, const size_type col) const
#if (TwoDArraySanityChecking==1)
if ((row < 0) || (row >= a->Nrows) || (col < 0) || (col >= a->Ncols))
#endif
return a->Data[row][col];
#endif
// BasicArray.h
 * \class BasicArray
 * A array data type that manages the allocation and
 * deallocation of memory.  This code is strongly influenced on the discussion
 * code represents an extension of the vector class developed by Brian Bartell,
 * UC San Diego.
 * To minimize the memory impact of these arrays, the reference count is
 * only used when needed.  Specifically, the \c ArrayRef class is 
 * used (1) when a constructor passes data that is not owned by the array
 * or (2) after methods like operator&= and set_data are called, which 
 * initiate the use of reference counting.  Thus by default the memory
 * usage of a \c BasicArray is a pointer, an integer counter and the 
 * memory in the array.
 * Note that this memory optimization requires that the class \c ArrayRef
 * know about all of the classes that have pointers to its data.  This
 * is somewhat dangerous, since you can run into cases where the many arrays
 * are shared, at which point the sharing mechanism becomes quite cumbersome.
 * However, these cases appear to be rare, and this code reflects the 
 * common usage of this class.  The set_ref_limit() method can be used to set 
 * the maximum number of references allowed in a code.  When this is 
 * exceeded, this code aborts.
 * This method for reference counting incurs some overhead, especially when
 * arrays are added or deleted, and when arrays are resized.  When arrays are
 * fixed but widely shared, the freeze_memory() method can be called.  This 
 * sets up the ArrayRef object such that the array it manages cannot be 
 * modified (e.g. with the set_data() or resize() methods).  Presently, there
 * is no mechanism to 'unfreeze' and array, since frozen arrays are optimized,
 * in part, by eliminating some bookkeeping arrays in the ArrayRef object.
#ifndef __BasicArray_h
#define __BasicArray_h
#ifdef NON_ANSI
#include <iostream.h>
#include <stdlib.h>
#else
#include <iostream>
#include <cstdlib>
#endif
 * \def ArraySanityChecking
 * If the macro ArraySanityChecking=1 then some routine sanity checks will 
 * be performed when accessing vectors.  Sanity checking generally degrades 
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with ArraySanityChecking=0 to 
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(ArraySanityChecking)
#define ArraySanityChecking    1
#endif
template <class T>
class UTILIB_API BasicArray;
/// CLASS DECLARATIONS
#ifdef SWIG
template <class T>
class BasicArray {
#else
template <class T>
class UTILIB_API BasicArray {
#endif
  friend class ArrayRef<T,BasicArray<T> >;
public:
	/// Empty constructor.
  BasicArray()
	{construct(0,(T*)NULL,DataNotOwned);}
	/**
         * Constructor that initializes the length and possibly data.
         * The \a len parameter specifies the length of the array.
         * If the \a d parameter is not null, then this array is
         * assumed to have length \a len.  The initialization of the
         * array then depends upon the value of the \a o parameter. If
         * \a o is \b DataNotOwned (the default), then the data is 
         * copied from \a d.  Otherwise, the internal point is set to
         * \a d and the internal ownership flag is set to \a o.
         */
#ifndef NON_ANSI
  explicit 
#endif
  BasicArray(const size_type mylen, T *d=((T*)0), 
			const EnumDataOwned o=DataNotOwned)
	{construct(mylen,d,o);}
	/// Copy constructor.
  BasicArray(const BasicArray<T>& array)
	{construct(array.size(), array.data(), AcquireOwnership);}
	/// Destructor.
  virtual ~BasicArray()
	{free();}
	/// Returns TRUE if this array shares data with another array.
  int shared_mem() const
	{return (shared != NULL);}
	/// Resizes the array to the given, nonnegative, value.
  virtual int resize(const size_type newl);
	/// Returns the length of the array.
  size_type size() const
	{ return Len; }
	/// Returns the length of the array.  This method is deprecated.
  int len() const
	{return (int)size();}
	/// Returns the internal pointer to the array.
  T* data() const
	{ return Data; }
#ifndef SWIG
	/// A coercion operator, which returns a pointer to the internal array.
  operator T* () const
	{ return Data; }
#endif
	/// Returns the number of references to the internal array.
  int nrefs() const
	{if (shared) return shared->ref; return 0;}
	/**
         * Accesses the i-th element of the array.
         * This method gives \c BasicArray's the same look-and-feel as C
         * arrays.  Note that the index for these arrays begins at zero.
	 * This method returns a modifiable data element.
         */
  T & operator[](const int i);
	/// Accesss the i-th element of the array and returns a const.
  const T & operator[](const int i) const;
	/**
         * Accesses the i-th element of the array.
         * This method gives \c BasicArray's the same look-and-feel as C
         * arrays.  Note that the index for these arrays begins at zero.
	 * This method returns a modifiable data element.
         */
  T & operator[](const size_type i);
	/// Accesss the i-th element of the array and returns a const.
  const T & operator[](const size_type i) const;
	/// Copies the \b array object by constructing a new \b BasicArray
  BasicArray<T>& operator=(const BasicArray<T>& array);
	/// Copies the pointer from the \b array object and increments the data's reference counter.
  BasicArray<T>& operator&=(const BasicArray<T>& array);
	/// Copies the pointer from the \b array object and increments the data's reference counter, updating \b array if it is not shared.
  BasicArray<T>& operator&=(BasicArray<T>& array);
	/// Set all elements of the array to \b val.
  BasicArray<T>& operator=(const T& val);
	/// Method to explicitly set the internal data array to a pointer array.
  BasicArray<T>& set_data(const size_type len, T *data,
                                const EnumDataOwned o=DataNotOwned);
	/** 
         * Method to explicitly set the internal data array to share the data 
	 * in a \b BasicArray.
         * The \a start parameter specifies the initial point in the 
         * \c BasicArray, and \a newlen specifies the length of the subvector
         * that the current array object sees.
         */
  BasicArray<T>& set_data(const BasicArray<T>& vec, const size_type start,
                                const size_type newlen);
	/// Calls \b set_data with a default value for \a newlen
  BasicArray<T>& set_data(const BasicArray<T>& vec, const size_type start=0)
		{return set_data(vec,start,vec.size()-start);}
	/// Copy a subvector of a \b BasicArray into the current array.
  BasicArray<T>& set_subvec(const size_type start, const size_type len,
                                const BasicArray<T>& datavec, 
				const size_type offset=0);
#ifndef SWIG
	/// This works like the \b set_data method
  BasicArray<T>& at(const size_type start, const size_type newlen,
				BasicArray<T>* array = (BasicArray<T>*)0) const;
	/// This works like the \b set_data method
  BasicArray<T>& at(const size_type start=0) const
		{return at(start, size()-start);}
#endif
	/// Resize and append an element onto the array
  void append(T& element)
	size_type tmp=Len;
	resize(tmp+1);
	(*this)[tmp] = element;
	/// Resize and append an array onto the array
  void append(BasicArray<T>& vec)
	size_type tmp=Len;
	resize(tmp+vec.size());
	for (size_type i=tmp; i<Len; i++)
	  (*this)[i] = vec[i-tmp];
	/// Set reference counter limit
  static void set_ref_limit(const int num)
	{ ClassRef<BasicArray<T> >::num_refs_limit = num; }
	/// Freeze the array allocation, to facilitate array sharing
  void freeze_memory()
	if (!shared) 
   	   set_shared_data(Data, Len, AcquireOwnership);
	shared->freeze();
protected:
	/// The pointer to this array's data.
  T* Data;
	/// The length of the array in \a Data.
  size_type Len;
	/// Pointer to the structure that maintains the shared pointer.
  ArrayRef<T,BasicArray<T> >* shared;
	/// Method used by constructors to setup the \b BasicArray class.
  virtual void construct(const size_type mylen, T *d, 
				const EnumDataOwned o=DataNotOwned);
	/// Virtual method that is used by numeric arrays to initalize the array
  virtual void initialize(T* /*data*/, const size_type /*start*/, 
					const size_type /*stop*/)
		{}
	/// Method used to delete the internal array class.
  void free();
	/// Method to explicitly set the shared data array to a pointer array.
  void set_shared_data(T *data, const size_type len_,
                                const EnumDataOwned o=DataNotOwned);
/// INLINED METHODS
template <class T>
inline T & BasicArray<T>::operator[](const int idx)
#if (ArraySanityChecking==1)
if ((idx < 0) || ((size_type)idx >= Len))
#endif
return Data[idx];
template <class T>
inline const T & BasicArray<T>::operator[](const int idx) const
#if (ArraySanityChecking==1)
if ((idx < 0) || ((size_type)idx >= Len))
#endif
return Data[idx];
template <class T>
inline T & BasicArray<T>::operator[](const size_type idx)
#if (ArraySanityChecking==1)
if (idx >= Len)
#endif
return Data[idx];
template <class T>
inline const T & BasicArray<T>::operator[](const size_type idx) const
#if (ArraySanityChecking==1)
if (idx >= Len)
#endif
return Data[idx];
/// METHOD DEFINITIONS
template <class T>
void BasicArray<T>::construct(const size_type mylen, T *d, const EnumDataOwned o)
Len = mylen;
if (d == NULL) {
   if (mylen > 0) {
      Data = new T [mylen] ;
      if (Data == 0)
      }
   else
      Data = NULL;
   }
else {
   if (o == AcquireOwnership) {
      if (mylen > 0)  {
         Data = new T [mylen] ;
         if (Data == 0)
         for (size_type i=0; i<mylen; i++) Data[i] = d[i] ;
         }
      }
   else
      Data = d;
   }
if ((d != NULL) && (o != AcquireOwnership))
   set_shared_data(Data,Len,o);
else
   shared=0;
template <class T>
void BasicArray<T>::free()
if (shared)
   shared->release(this);
else if (Len > 0) {
   delete [] Data;
   Data=NULL;
   Len=0;
   }
template <class T>
BasicArray<T>& BasicArray<T>::operator=(const BasicArray<T>& array)
if (this != &array) {
   free();
   construct(array.size(),array.data(),AcquireOwnership);
   }
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::operator=(const T& val)
if (size() == 0)
   return *this;
T *start = Data;
T *end = start + size();
for ( ; start < end ; start++ )
  *start = val;
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::operator&=(const BasicArray<T>& array)
if ((Data != NULL) && (array.Data == Data)) return *this;
if (!array.shared)
free();
shared = array.shared;
shared->acquire(this);
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::operator&=(BasicArray<T>& array)
if ((Data != NULL) && (array.Data == Data)) return *this;
if (!array.shared)
   array.set_shared_data(array.Data, array.Len, AcquireOwnership);
free();
shared = array.shared;
shared->acquire(this);
return *this;
template <class T>
int BasicArray<T>::resize(const size_type newl)
if (newl == Len) return OK;
if (newl == 0) {
   if (shared)
      shared->set_data(0,0,AcquireOwnership);
   else if (Len > 0) {
      delete [] Data;
      Data = 0;
      Len = 0;
      }
   return OK;
   }
T *d;
d = new T [newl];
if (d == 0)
if (Len > 0) {
   T* start = Data;
   for (size_type i=0; i<min(newl,Len); i++,start++)
     d[i] = *start;
   }
if (newl > Len)
   initialize(d,Len,newl);
if (shared)
   shared->set_data(d,newl,AcquireOwnership);
else {
   if (Len > 0) 
      delete [] Data;
   Data = d;
   Len = newl;
   }
return OK;
template <class T>
void BasicArray<T>::set_shared_data(T* data, const size_type len,
						const EnumDataOwned o)
if (!shared) {
   if ((Len > 0) && (data != Data))
      delete [] Data;
   shared = new ArrayRef<T,BasicArray<T> >();
   if (!shared)
   shared->acquire(this);
   }
shared->set_data(data,len,o);
template <class T>
BasicArray<T>& BasicArray<T>::set_data(const size_type len, T * data, 
							const EnumDataOwned o)
if (Data == data) return *this;
set_shared_data(data, len, o);
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::set_data(const BasicArray<T>& array, 
						const size_type start,
                                                const size_type newlen)
if (array.Data == Data)                      // Return unmodified array when
   return *this;                             // you are setting yourself.
if (array.Data)
   set_shared_data( &(array.Data[start]), newlen, DataNotOwned);
else
   resize(0);
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::set_subvec(const size_type start, 
			const size_type len,
                        const BasicArray<T>& array, const size_type offset)
T* begin = Data + start;
T* newdata = array.Data + offset;
for (size_type i=0; i<len; i++, begin++, newdata++)
  *begin = *newdata;
return *this;
template <class T>
BasicArray<T>& BasicArray<T>::at(const size_type start, const size_type newlen,
                                BasicArray<T>* array ) const
BasicArray<T> *tmp;
if (array == NULL) {
   tmp = new BasicArray<T>();
   if (tmp == 0)
   }
else
   tmp = array;
tmp->set_data((*this), start, newlen);
return *tmp;
#define BasicArray_DEFN
// Copies an array without memory allocation.
template <class T, class V>
BasicArray<T>& operator<<(BasicArray<T>& x, const BasicArray<V>& y)
if (((void*)(x.data())) == ((void*)(y.data())))
   return x;
if (x.size() != y.size())
			x.size(), y.size()));
size_type len = x.size();
for (size_type i=0; i<len; i++)
  x[i] = y[i];
return x;
#endif
// BitArrayBase.h
 * \class BitArrayBase
 * An array of binary values.  The main elements of this
 * array have the same look and feel as a \c SimpleArray object.  However,
 * this class uses a special, compact representation of the data elements,
 * which forces it to be a separate class.  This class does not impose
 * a restriction on the maximum length of the bit array.
 * To minimize the memory impact of these arrays, the reference count is
 * only used when needed.  Specifically, the \c BitArrayRep class is
 * used (1) when a constructor passes data that is not owned by the array
 * or (2) after methods like operator&= and set_data are called, which
 * initiate the use of reference counting.  Thus by default the memory
 * usage of a \c BitArray is two pointers, an integer counter and the
 * memory in the array.
 * Note that this memory optimization requires that the class \c BitArrayRep
 * know about all of the classes that have pointers to its data.  This
 * is somewhat dangerous, since you can run into cases where the many arrays
 * are shared, at which point the sharing mechanism becomes quite cumbersome.
 * However, these cases appear to be rare, and this code reflects the
 * common usage of this class.  The variable BitArrayRep<T>::num_refs_limit
 * can be used to set the maximum number of references allowed in a code.
 * When this is exceeded, this code aborts.
#ifndef __BitArrayBase_h
#define __BitArrayBase_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <math.h>
#else
#include <iostream>
#include <cmath>
using namespace std;
#endif
#ifndef SWIG
// I'm not sure that this would work if BYTESIZE != 8
#define BYTESIZE 8      /* bits per char */
#define BIT(X,i)    	(((X) & (char)(1 << ((i) & (BYTESIZE - 1)))) != 0)
#define SET_BIT(X,i)   	((X) |= (char)(1 << ((i) & (BYTESIZE - 1))))
#define RESET_BIT(X,i)  ((X) &= ~(char)(1 << ((i) & (BYTESIZE - 1))))
/**                                                                              * \def BitArraySanityChecking
 * If the macro BitArraySanityChecking=1 then some routine sanity checks will
 * be performed when accessing vectors.  Sanity checking generally degrades
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with BitArraySanityChecking=0 to
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(BitArraySanityChecking)
#define	BitArraySanityChecking	1
#endif
class UTILIB_API BitArrayBase;
 * \class BitArrayRef
 * The internal class that is used to manage the data for \c BitArrayBase.
class UTILIB_API BitArrayRef : public ArrayRef<char,BitArrayBase> {
public:
	/// The default constructor.
  BitArrayRef() : ArrayRef<char,BitArrayBase>() {array_len=0;}
        /// 
  virtual void copy_data(BitArrayBase* array);
        /// 
  virtual void reset_data(BitArrayBase* array);
	/// Number of bit sets in the \c BitArrayBase array.
  size_type array_len;
	///
  void set_data(char* Data_, size_type Len_, size_type array_len_,
							EnumDataOwned own_)
	if (Len_ > 0)
	   array_len = array_len_;
	else
	   array_len = 0;
	ArrayRef<char,BitArrayBase>::set_data(Data_,Len_, own_);
#endif //SWIG
#ifdef SWIG
class BitArrayBase {
#else
class UTILIB_API BitArrayBase {
#endif
  friend class ArrayRef<char,BitArrayBase>;
  friend class BitArrayRef;
public:
	/// Empty constructor.
  BitArrayBase()
	{construct(0,0,0);}
        /**
         * Constructor that initializes the length and possibly data.
         * The \a len parameter specifies the number of sets of bits.
         * If the \a d parameter is not null, then this array is
         * assumed to have length \a nbytes.  The initialization of the
         * array then depends upon the value of the \a o parameter. If
         * \a o is \b DataNotOwned (the default), then the data is
         * copied from \a d.  Otherwise, the internal point is set to
         * \a d and the internal ownership flag is set to \a o.
         */
#ifndef NON_ANSI
  explicit
#endif
  BitArrayBase(const size_type len, const size_type nbytes=0, char* d=(char*)0, 
			 const EnumDataOwned o=DataNotOwned)
	{construct(len,nbytes,d,o);}
	/// Copy constructor.
  BitArrayBase(const BitArrayBase& array)
	{construct(array.array_len,array.Len, array.Data, AcquireOwnership);}
	/// Destructor.
  virtual ~BitArrayBase()
	{free();}
	/// Returns TRUE if this array shares data with another array
  int shared_mem() const
	{return (shared != NULL);}
	/// Resize the array to support \a num bits.
  int resize(const size_type num);
	/// Returns the length of the array.
  size_type size() const
	{return array_len;}
	/// Returns the length of the array.  This method is deprecated.
  int len() const
	{return (int)size();}
	/// Returns the internal byte-array that contains bit information.
  char* data() const
	{return Data;}
	/// Returns the number of references to the internal array .
  int nrefs() const
	{if (shared) return shared->ref; else return 0;}
	/// Copies the \b array object by constructing a new \b BitArrayBase.
  BitArrayBase& operator=(const BitArrayBase& array);
	/// Copies the pointer from the \b array object and increments the data's reference counter.
  BitArrayBase& operator&=(const BitArrayBase& array);
	/// Copies the pointer from the \b array object and increments the data's reference counter, updating \b array if it is not shared.
  BitArrayBase& operator&=(BitArrayBase& array);
	/// Set all elements equal to \c value.
  BitArrayBase& operator=(const int value);
	/// Copy \c vec into the current array.
  BitArrayBase& operator<<(const BitArrayBase& vec);
        /// Put bit value \a val in the \a ndx-th bit-pair.
  virtual void put(const size_type ndx, const int val) = 0;
	/// Checks to see if the current array equals \b array.
  int operator==(const BitArrayBase& array) const;
	/// Checks to see if the current array does not equal \b array.
  int operator!=(const BitArrayBase& array) const;
	/**
	 * Compares the current array with \b array.
	 * If the current array is longer, then returns 1. If shorter, then
	 * returns -1.  Otherwise, does a pairwise comparison on elements of
	 * both arrays.  If there exists a nonequal pair of elements, then
	 * returns 1 if the current array is greater and -1 otherwise.
	 */
  int compare(const BitArrayBase& array) const;
	/// Perform an element-wise comparison for greater-than
  int operator>(const BitArrayBase&) const;
	/// Perform an element-wise comparison for greater-than-or-equal-to
  int operator>=(const BitArrayBase&) const;
	/**
	 * Write the array to an output stream.
	 * The format for this output is
	 * \verbatim <len> : <bit-1><bit-2>...<bit-n> \endverbatim
	 */
  int write(ostream& output) const;
	/// Read the array from an input stream.
  virtual int read(istream& input) = 0;
	/// Pack the array into a \c PackBuffer class.
  int write(PackBuffer& output) const;
	/// Unpack the array from an \c UnPackBuffer class.
  int read(UnPackBuffer& input);	
protected:
        /// Returns the value of the \a ndx-th bit-pair.
  virtual int operator[](const size_type ndx) const = 0;
	/// The pointer to this array's data.
  char* Data;
	/// The number of bytes allocated in \c Data.
  size_type Len;
	/// The number of elements in the array.
  size_type array_len;
	/// Pointer tothe structure that maintains the shared pointer.
  BitArrayRef* shared;
	/// Method used by constructors to setup the internal array class.
  void construct(const size_type len, const size_type nbytes, 
		char *d, const EnumDataOwned o=DataNotOwned);
	/// Method used to delete the internal array class.
  void free();
        /// Method to explicitly set the shared data array to a pointer array.
  void set_shared_data(char *data, const size_type len_, 
		const size_type array_len_, const EnumDataOwned o=DataNotOwned);
	/// Returns the number of bits in an element in the array.
  virtual int element_size() const = 0;
	/// Initialie the 'end' of an array (e.g. after resizing it).
  void initialize(const size_type curr_array_len, 
			const size_type new_array_len);
#ifndef SWIG
inline void BitArrayRef::copy_data(BitArrayBase* array)
array->array_len = array_len;
ArrayRef<char,BitArrayBase>::copy_data(array);
inline void BitArrayRef::reset_data(BitArrayBase* array)
array->array_len = 0;
ArrayRef<char,BitArrayBase>::copy_data(array);
inline UTILIB_API ostream& operator<<(ostream& output, const BitArrayBase& array)
{ array.write(output); return(output); }
inline UTILIB_API istream& operator>>(istream& input, BitArrayBase& array)
{ array.read(input); return(input); }
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const BitArrayBase& array)
{ array.write(output); return(output); }
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, BitArrayBase& array)
{ array.read(input); return(input); }
#endif
#endif
// BitArray.h
 * \class BitArray
 * An array of binary values.  The main elements of this
 * array have the same look and feel as a \c SimpleArray object.  However,
 * this class uses a special, compact representation of the data elements,
 * which forces it to be a separate class.  This class does not impose
 * a restriction on the maximum length of the bit array.
#ifndef __BitArray_h
#define __BitArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <math.h>
#else
#include <iostream>
#include <cmath>
#endif
#ifndef SWIG
// I'm not sure that this would work if BYTESIZE != 8
#define BYTESIZE 8      /* bits per char */
#define BIT(X,i)    	(((X) & (char)(1 << ((i) & (BYTESIZE - 1)))) != 0)
#define SET_BIT(X,i)   	((X) |= (char)(1 << ((i) & (BYTESIZE - 1))))
#define RESET_BIT(X,i)  ((X) &= ~(char)(1 << ((i) & (BYTESIZE - 1))))
#endif
/**                                                                              * \def BitArraySanityChecking
 * If the macro ArraySanityChecking=1 then some routine sanity checks will
 * be performed when accessing vectors.  Sanity checking generally degrades
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with ArraySanityChecking=0 to
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(BitArraySanityChecking)
#define	BitArraySanityChecking	1
#endif
#ifdef SWIG
class BitArray : public BitArrayBase {
#else
class UTILIB_API BitArray : public BitArrayBase {
#endif
public:
	/// Empty constructor.
  BitArray() : BitArrayBase() {}
	/// Standard constructor.
  BitArray(const size_type len, const size_type nbytes=0, char* d=(char*)0, 
			 const EnumDataOwned o=DataNotOwned)
		{construct(len,
			(nbytes==0 ?  (len+BYTESIZE-1)/(BYTESIZE/element_size()) 
				   : nbytes),
			d,o); }
	/// Copy constructor.
  BitArray(const BitArray& array)
		: BitArrayBase(array) {}
        /// Return ON/OFF value for the \c ndx index.
  int operator()(const size_type ndx) const;
        /// Put value \c val at the \c ndx index.
  void put(const size_type ndx, const int val);
	/// Set the \a ndx-th bit to \c ON
  void set(const size_type ndx);
	/// Set all bits \c ON
  void set();
	/// Set the \a ndx-th bit to \c OFF
  void reset(const size_type ndx);
	/// Set all bits to \c OFF
  void reset();
	/// Flip bit value of the \a ndx-th bit
  void flip(const size_type ndx);
	/// Flip all bits
  void flip();
	/// Returns the number of bits that are set \c ON.
  size_type nbits() const;
	/// Read the array from an input stream.
  int read(istream& input);
	/** Return true (1) if the two BitArrays both have a 1 in at least one
	    bit.  Equivalent to a bitwise AND and then comparing nbits() on 
	    the result to 0, but much more efficient (e.g. can return as soon 
	    as find agreement */
  int shared_one(BitArray& other) const;
protected:
        /// Return ON/OFF value for the \c ndx index.
  int operator[](const size_type ndx) const;
  int element_size() const
		{return 1;}
// Related functions that might be useful
/// Perform a bitwise OR between two arrays
int bitwise_or(BitArray& a1, BitArray& a2, BitArray& result);
/// Perform a bitwise XOR between two arrays
int bitwise_xor(BitArray& a1, BitArray& a2, BitArray& result);
/// Perform a bitwise AND between two arrays
int bitwise_and(BitArray& a1, BitArray& a2, BitArray& result);
inline int BitArray::operator()(const size_type idx) const
#if (BitArraySanityChecking==1)
if (idx >= array_len)
#endif
int ans;
ans = (int) BIT( Data[idx/BYTESIZE] , idx );
return ans;
inline int BitArray::operator[](const size_type idx) const
#if (BitArraySanityChecking==1)
if (idx >= array_len)
#endif
int ans;
ans = (int) BIT( Data[idx/BYTESIZE] , idx );
return ans;
#endif
// CharString.h
 * \class CharString
 * The \c CharString class is derived from the \c SimpleArray<char> class.  
 * However, it manipulates strings that contain a terminating null '\000' at 
 * the end, without requiring the user to explicitly know that this exists.
 * Potential bug:  when a CharString is initialized with a 
 * const char*, the class does not explicitly prohibit the
 * modification of the character array.  This was done to
 * keep all of the basic operations relatively efficient.
#ifndef __CharString_h
#define __CharString_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <string.h>
#include <iostream.h>
#else
#include <cstring>
#include <iostream>
#endif
#ifdef SWIG
class CharString : public SimpleArray<char> {
#else
class UTILIB_API CharString : public SimpleArray<char> {
#endif
public:
	/// Null constructor.
  CharString();
	/**
	 * Constructor that initializes the length and possibly data.
	 * The \a len parameter specifies the length of the array.
	 * If the \a d parameter is not null, then this array is
	 * assumed to have length \a len.  The initialization of the
	 * array then depends upon the value of the \a o parameter. If
	 * \a o is \b DataNotOwned (the default), then the data is
	 * copied from \a d.  Otherwise, the internal point is set to
	 * \a d and the internal ownership flag is set to \a o.
	 */
#ifndef NON_ANSI
  explicit 
#endif
  CharString(const size_type len, char* str=(char*)0, 
		const EnumDataOwned own=DataNotOwned);
	/**
	 * Constructor that initializes the data using the array 
	 * \a str.  The length is determined by computing the length
	 * of \a str, and ownership is handled as above.
	 */
  CharString(char* str, const EnumDataOwned own=DataNotOwned);
	/**
	 * Constructor that initializes the data using the array 
	 * \a str.  The length is determined by computing the length
	 * of \a str, and ownership is handled as above.
	 */
  CharString(const char* str, const EnumDataOwned own=DataNotOwned);
	/// Copy constructor.
  CharString(const CharString& array);
	/// Copy operator=
  CharString& operator=(const CharString& str)
	if (Data != str.Data) {
	   free();
	   construct(str.size(),str.data(),AcquireOwnership);
	   }
	return *this;
        /// Returns the length of the string.
  size_type size() const
        { return Len-1; }
        /// Resizes the string to the given, nonnegative, value.
  int resize(const size_type);
	/// Checks to see if the current array equals \b array.
  int  operator== (const char* array) const;
	/// Checks to see if the current array is not equal to \b array.
  int  operator!= (const char* array) const;
	/// Checks to see if the current array equals \b array.
  int  operator== (char* array) const
		{return operator==((const char*)array);}
	/// Checks to see if the current array is not equal to \b array.
  int  operator!= (char* array) const
		{return operator!=((const char*)array);}
	/// Checks to see if the current array is lexicographically less than \b array.
  int  operator< (const CharString& array) const;
	/// Checks to see if the current array is lexicographically greater than \b array.
  int  operator> (const CharString& array) const;
	/// Appends the string with \a array
  CharString& operator+=(const char* array);
	/// Appends the string with \a array
  CharString& operator+=(char* array)
		{return operator+=((const char*)array);}
	/// Appends the string with a string representation of \a val
  CharString& operator+=(const int val);
	/// Appends the string with a string representation of \a val
  CharString& operator+=(const double val);
	/**
	 * Copy a substring from \a datavec.
	 * The substring beginning at \a offset in \a datavec and 
	 * ending at \a offset + \a len - 1 is copied to the substring
	 * in the current array beginning at \a start.
	 */
  CharString& set_subvec(const size_type start, const size_type len,
                                const CharString& datavec, 
				const size_type offset=0);
	/// Write the string to an output stream.
  int write(ostream& output) const;
        /// Pack the array into a \c PackBuffer class.
  int write(PackBuffer& output) const 
		{return SimpleArray<char>::write(output);}
	/**
	 * Read a string from an input stream.
	 * This method operates like a normal stream operator would.
	 * Whitespace is ignored, and characters are read until a
	 * standard delimiter is read: whitespace, '\\t' or '\\n'.
	 */
  int read(istream& input);
        /// Unpack the string from an \c UnPackBuffer class.
  int read(UnPackBuffer& input);
  friend int compare(const CharString& str1, const CharString& str2);
protected:
	/// Method used by constructors to setup the \b CharString class.
  virtual void construct(const size_type len, char *d, 
					const EnumDataOwned o=DataNotOwned);
long int  aslong(const CharString& str, int& status);
double    asdouble(const CharString& str, int& status);
#endif
// ClassRef.h
 * \class ClassRef
 * A data type that manages the reference counting for unspecified data
 * elements.  This is a rather non-standard form of memory referencing,
 * in which the reference object knows about all of the objects for which
 * it is sharing memory.  This is not a scalable form of reference
 * management.  However, it facilitates the use of reference sharing on
 * an as-needed basis.  Further, it facilitates the fast access of data
 * in the main objects.  See the \c BasicArray class for an example of
 * how this reference sharing is used.
 * The variable ClassRef<V>::num_refs_limit can be used to set the maximum 
 * number of references allowed in a code.  When this is exceeded, this code 
 * aborts.
 * If the flag ClassRef<V>::const_ref is true, then these references are
 * assumed to share a 'constant' array, for which resize operations are not
 * permited.  This value is set by the 'freeze()' method.  Note that there
 * seems to be no reasonable way to 'unfreeze' references, since the 
 * back references are not updated for frozen ClassRef objects.
#ifndef __ClassRef_h
#define __ClassRef_h
#define __math_h_NO_ARRAYS
#undef __math_h_NO_ARRAYS
typedef size_t size_type;
template <class V> 
class ClassRef {
public:
	/// Max number of shared references
  static int num_refs_limit;
	/// The default constructor.
  ClassRef() {own=DataNotOwned; ref=0; ref_ptrs=0; ptrlen=0; const_ref=FALSE;}
	/// Destructor
  virtual ~ClassRef() {if (ref_ptrs) delete [] ref_ptrs;}
 	/// Update the data in the arrays sharing this object.
  void update_refs()
	if (const_ref == TRUE)
	for (int i=0; i<ref; i++)
  	  copy_data(ref_ptrs[i]);
	/// Add a new array to the list of arrays sharing this object
  void acquire(V* array);
	/// Remove an array from the list of arrays sharing this object
  void release(V* array);
	/// Resize the list of reference pointers
  void resize_ref_ptrs(const int);
	/// Copy the class' data to \c array.
  virtual void copy_data(V* array) = 0;
	/// Reset the data in \c array.
  virtual void reset_data(V* array) = 0;
	/// Delete the data in the ArrayRef object
  virtual void delete_data() = 0;
	/// The ownership category.
  EnumDataOwned own;
	/// Number of arrays that are referencing this \b ClassRef instance.
  int ref;
	/// Set a flag to share a fixed data array (e.g. that is not resized).
  void freeze()
	{ const_ref=TRUE; }
	/// If true, references share a 'constant' array
  int const_ref;
protected:
	/// Length of the \a ref_ptrs array.
  int ptrlen;
	/// Array of pointers to array objects that share this object.
  V** ref_ptrs;
template <class V>
int ClassRef<V>::num_refs_limit=32;
template <class V>
void ClassRef<V>::acquire(V* array)
if (const_ref == FALSE) {
   //
   // Ignore num_refs_limit if this is a constant reference
   //
   if (ref == num_refs_limit)
   if (ref == ptrlen)
      resize_ref_ptrs(ptrlen*2+2);
   ref_ptrs[ref++] = array;
   }
copy_data(array);
template <class V>
void ClassRef<V>::release(V* array)
if (const_ref == FALSE) {
   V** tmp = ref_ptrs;
   int i=0;
   for (i=0; i<(ref-1); i++, tmp++)
     if (*tmp == array)  break;
   if (i < (ref-1))
      ref_ptrs[i] = ref_ptrs[--ref];
   else
      ref--;
   if ((ptrlen > 2) && (ref < ptrlen/2))
      resize_ref_ptrs(ref);
   }
else
   ref--;
if (ref == 0) {
   delete_data();
   own = DataNotOwned;
   const_ref=FALSE;
   }
reset_data(array);
template <class V>
void ClassRef<V>::resize_ref_ptrs(const int newlen)
V** tmp = new V* [newlen];
if (ref) {
   for (int i=0; i<min(ref,newlen); i++)
     tmp[i] = ref_ptrs[i];
   delete [] ref_ptrs;
   }
ptrlen = newlen;
ref_ptrs=tmp;
template <class T, class V> 
class ArrayRef : public ClassRef<V> {
public:
	/// The default constructor.
  ArrayRef() {Len=0; Data=0;}
	/// Destructor
  virtual ~ArrayRef() {if (own) delete [] Data;}
	/// Copy the class' data to \c array.
  void copy_data(V* array);
	/// Reset the data in \c array.
  void reset_data(V* array);
	/// Delete the data in the ArrayRef object
  void delete_data()
	{ if (own) delete [] Data; Data=0; }
	/// Set the array data.
  void set_data(T* Data_, size_type Len_, EnumDataOwned own_);
	/// Pointer to an array of T objects.
  T* Data;
	/// Length of the \c Data array.
  size_type Len;
template <class T, class V>
void ArrayRef<T,V>::copy_data(V* array)
array->Data = Data;
array->Len  = Len;
template <class T, class V>
void ArrayRef<T,V>::reset_data(V* array)
array->Data = 0;
array->Len  = 0;
template <class T, class V>
void ArrayRef<T,V>::set_data(T* Data_, size_type Len_, EnumDataOwned own_)
if (const_ref == TRUE)
if (Data && own && (Len > 0))
   delete [] Data;
if (Len_ > 0) {
   Data = Data_;
   own = own_;
   Len = Len_;
   }
else {
   Data=0;
   Len=0;
   own=DataNotOwned;
   }
update_refs();
#endif
 * \file DoubleMatrix.h
#ifndef __DoubleMatrix_h
#define __DoubleMatrix_h
 * \typedef DoubleMatrix
 * Type for Num2DArray<double> classes.
typedef Num2DArray<double> DoubleMatrix;
#endif
 * \file DoubleVector.h
#ifndef __DoubleVector_h
#define __DoubleVector_h
 * \typedef DoubleVector
 * Type for NumArray<double> classes.
typedef NumArray<double> DoubleVector;
#endif
// EnumBitArray.h
 * \class EnumBitArray
 * An array of n-bit values that uses an enumerated datatype. 
 * The main elements of this array have the same look and feel as a 
 * \c SimpleArray object.  However, this class uses a special, compact 
 * representation of the data elements, which forces it to be a separate class.
 * This class does not impose a restriction on the maximum length of the array.
 * Note: this class assumes that
 *	1. the user sets up the static variable seperately, and
 *	2. the enum type is set to integral values, starting from 0
#ifndef __EnumBitArray
#define __EnumBitArray
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <math.h>
#else
#include <iostream>
#include <cmath>
#endif
// I'm not sure that this would work if BYTESIZE != 8
#define BYTESIZE 8      /* bits per char */
 * \def EnumBitArraySanityChecking
 * If the macro ArraySanityChecking=1 then some routine sanity checks will
 * be performed when accessing vectors.  Sanity checking generally degrades
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with ArraySanityChecking=0 to
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(EnumBitArraySanityChecking)
#define	EnumBitArraySanityChecking	1
#endif
template <class T>
class UTILIB_API EnumBitArray : public BitArrayBase {
public:
	/// Empty constructor.
  EnumBitArray() : BitArrayBase() {}
	/// Construct with data provided by the \a d array.
  EnumBitArray(const size_type len, const size_type nbytes=0, char* d=(char*)0, 
			 const EnumDataOwned o=DataNotOwned)
		{construct(len,
                        (nbytes==0 ?  (len+BYTESIZE-1)/(BYTESIZE/element_size())                                
                                   : nbytes), 
                        d,o); }
	/// Copy constructor.
  EnumBitArray(const EnumBitArray& array)
		: BitArrayBase(array) {}
	/// Return the \a ndx element of this array.
  T operator()(const size_type idx) const;
	/// Put the value \a val at the \a ndx index.
  void put(const size_type idx, const T val);
	/// Set all elements of the array to \a value.
  EnumBitArray<T>& operator=(const T value);
	/// 
  int write(ostream& input) const;
	/// 
  int read(istream& input);
protected:
	///
  int operator[](const size_type idx) const;
	///
  void put(const size_type , const int ) {}
        ///
  int element_size() const
                {return enum_count;}
	/// The number of elements in the enumeration type.
  static int   enum_count;
	/// The character labels of the enumeration types.
  static char  enum_labels[];
	/// A list of the enumeration values.
  static T     enum_vals[];
template <class T>
inline int EnumBitArray<T>::operator[](const size_type idx) const
#if (EnumBitArraySanityChecking==1)
if (idx >= array_len)
#endif
unsigned char X = Data[(2*idx)/BYTESIZE];
size_type i = 2*idx;
unsigned char val = (X & (char)(3 << (i & (BYTESIZE - 1))));
val = val >> (i & (BYTESIZE - 1));
return (int)val;
template <class T>
inline T EnumBitArray<T>::operator()(const size_type idx) const
{ return (T) operator[](idx); }
template <class T>
inline void EnumBitArray<T>::put(const size_type idx, const T val)
#if (EnumBitArraySanityChecking==1)
if (idx >= array_len)
#endif
int tval = (int)val;
unsigned char X = Data[(2*idx)/BYTESIZE];
size_type i = 2*idx;
unsigned char qwerty = (3 << (i & (BYTESIZE - 1)));
unsigned char qwertydata = X & qwerty;
X ^= qwertydata;
X |= ((tval & 3) << (i & (BYTESIZE - 1)));
Data[(2*idx)/BYTESIZE] = X;
// This only works for element_size() <= 4 right now...
template <class T>
int EnumBitArray<T>::read(istream& s)
  size_type i;
  char c;
  if (Data) {// size is known
     for (i=0; i<array_len; i++) {
       s.get(c);
       while (s && ((c == ' ') || (c == '\t') || (c == '\n')))
         s.get(c);
       int j;
       for (j=0; j<element_size(); j++)
         if (c == enum_labels[j]) break;
       if (j<element_size())
          put(i,enum_vals[j]);
       else {
	  break;
	  }
       }
     }
  else 			// size and sparseity is not known
  return OK ;
template <class T>
int EnumBitArray<T>::write(ostream& s) const
if (Data) {
   for (size_type i=0; i<array_len; i++)
     s << enum_labels[(int)(operator()(i))];
   }
return OK ;
template <class T>
EnumBitArray<T>& EnumBitArray<T>::operator=(const T val)
BitArrayBase::operator=((int)val);
return *this;
#endif
// Ereal.h
 * \class Ereal
 * Defines an extension of 'real' (e.g. double, float, long doulb)  
 * that can 'assume' all 'real' values, as well as -infinity and +infinity.
#ifndef __Ereal_h
#define __Ereal_h
#include <cmath>
#include <iostream>
#include <cctype>
template <class Type> class Ereal;
template <class Type> Ereal<Type>
operator+ (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator+ (const Ereal<Type>& x, const Type y);
template <class Type> Ereal<Type>
operator+ (const Type x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator- (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator- (const Ereal<Type>& x, const Type y);
template <class Type> Ereal<Type>
operator- (const Type x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator* (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator* (const Ereal<Type>& x, const Type y);
template <class Type> Ereal<Type>
operator* (const Type x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator/ (const Ereal<Type>& x, const Ereal<Type> y);
template <class Type> Ereal<Type>
operator/ (const Ereal<Type>& x, const Type y);
template <class Type> Ereal<Type>
operator/ (const Type x, const Ereal<Type>& y);
template <class Type> Ereal<Type>
operator+ (const Ereal<Type>& x);
template <class Type> Ereal<Type> 
operator- (const Ereal<Type>& num);
template <class Type> bool
operator== (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator== (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator== (const Type x, const Ereal<Type>& y);
template <class Type> bool
operator!= (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator!= (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator!= (const Type x, const Ereal<Type>& y);
template <class Type> bool
operator> (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator> (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator> (const Type x, const Ereal<Type>& y);
template <class Type> bool
operator>= (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator>= (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator>= (const Type x, const Ereal<Type>& y);
template <class Type> bool
operator< (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator< (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator< (const Type x, const Ereal<Type>& y);
template <class Type> bool
operator<= (const Ereal<Type>& x, const Ereal<Type>& y);
template <class Type> bool
operator<= (const Ereal<Type>& x, const Type y);
template <class Type> bool
operator<= (const Type x, const Ereal<Type>& y);
template <class Type>
std::istream& operator>> (std::istream& is, Ereal<Type>& num);
template <class Type>
std::ostream& operator<< (std::ostream& os, const Ereal<Type>& num);
template <class Type>
bool isinf(const Ereal<Type>& num);
template <class Type>
bool isnan(const Ereal<Type>& num);
template <class Type>
bool isind(const Ereal<Type>& num);
template <class Type>
bool finite(const Ereal<Type>& num);
template <class Type>
class Ereal
public:
	///
  Ereal(const Type num=0.0);
	///
  Ereal operator+= (const Ereal<Type>& num)
	plus(val,Finite,num.val,num.Finite,val,Finite);
	return *this;
	///
  Ereal operator-= (const Ereal<Type>&)
	minus(val,Finite,num.val,num.Finite,val,Finite);
	return *this;
	///
  Ereal operator*= (const Ereal<Type>&)
	mult(val,Finite,num.val,num.Finite,val,Finite);
	return *this;
	///
  Ereal operator/= (const Ereal<Type>&)
	div(val,Finite,num.val,num.Finite,val,Finite);
	return *this;
	///
  operator Type () const;
	///
  std::ostream& write(std::ostream& os) const;
	///
  std::istream& read(std::istream& is);
	///
  PackBuffer& write(PackBuffer& os) const;
	///
  UnPackBuffer& read(UnPackBuffer& is);
  friend Ereal<Type> operator+ <> (const Ereal<Type>& x, const Ereal<Type>& y);
  friend Ereal<Type> operator+ <> (const Ereal<Type>& x, const Type y);
  friend Ereal<Type> operator+ <> (const Type x, const Ereal<Type>& y);
  friend Ereal<Type> operator- <> (const Ereal<Type>& x, const Ereal<Type>& y);
  friend Ereal<Type> operator- <> (const Ereal<Type>& x, const Type y);
  friend Ereal<Type> operator- <> (const Type x, const Ereal<Type>& y);
  friend Ereal<Type> operator* <> (const Ereal<Type>& x, const Ereal<Type>& y);
  friend Ereal<Type> operator* <> (const Ereal<Type>& x, const Type y);
  friend Ereal<Type> operator* <> (const Type x, const Ereal<Type>& y);
  friend Ereal<Type> operator/ <> (const Ereal<Type>& x, const Ereal<Type> y);
  friend Ereal<Type> operator/ <> (const Ereal<Type>& x, const Type y);
  friend Ereal<Type> operator/ <> (const Type x, const Ereal<Type>& y);
  friend Ereal<Type> operator+ <> (const Ereal<Type>& x);
  friend Ereal<Type> operator- <> (const Ereal<Type>& num);
  friend bool operator== <> (const Type x, const Ereal<Type>& y);
  friend bool operator== <> (const Ereal<Type>&, const Ereal<Type>&);
  friend bool operator== <> (const Ereal<Type>&, const Type);
  friend bool operator< <> (const Ereal<Type>&, const Ereal<Type>&);
  friend bool operator< <> (const Ereal<Type>&, const Type);
  friend bool operator< <> (const Type x, const Ereal<Type>& y);
  friend bool operator<= <> (const Ereal<Type>&, const Ereal<Type>&);
  friend bool operator<= <> (const Ereal<Type>&, const Type);
  friend bool operator<= <> (const Type x, const Ereal<Type>& y);
  friend std::istream& operator>> <> (std::istream& is, Ereal<Type>& num);
  friend std::ostream& operator<< <> (std::ostream& os, const Ereal<Type>& num);
  friend bool isinf<> (const Ereal<Type>& num);
  friend bool isnan<> (const Ereal<Type>& num);
  friend bool isind<> (const Ereal<Type>& num);
  friend bool finite<> (const Ereal<Type>& num);
  static Ereal<Type> positive_infinity;
  static Ereal<Type> negative_infinity;
protected:
	///
  Ereal(const Type num, const bool f_flag) : val(num), Finite(f_flag) {}
	///
  Type val;
	///
  bool Finite;
	///
  static void plus(const Type xval, const bool xFinite, 
		const Type yval, const bool yFinite, 
		Type& rval, bool& rFinite);
	///
  static void minus(const Type xval, const bool xFinite, 
		const Type yval, const bool yFinite, 
		Type& rval, bool& rFinite);
	///
  static void mult(const Type xval, const bool xFinite, 
		const Type yval, const bool yFinite, 
		Type& rval, bool& rFinite);
	///
  static void div(const Type xval, const bool xFinite, 
		const Type yval, const bool yFinite, 
		Type& rval, bool& rFinite);
	///
  static void check_if_infinite(Type& val, bool& Finite);
	///
  static Type positive_infinity_val;
	///
  static Type negative_infinity_val;
template <class Type>
Ereal<Type> Ereal<Type>::positive_infinity(1.0,false);
template <class Type>
Ereal<Type> Ereal<Type>::negative_infinity(-1.0,false);
template <class Type>
inline void Ereal<Type>::check_if_infinite(Type& val, bool& Finite)
if (Finite) {
   if (val <= negative_infinity_val) {
      Finite = false;
      val = -1.0;
      }
   else if (val >= positive_infinity_val) {
      Finite = false;
      val = 1.0;
      }
   }
template <class Type>
inline Ereal<Type>::Ereal(const Type num)
val = num;
Finite = true;
check_if_infinite(val,Finite);
template <class Type>
inline Ereal<Type>::operator Type () const
if (Finite) 
   return val;
if (val == -1.0)
   return negative_infinity_val;
else if (val == 1.0)
   return positive_infinity_val;
else if (val == 2.0)
   return 0.0;			// TODO: exception - NaN
else 
   return 0.0;			// TODO: exception - NaN
template <class Type> 
inline void Ereal<Type>::plus(const Type xval, const bool xFinite, 
			const Type yval, const bool yFinite, 
			Type& rval, bool& rFinite)
if (xFinite) {
   if (yFinite) {
      rval = xval + yval;
      rFinite = true;
      check_if_infinite(rval,rFinite);
      }
   else {
      rFinite = false;
      rval = yval;
      }
   }
else {
   rFinite = false;
   if (!yFinite) {
      if ((xval == 2.0) || (yval == 2.0))
         rval = 2.0;				// NaN
      else if (xval*yval == 0.0)
         rval = 0.0;				// Indeterminate
      else if (xval*yval == -1.0)
         rval = 0.0;				// Indeterminate: infty - infty
      else
	 rval = xval;
      }
   else
      rval = xval;
   }
template <class Type> 
inline void Ereal<Type>::minus(const Type xval, const bool xFinite, 
			const Type yval, const bool yFinite, 
			Type& rval, bool& rFinite)
if (xFinite) {
   if (yFinite) {
      rval = xval - yval;
      rFinite = true;
      check_if_infinite(rval,rFinite);
      }
   else {
      rFinite = false;
      if (yval == 2.0)
         rval = 2.0;
      else
         rval = - yval;
      }
   }
else {
   rFinite = false;
   if (!yFinite) {
      if ((xval == 2.0) || (yval == 2.0))
         rval = 2.0;				// NaN
      else if (xval*yval == 0.0)
         rval = 0.0;				// Indeterminate
      else if (xval*yval == 1.0)
         rval = 0.0;				// Indeterminate: infty - infty
      else
	 rval = xval;
      }
   else
      rval = xval;
   }
template <class Type> 
inline void Ereal<Type>::mult(const Type xval, const bool xFinite, 
			const Type yval, const bool yFinite, 
			Type& rval, bool& rFinite)
if (xFinite) {
   if (yFinite) {
      rval = xval * yval;
      rFinite = true;
      check_if_infinite(rval,rFinite);
      }
   else {
      rFinite = false;
      if (yval == 2.0)
         rval = 2.0;
      else if (xval*yval == 0.0)		// Indeterminate: infty * 0
         rval = 0.0;				//             OR Ind * num
      else if (xval*yval > 0.0)
         rval = 1.0;
      else 
         rval = -1.0;
      }
   }
else {
   rFinite = false;
   if (yFinite) {
      if (xval == 2.0)
         rval = 2.0;
      else if (xval*yval == 0.0)		// Indeterminate: infty * 0
         rval = 0.0;				//             OR Ind * num
      else if (xval*yval > 0.0)
         rval = 1.0;
      else 
         rval = -1.0;
      }
   else {
      if ((xval == 2.0) || (yval == 2.0))
         rval = 2.0;
      else 
	 rval = xval*yval;			// Note: handles cases where
						//   either is Ind.
      }
   }
template <class Type>
inline void Ereal<Type>::div(const Type xval, const bool xFinite, 
		const Type yval, const bool yFinite, 
		Type& rval, bool& rFinite)
if (xFinite) {
   if (yFinite) {
      if (yval == 0.0) {
         rFinite = false;
         if (xval > 0.0)
            rval = 1.0;
	 else if (xval < 0.0)
	    rval = -1.0;
	 else 
	    rval = 0.0;			   // Indeterminate: 0 / 0
         }
      else {
         rFinite = true;
         rval = xval / yval;
         check_if_infinite(rval,rFinite);
         }
      }
   else {
      rval = 0.0;
      rFinite = true;
      }
   }
else {
   rFinite = false;
   if (yFinite) {
      if (yval < 0.0)
         rval = - xval;
      else if (yval == 0.0)
         rval = 0.0;				// Indeterminate: infty / 0
      else
         rval = xval;
      }
   else
      rval = 0.0;				// Indeterminate: 
						//        +/- infty / +/- infty
   }
template <class Type> inline
std::ostream& Ereal<Type>::write(std::ostream& os) const
if (Finite)
   os << val;
else {
   if (val == -1.0)
   else if (val == 1.0)
   else if (val == 2.0)
   else if (val == 0.0)
   else
   }
return os;
template <class Type> inline
std::istream& Ereal<Type>::read(std::istream& is)
char c;
is.get(c);
bool neg_flag=false;
if (c == '-') {
   neg_flag = true;
   is.get(c);
   }
if (isdigit(c)) {
   is.putback(c);
   is >> val;
   if (neg_flag)
      val = -val;
   Finite = true;
   check_if_infinite(val,Finite);
   }
else if (isalpha(c)) {
   is.get(c);
   if (c == 'I') {
      is.get(c);
      is.get(c);
      if (c == 'd') {
         }
      else if (c == 'f') {
         }
      else
      }
   else if (c == 'N') {
      }
   // else generate an exception
   }
return is;
template <class Type> inline
PackBuffer& Ereal<Type>::write(PackBuffer& os) const
{ os << Finite << val;  return os; }
template <class Type> inline
UnPackBuffer& Ereal<Type>::read(UnPackBuffer& is)
{ is >> Finite >> val; return is; }
template <class Type> inline Ereal<Type>
operator+ (const Ereal<Type>& x, const Ereal<Type>& y)
Type val;
bool Finite;
Ereal<Type>::plus(x.val, x.Finite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator+ (const Ereal<Type>& x, const Type y)
Type yval = y;
bool yFinite = true;
Ereal<Type>::check_if_infinite(yval,yFinite);
Type val;
bool Finite;
Ereal<Type>::plus(x.val, x.Finite, yval, yFinite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator+ (const Type x, const Ereal<Type>& y)
Type xval = x;
bool xFinite = true;
Ereal<Type>::check_if_infinite(xval,xFinite);
Type val;
bool Finite;
Ereal<Type>::plus(xval, xFinite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator- (const Ereal<Type>& x, const Ereal<Type>& y)
Type val;
bool Finite;
Ereal<Type>::minus(x.val, x.Finite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator- (const Ereal<Type>& x, const Type y)
Type yval = y;
bool yFinite = true;
Ereal<Type>::check_if_infinite(yval,yFinite);
Type val;
bool Finite;
Ereal<Type>::minus(x.val, x.Finite, yval, yFinite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator- (const Type x, const Ereal<Type>& y)
Type xval = x;
bool xFinite = true;
Ereal<Type>::check_if_infinite(xval,xFinite);
Type val;
bool Finite;
Ereal<Type>::minus(xval, xFinite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator* (const Ereal<Type>& x, const Ereal<Type>& y)
Type val;
bool Finite;
Ereal<Type>::mult(x.val, x.Finite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator* (const Ereal<Type>& x, const Type y)
Type yval = y;
bool yFinite = true;
Ereal<Type>::check_if_infinite(yval,yFinite);
Type val;
bool Finite;
Ereal<Type>::mult(x.val, x.Finite, yval, yFinite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator* (const Type x, const Ereal<Type>& y)
Type xval = x;
bool xFinite = true;
Ereal<Type>::check_if_infinite(xval,xFinite);
Type val;
bool Finite;
Ereal<Type>::mult(xval, xFinite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> Ereal<Type>
operator/ (const Ereal<Type>& x, const Ereal<Type> y)
Type val;
bool Finite;
Ereal<Type>::div(x.val, x.Finite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> Ereal<Type>
operator/ (const Ereal<Type>& x, const Type y)
Type yval = y;
bool yFinite = true;
Ereal<Type>::check_if_infinite(yval,yFinite);
Type val;
bool Finite;
Ereal<Type>::div(x.val, x.Finite, yval, yFinite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> Ereal<Type>
operator/ (const Type x, const Ereal<Type>& y)
Type xval = x;
bool xFinite = true;
Ereal<Type>::check_if_infinite(xval,xFinite);
Type val;
bool Finite;
Ereal<Type>::div(xval, xFinite, y.val, y.Finite, val, Finite);
return Ereal<Type>(val,Finite);
template <class Type> inline Ereal<Type>
operator+ (const Ereal<Type>& x)
{ return x; }
template <class Type> inline 
Ereal<Type> operator- (const Ereal<Type>& num)
if (num.Finite)
   return Ereal<Type>(-num.val, num.Finite);
else if (val == 1.0)
   return Ereal<Type>(-1.0, num.Finite);
else if (val == -1.0)
   return Ereal<Type>(1.0, num.Finite);
else 
   return num;
template <class Type> inline
bool operator== (const Ereal<Type>& x, const Ereal<Type>& y)
if (x.Finite) {
   if (y.Finite)
      return (x.val == y.val);
   else
      return false; 
   }
else {
   if (y.Finite)
      return false;
   else
      return (x.val == y.val);			// Correct?
   }
template <class Type> inline
bool operator== (const Ereal<Type>& x, const Type y)
if (x.Finite)
   return (x.val == y);
return false;
template <class Type> inline
bool operator== (const Type x, const Ereal<Type>& y)
{ return (y == x); }
template <class Type> inline bool
operator!= (const Ereal<Type>& x, const Ereal<Type>& y)
{ return (!(y == x)); }
template <class Type> inline bool
operator!= (const Ereal<Type>& x, const Type y)
{ return (!(y == x)); }
template <class Type> inline bool
operator!= (const Type x, const Ereal<Type>& y)
{ return (y != x); }
template <class Type> inline
bool operator> (const Ereal<Type>& x, const Ereal<Type>& y)
{ return (! (x <= y)); }
template <class Type> inline
bool operator> (const Ereal<Type>& x, const Type y)
{ return (! (x <= y)); }
template <class Type> inline 
bool operator> (const Type x, const Ereal<Type>& y)
{ return (!(x <= y)); }
template <class Type> inline 
bool operator>= (const Ereal<Type>& x, const Ereal<Type>& y)
{ return (!(x < y)); }
template <class Type> inline 
bool operator>= (const Type x, const Ereal<Type>& y)
{ return (!(x < y)); }
template <class Type> inline 
bool operator>= (const Ereal<Type>& x, const Type y)
{ return (!(x < y)); }
template <class Type> inline
bool operator< (const Ereal<Type>& x, const Ereal<Type>& y)
if (x.Finite) {
   if (y.Finite)
      return (x.val < y.val);
   else if (y.val == 1.0)
      return true;
   else if (y.val == -1.0)
      return false; 					// TODO: errors
   return false;					// ERRORS!
   }
else {
   if (y.Finite) {
      if (x.val == 1.0)
         return false;
      else if (x.val == -1.0)
         return true;
      return false;					// TODO: errors
      }
   else {
      if ((x.val == -1.0) && (y.val == 1.0))
         return true;
      return false; 					// TODO: errors
      }
   }
template <class Type> inline
bool operator< (const Ereal<Type>& x, const Type y)
if (x.Finite)
   return (x.val < y);
else {
   if (x.val == 1.0)
      return false;
   else if (x.val == -1.0)
      return true;
   return false;					// TODO: errors
   }
template <class Type> inline bool
operator< (const Type x, const Ereal<Type>& y)
{ return operator>=(y,x); }
template <class Type> inline
bool operator<= (const Ereal<Type>& x, const Ereal<Type>& y)
if (x.Finite) {
   if (y.Finite)
      return (x.val <= y.val);
   else if (y.val == 1.0)
      return true;
   else if (y.val == -1.0)
      return false;
   return false; 					// TODO: errors
   }
else {
   if (y.Finite) {
      if (x.val == 1.0)
         return false;
      else if (x.val == -1.0)
         return true; 
      return false;					// TODO: errors
      }
   else {
      if ((x.val == 1.0) && (y.val == -1.0))
         return false;
      return true; 					// TODO: errors
      }
   }
template <class Type> inline
bool operator<= (const Ereal<Type>& x, const Type y)
if (x.Finite)
   return (x.val <= y);
else {
   if (x.val == 1.0)
      return false;
   else if (x.val == -1.0)
      return true;
   return false;					// TODO: errors
   }
template <class Type> inline bool
operator<= (const Type x, const Ereal<Type>& y)
{ return operator>(y,x); }
template <class Type> inline
std::istream& operator>> (std::istream& is, Ereal<Type>& num)
{ num.read(is); return is; }
template <class Type> inline
std::ostream& operator<< (std::ostream& os, const Ereal<Type>& num)
{ num.write(os); return os; }
template <class Type> inline
UnPackBuffer& operator>> (UnPackBuffer& is, Ereal<Type>& num)
{ return num.read(is); }
template <class Type> inline
PackBuffer& operator<< (PackBuffer& os, const Ereal<Type>& num)
{ return num.write(os); }
template <class Type> inline
bool isinf(const Ereal<Type>& num)
{ return (!num.Finite); }
template <class Type> inline
bool isnan(const Ereal<Type>& num)
{ return (!num.Finite && num.val == 2.0); }
template <class Type> inline
bool isind(const Ereal<Type>& num)
{ return (!num.Finite && num.val == 0.0); }
template <class Type> inline
bool finite(const Ereal<Type>& num)
{ return (num.Finite); }
template<class Type>
Type Ereal<Type>::positive_infinity_val = (Type) 1e16;
template<class Type>
Type Ereal<Type>::negative_infinity_val = (Type) -1e16;
#endif
// GenericHashTable.H
 * \class GenericHashTable
 * A hash table class that uses a general set of classes for keys 
 * values. The \c GenericHashTable class is derived from \c AbstractHashTable,
 * which defines the basic operations of the hash table. The keys
 * are assumed to be classes for which the following operations are
 * defined:
 *	size_type hash(size_type tablesize) const
 *	int compare(KEY* key) const
 *	int write(ostream& os) const
 *	int read(istream& is)
 * \sa SimpleHashTable
#ifndef __GenericHashTable_h
#define __GenericHashTable_h
#ifdef __GNUC__
#pragma interface
#endif
template <class T>
class UTILIB_API GenericHashTable;
 * \class GenericHashTableItem
template <class T>
class GenericHashTableItem 
  friend class AbstractHashTable<GenericHashTableItem<T>,T>;
public:
	/// Write the key to an output stream.
  void write(ostream& os) {Keyptr->write(os);}
	/// Return the key.
  T* key() {return Keyptr;}
	///
  int compare(T* key)
		{return Keyptr->compare(key);}
private:
	/// A pointer to a key object.
  T* Keyptr;
	/// Constructor, which requires a key.
  GenericHashTableItem(T* Key_) : Keyptr(Key_) {}
 * \class GenericHashTable
template <class T>
class GenericHashTable : public AbstractHashTable<GenericHashTableItem<T>,T>
public:
	/// Constructor, which specifies the name for the hash table.
	: AbstractHashTable<GenericHashTableItem<T>,T>(nameBuff) {}
	/// Constructor, which specifies the size and name for the hash table.
	: AbstractHashTable<GenericHashTableItem<T>,T>(init_size, nameBuff) {}
	/// Destructor.
#endif
// GenericHeap.h
 * \class GenericHeap
 * A heap class that uses a general class for the keys/data.
 * The \c GenericHeap class is derived from \c AbstractHeap,
 * which defines the basic operations of the heap.
#ifndef __GenericHeap_h
#define __GenericHeap_h
#ifdef __GNUC__
#pragma interface
#endif
template <class T>
class UTILIB_API GenericHeap;
 * \class GenericHeapItem
 * Extends the \c AbstractHeapItem to include a pointer to a generic key
 * type.  The class definition for the key type must be consistent with the
 * definition of the \c GenericKey class.
template <class T>
class UTILIB_API GenericHeapItem : public AbstractHeapItem
  friend class GenericHeap<T>;
public:
	/// Write the key to an output stream.
  void write(ostream& os) {Key->write(os);}
	/// Return the key.
  T* get_key() {return Key;}
private:
	/// A pointer to a key object.
  const T* Key;
	/// Return the key.
  void* key() {return (void*)Key;}
	/// Constructor, which requires a key.
  GenericHeapItem(const T* Key_) : Key(Key_) {}
template <class T>
class UTILIB_API GenericHeap : public AbstractHeap
public:
	 /// Constructor, which specifies a name for the tree.
       int initSize = defaultSize,
       int quantumChoice = defaultQuantum) 
	: AbstractHeap(nameBuff,initSize,quantumChoice) {}
	/// Destructor.
  ~GenericHeap();
	/**
	 * Find the \c GenericSplayTreeItem with value \a data in the list.
	 * If this data value is not found in the list, this method
	 * returns \c NULL.
	 */
  GenericHeapItem<T>* find( T& key);
	/// Return the top of the heap.
  GenericHeapItem<T>* top()
		{return (GenericHeapItem<T>*) AbstractHeap::top();}
	/// Adds a key to the heap.
  void add(const T& key)
                {insert((const T* )&key);}
	/// Adds a key to the heap and returns the \c GenericHeapItem object in the \a item argument.
  void add(const T& key, GenericHeapItem<T>*& item)
                {item = insert((const T* )&key);}
	/**
	 * Removes a splay tree item with the given key.
	 * The status flag is \c TRUE if the key was found and \c FALSE
	 * otherwise.
	 */
  void remove( T& key, int& status)
                {
		GenericHeapItem<T>* tmp = find(key);
		if (tmp)
		   AbstractHeap::remove(tmp,status);
	        else
		   status = FALSE;
	/**
	 * Removes a splay tree item.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(GenericHeapItem<T>* item, int& status)
                {
                if (!item)
                   status = FALSE;
                else
                   AbstractHeap::remove(item,status);
                }    
	/**
	 * Removes a splay tree item and returns the item's key.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(GenericHeapItem<T>* item, T& key, int& status)
                {
		if (!item)
                   status = FALSE;
		else {
		   key = *(item->Key);
		   AbstractHeap::remove(item,status);
		   }
protected:
	/// Inserts an item into the heap.
  GenericHeapItem<T>* insert(const T* key)
		GenericHeapItem<T>* item = new GenericHeapItem<T>(key);
		AbstractHeap::add(item);
		return item;
	///
  int compare(const void* key1, const void* key2);
	///
  void write_item(ostream& output, AbstractHeapItem* item) const
		{((GenericHeapItem<T>*)item)->Key->write(output);}
	///
  void read_item(istream& is, AbstractHeapItem*& item);
	///
  void deleteElement(const int element);
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, const GenericHeap<T>& heap)
{ heap.write(output); return(output); }
template <class T>
inline UTILIB_API istream& operator>>(istream& input, GenericHeap<T>& heap)
{ heap.read(input); return(input); }
template <class T>
int GenericHeap<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
int tmp=key1->compare(key2);
return tmp*Sense;
template <class T>
GenericHeap<T>::~GenericHeap<T>()
for (int i = size(); i>0; i--)
  deleteElement(i);
template <class T>
void GenericHeap<T>::deleteElement(const int element)
GenericHeapItem<T>* item = (GenericHeapItem<T>*) member(element);
delete item;
// For right now, this is done with a linear search through the
// heap array.  A more efficient method could be designed, but I don't
// expect to use this method much, so...
template <class T>
GenericHeapItem<T>* GenericHeap<T>::find( T& key)
for (int i=1; i<= size(); i++)
  if (*(((GenericHeapItem<T>*)member(i))->Key) == key)
     return (GenericHeapItem<T>*) member(i);
return NULL;
template <class T>
void GenericHeap<T>::read_item(istream& is, AbstractHeapItem*& item)
T* key = new T ();
key->read(is);
item = new GenericHeapItem<T>(key);
}        
#endif
// GenericKey.h
 * \class GenericKey
 * Abstract class for keys that are not based on a standard data type.
#ifndef __GenericKey_h
#define __GenericKey_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif
template <class KEY, class DATA>
class UTILIB_API GenericKey
public:
	/// Return true if \a key equals the current key.
  virtual bool operator==(GenericKey<KEY,DATA>& key) const
		{return (Key == key.Key);}
	///
  virtual bool operator<(GenericKey<KEY,DATA>& key) const
		{return (Key < key.Key);}
	///
  virtual bool operator>(GenericKey<KEY,DATA>& key) const
		{return (Key > key.Key);}
	/**
	 * Compare \a key with the current key, returning a value that is 
	 * consistent with the 
	 * \if GeneratingLaTeX standard comparison semantics (see Section~\ref{compare} \endif
	 */
  virtual int compare(GenericKey<KEY,DATA>* val)
		{return (Key < val->key());}
	/// Write the key to an output stream.
  virtual void write(ostream& os) const
	/// Read the key from an input stream.
  virtual void read(istream& )
		{}
	///
  DATA& data()
		{return Data;}
	///
  KEY&  key()
		{return Key;}
protected:
	///
  KEY Key;
	///
  DATA Data;
template <class KEY, class DATA>
inline ostream& operator<<(ostream& output, GenericKey<KEY,DATA>& key)
{ key.write(output); return(output); }
template <class KEY, class DATA>
inline istream& operator>>(istream& input, GenericKey<KEY,DATA>& key)
{ key.read(input); return(input); }
#endif
// GenericSplayTree.h
 * \class GenericSplayTree
 * A splay tree class that uses a general set of classes for keys and data
 * values. The \c GenericSplayTree class is derived from \c AbstractSplayTree,
 * which defines the basic operations of the splay tree. This
 * instantiation requires both keys and data values, both of which can be
 * defined from a general set of classes.
 * \sa SimpleSplayTree
#ifndef __GenericSplayTree_h
#define __GenericSplayTree_h
#ifdef __GNUC__
#pragma interface
#endif
template <class T>
class UTILIB_API GenericSplayTree;
 * \class GenericSplayTreeItem
 * Extends the \c AbstractSplayTreeItem to include a pointer to a generic key 
 * type.  The class definition for the key type must be consistent with the
 * definition of the \c GenericKey class.
template <class T>
class UTILIB_API GenericSplayTreeItem : public AbstractSplayTreeItem
  friend class GenericSplayTree<T>;
public:
	/// Write the key to an output stream.
  void write(ostream& os) {key_ptr->write(os);}
	/// Return the \c ctr counter.
  int counter() {return ctr;}
	/// Return the key.
  T* key() {return key_ptr;}
private:
	///
  void* Key() {return (void*)key_ptr;}
	/// A pointer to a key object.
  T* key_ptr;
	/// The number of instances of \c Key that have been inserted into this splay tree.
  int ctr;
	/// Constructor, which requires a key.
  GenericSplayTreeItem( T* key_ptr_) : key_ptr(key_ptr_), ctr(0) {}
template <class T>
class UTILIB_API GenericSplayTree : public AbstractSplayTree
public:
	/// Constructor, which specifies a name for the tree.
	: AbstractSplayTree(nameBuff), duplicate_flag(0),
	  check_duplicates_flag(0) {}
	/// Destructor.
  ~GenericSplayTree();
	/**
	 * Find the \c GenericSplayTreeItem with value \a data in the list.
	 * If this data value is not found in the list, this method
	 * returns \c NULL.
	 */ 
  GenericSplayTreeItem<T>* find( const T& key)
		{return (GenericSplayTreeItem<T>*) 
				AbstractSplayTree::find(&key);}
	///
  GenericSplayTreeItem<T>* find_rank(int r) 
		{return (GenericSplayTreeItem<T>*)
				AbstractSplayTree::find_rank(r);}
        ///
  int rank(const T& key)
                {find(key); return AbstractSplayTree::rank();}
	/// Return the top of the splay tree.
  GenericSplayTreeItem<T>* top()
		{return (GenericSplayTreeItem<T>*)AbstractSplayTree::top();}
	/// Returns the value of \c duplicate_flag.
  int& duplicate() {return duplicate_flag;}
	/// Returns the value of \c check_duplicates_flag.
  int& check_duplicates() {return check_duplicates_flag;}
	/// Returns the argument \a key to be the value of the current key.
  void current( T& key)
		{key = *(top()->key_ptr);}
	/// Adds a key to the tree.
  void add( T& key)
                {insert(&key);}
	/// Adds a key to the tree and returns the \c GenericSplayTreeItem object in the \a item argument.
  void add( T& key, GenericSplayTreeItem<T>*& item)
                {item = insert(&key);}
	/**
	 * Removes a splay tree item with the given key.
	 * The status flag is \c TRUE if the key was found and \c FALSE
	 * otherwise.
	 */
  void remove( const T& key, int& status)
                {
		GenericSplayTreeItem<T>* item = find(key);
		if (item)
		   AbstractSplayTree::remove(item,status);
	        else
		   status = FALSE;
	/**
	 * Removes a splay tree item.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(GenericSplayTreeItem<T>* item, int& status)
                {
		if (!item)
		   status = FALSE;
		else
		   AbstractSplayTree::remove(item,status);
	/**
	 * Removes a splay tree item and returns the item's key.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.  
	 */
  void remove(GenericSplayTreeItem<T>* item, T& key, int& status)
                {
		if (!item)
		   status = FALSE;
		else {
		   key = *(item->key_ptr);
		   AbstractSplayTree::remove(item,status);
		   }
	/// Perform a splay operation starting from the root of the tree.
  void splay(const T& key)
                {AbstractSplayTree::splay(&key);}
protected:
	/// TODO
  int duplicate_flag;
	/// TODO
  int check_duplicates_flag;
	/// Deletes an \c AbstractSplayTreeItem (used by the AbstractSplayTree class).
  void delete_item(AbstractSplayTreeItem* item)
		{ delete item; }
	/// Inserts an item into the splay tree.
  GenericSplayTreeItem<T>* insert(T* key);
	///
  int compare(const void* key1, const void* key2);
	///
  void write_item(ostream& os, AbstractSplayTreeItem* item);
	///
  void read_item(istream& is, AbstractSplayTreeItem*& item);
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, GenericSplayTree<T>& tree)
{ tree.write(output); return(output); }
template <class T>
inline UTILIB_API istream& operator>>(istream& input, GenericSplayTree<T>& tree)
{ tree.read(input); return(input); }
template <class T>
GenericSplayTreeItem<T>* GenericSplayTree<T>::insert(T* key)
splay(*key);
GenericSplayTreeItem<T>* tree = (GenericSplayTreeItem<T>*)top();
duplicate_flag = 0;
if (check_duplicates_flag && (tree != NULL)) {
   if (compare(key,tree->key_ptr)==0) {	// it's already there
      tree->ctr++;
      duplicate_flag = 1;
      return tree;
      }
   }
GenericSplayTreeItem<T>* newroot = new GenericSplayTreeItem<T>(key);
if (newroot == NULL) 
AbstractSplayTree::add(newroot);
return newroot;
template <class T>
int GenericSplayTree<T>::compare(const void* key1_, const void* key2_)
if (key1_ == key2_)
   return 0;
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
return key1->compare(key2);
template <class T>
GenericSplayTree<T>::~GenericSplayTree()
for (int i=0; i<counter; i++) {
  GenericSplayTreeItem<T>* item = top();
  int status;
  remove(item,status);
template <class T>
void GenericSplayTree<T>::read_item(istream& is, AbstractSplayTreeItem*& item)
T* key = new T ();
key->read(is);
item = new GenericSplayTreeItem<T>(key);
template <class T>
void GenericSplayTree<T>::write_item(ostream& os, AbstractSplayTreeItem* item)
if (check_duplicates_flag)
((GenericSplayTreeItem<T>*)item)->write(os);
#endif
// hash_fn.h
// Defines commonly used hash functions
#ifndef __hash_fn_h
#define __hash_fn_h
template <class T>
size_type hash_fn(const T& key, size_type table_size)
{return key.hash(table_size);}
// CharString
size_type hash_fn1(const CharString& key, size_type table_size);
size_type hash_fn2(const CharString& key, size_type table_size);
size_type hash_fn3(const CharString& key, size_type table_size);
template<>
inline size_type hash_fn(const CharString& key, size_type table_size)
	{return hash_fn2(key,table_size);}
// int
size_type hash_fn1(const int& key, size_type table_size);
template<>
inline size_type hash_fn(const int& key, size_type table_size)
	{return hash_fn1(key,table_size);}
// BasicArray
template<>
size_type hash_fn(const BasicArray<int>& num, size_type table_size);
#endif
 * \file IntMatrix.h
#ifndef __IntMatrix_h
#define __IntMatrix_h
 * \typedef IntMatrix
 * Type for Num2DArray<int> classes.
typedef Num2DArray<int> IntMatrix;
#endif
 * \file IntVector.h
#ifndef __IntVector_h
#define __IntVector_h
 * \typedef IntVector
 * Type for NumArray<int> classes.
typedef NumArray<int> IntVector;
#endif
// LinkedList.h
 * \class LinkedList
 * A class that defines a doubly-linked list.
 * The design of this class was strongly influenced by
 * This linked list code can be switched between use as a queue, stack or
 * simple linked list by setting different `mode' values.  By default, a
 * \c LinkedList object behaves like a queue.
#ifndef __LinkedList_h
#define __LinkedList_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stdlib.h>
#include <stddef.h>
#include <iostream.h>
#else
#include <cstdlib>
#include <cstddef>
#include <iostream>
#endif
template <class T>
class UTILIB_API LinkedList;
 * \class ListItem
 * A simple container class that is used by \c LinkedList.
 * This code includes the management of a list of unused \c ListItem's,
 * which are used first before new \c ListItem's are constructed.  The
 * user can clear the unused items if that is desirable.
template <class T>
class UTILIB_API ListItem {
  friend class LinkedList<T>;
public:
	/// Construct an item with the given data value.
  ListItem( T& Data_)
		: Data(Data_) {next = prev = 0;}
	/// Return the item's data value.
  T& data() 
		{return Data;}
	/// Return \c TRUE if \a item equals the data value in the current item.
  int operator==(const ListItem<T>& item) 
		{return (Data == item.Data);}
	/// Deletes the list of unused \c ListItem objects.
  static void delete_unused();
protected:
	/// The item's data value.
  T Data;
	/// The next item in the list.
  ListItem *next;
	/// The previous item in the list.
  ListItem *prev;
	/// The pointer to the list of unused \c ListItem objects.
  static ListItem* unused;
	/// Allocates a \c ListItem, taking items off of the \c unused list first.
  void *operator new(size_t);
	/// Deletes a \c ListItem, adding it to the \c unused list.
  void operator delete(void*, size_t);
template <class T>
class UTILIB_API LinkedList
protected:
	/// Defines the different modes that the \c LinkedList can operate
  enum {
	stackLL = 0,	/**< Adds items to the beginning; Removes items from the beginning */
	queueLL = 1	/**< Adds items to the end; Removes items from the beginning */
public:
	/// Empty constructor, which sets up an empty linked list.
  LinkedList()
		{ mode=queueLL; counter++; first = last = 0; Len=0; }  
	/** 
	 * Destructor.
	 * After deleting the list, the destructor deletes the list of
	 * additional unused \c ListItem objects.
	 */
  virtual ~LinkedList();
	/**
	 * Find the \c ListItem with value \a data in the list.
	 * If this data value is not found in the list, this method
	 * returns \c NULL.
	 */
  ListItem<T>* find( T& data);
	/// Returns the head of the linked list.
  ListItem<T>* head() const
		{return first;}
	/// Returns the tail of the linked list.
  ListItem<T>* tail() const
		{return last;}
	/// Returns the next item in the list after \a item.
  ListItem<T>* next(ListItem<T>* item) const
		{return item->next;}
	/// Returns the value of the next item that will be removed.
  T& top()
		if (Len <= 0) {
		   exit(0);
		   }
		if (mode == queueLL) return first->data();
		return last->data();
	/// Adds a list item with data value \a data.
  void add( T& data)
		{ insert(data); }
	/// Adds a list item with data value \a data, and returns the \c ListItem object in the \a item argument.
  void add( T& data, ListItem<T>*& item)
		{ item = insert(data); }
	/**
	 * Insert an item in the list with data value \a data.
	 * If \a item is not null, then the new item is inserted before
	 * \a next.  Otherwise, it is inserted at the end of the list.
	 */
  ListItem<T>* insert( T& data, ListItem<T>* item = (ListItem<T>*)0);
	/// Removes the next list item and returns the data value in \a data.
  void remove( T& data) 
		if (mode==queueLL) 
		   extract(first,data); 
		else
		   extract(last,data);
	/// Removes \a item from the list.
  void remove( ListItem<T>* item) 
		{extract(item);}
	/// Removes \a item from the list and returns the data value in \a data.
  void remove(ListItem<T>* item, T& data) 
		{extract(item,data);}
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  int empty() const;
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  operator int() const
		{return (first == 0 ? FALSE : TRUE);}
	/// Returns the length of the list.
  int size() const 
		{return Len;}
	/// Returns the length of the list. (deprecated)
  int len() const 
		{return Len;}
	/// Sets the add/remove mode to operate a stack.
  void stack_mode()
		{mode = stackLL;}
	/// Sets the add/remove mode to operate a queue (the default).
  void queue_mode()
		{mode = queueLL;}
protected:
	/// The add/remove mode.
  int mode;
	/// Removes an item from the list.
  void extract(ListItem<T>* item);
	/// Removes an item from the list and returns its value in \a data.
  void extract(ListItem<T>* item, T& data)
		{data = item->Data; extract(item);}
	/// The first item in the list.
  ListItem<T> *first;
	/// The last item in the list.
  ListItem<T> *last;
	/// The length of the list.
  int Len;
	/// The number of unused \c ListItem objects.
  static int counter;
template <class T>
inline UTILIB_API LinkedList<T>& operator>>(LinkedList<T>& list, T& data)
{list.remove(data); return list;}
template <class T>
inline UTILIB_API LinkedList<T>& operator<<(LinkedList<T>& list, T& data)
{list.add(data); return list;}
// ListItem methods
template <class T>
ListItem<T> *ListItem<T>::unused = NULL;
template <class T>
void ListItem<T>::delete_unused()
ListItem<T> *curr = unused;
ListItem<T> *next;
while (curr) {
  next = curr->next;
  char* tmp = (char*) curr;
  delete [] tmp;
  curr = next;
unused=NULL;
template <class T>
void* ListItem<T>::operator new(size_t size)
if (!unused)
   return new char[size];
else {
   ListItem<T> *ptr = unused;
   unused = unused->next;
   return ptr;
   }
template <class T>
void ListItem<T>::operator delete(void *p, size_t)
((ListItem<T>*)p)->next = unused;
unused = (ListItem<T>*)p;
// LinkedList methods
template <class T>
int LinkedList<T>::counter=0;
template <class T>
LinkedList<T>::~LinkedList()
while (!empty())
  extract(first);
counter--;
if (!counter)
   ListItem<T>::delete_unused();
template <class T>
int LinkedList<T>::empty() const
return (first == NULL ? TRUE : FALSE) ;
template <class T>
void LinkedList<T>::extract(ListItem<T>* item)
if (empty())
if (item->prev) 
   item->prev->next = item->next;
else
   first = item->next;
if (item->next)
   item->next->prev = item->prev;
else
   last = item->prev;
delete item;
Len--;
template <class T>
ListItem<T>* LinkedList<T>::insert( T& data, ListItem<T>* next)
ListItem<T>* item = new ListItem<T>(data);
if (next) {
   if (next->prev)
      next->prev->next = item;
   else
      first = item;
   item->next = next;
   item->prev = next->prev;
   next->prev = item;
   }
else { 			// appending to end of list 
   if (last) {
      last->next = item;
      item->prev = last;
      last = item;
      }
   else
      first = last = item;
   }
Len++;
return item;
template <class T>
ListItem<T>* LinkedList<T>::find( T& data)
ListItem<T>* curr = first;
while (curr) {
  if (data == curr->data()) break;
  curr = curr->next;
return curr;
#endif
// MixedIntVars.h
 * \class MixedIntVars
 * A class that defines a set of parameters that
 * includes binary, integer and double variables.  This class
 * manages these variables in arrays of bits, ints and doubles.
 * \par
 * This class uses set() and get() methods to manage the values of the
 * variables.  This is more cumbersum than using an operator[] method, but
 * the operator[] method does not work well for binary variables.
#ifndef __MixedIntVars_h
#define __MixedIntVars_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
 * \class MixedIntVarsRep
 * The internal class that is used to manage the data for \c MixedIntVars 
 * objects.
class UTILIB_API MixedIntVarsRep {
  friend class MixedIntVars;
protected:
	/// Constructor, which can be used to specify the number of different groups of variables.
  MixedIntVarsRep(int nBinVars=0, int nIntVars=0, int nDblVars=0) 
	: ref(1), 
	own(AssumeOwnership),
	NumBinaryVars(nBinVars), 
	NumIntegerVars(nIntVars),
	NumVars(nBinVars+nIntVars+nDblVars),
	bitVars(nBinVars), gintVars(nIntVars), doubleVars(nDblVars)
	/// Number of \c MixedIntVars objects that are referencing this instance.
  int ref;
	/// The ownership category.
  EnumDataOwned own;
	/// The number of binary variables.
  int NumBinaryVars;
	/// The total number of integer variables.
  int NumIntegerVars;
	/// The total number of variables.
  int NumVars;
	/// The array used to store the binary variables.
  BitArray bitVars;
	/// The array used to store the general integer variables.
  IntVector gintVars;
	/// The array used to store the real variables.
  DoubleVector doubleVars;
class UTILIB_API MixedIntVars 
public:
	/// Constructor, which can be used to specify the number of different groups of variables.
  MixedIntVars(const int numBits=0, const int numGenInts=0, 
			const int numDoubles=0); 
	/// Destructor.
  virtual ~MixedIntVars()
		{free();}
	/// Resizes the number of binary, integer and real variables.
  void resize(const int numBits, const int numGenInts, const int numDoubles);
	/// Returns the number of references to the \c MixedIntVarsRep class.
  int nrefs() const
	{return (a ? a->ref : 0);}
	/// Returns the total number of integer variables.
  int numIntegerVars() const
		{ return (a ? a->NumIntegerVars : 0); }
	/// Returns the number of binary variables.
  int numBinaryVars() const
		{ return (a ? a->NumBinaryVars : 0); }
	/// Returns the number of general integer variables.
  int numGeneralIntVars() const
		{ return (a ? a->NumIntegerVars - a->NumBinaryVars : 0); }
	/// Returns the number of real variables.
  int numDoubles() const
		{ return (a ? a->NumVars - a->NumIntegerVars : 0); }
	/// Returns the number of all variables.
  int numAllVars() const
		{ return (a ? a->NumVars : 0); }
	/// Sets the value of the \a ndx-th binary variable to \a val.
  void setBit(const int ndx, int val);
	/// Sets the value of the \a ndx-th general integer variable to \a val.
  void setGeneralInt(const int ndx, int val);
	/**
	 * Sets the value of the \a ndx-th integer variable to \a val.
	 * This assumes that binary variables precede general integer
	 * variables.
	 */
  void setInt(const int ndx, int val);
	/// Sets the value of the \a ndx-th real variable to \a val.
  void setDouble(const int ndx, double val);
	/**
	 * Sets the value of the \a ndx-th variable to \a val.
	 * This assumes that binary variables precede general integer
	 * variables, which precede real variables.
	 */
  void set(const int ndx, double val);
	/// Gets the value of the \a ndx-th binary variable.
  int getBit(const int ndx);
	/// Gets the value of the \a ndx-th general integer variable.
  int getGeneralInt(const int ndx);
	/**
	 * Gets the value of the \a ndx-th integer variable.
	 * This assumes that binary variables precede general integer
	 * variables.
	 */
  int getInt(const int ndx);
	/// Gets the value of the \a ndx-th real variable.
  double getDouble(const int ndx);
	/**
	 * Gets the value of the \a ndx-th variable.
	 * This assumes that binary variables precede general integer
	 * variables, which precede real variables.
	 */
  double get(const int ndx);
	/// Copies the \b array object by constructing a new \b MixedIntVarsRep.
  MixedIntVars& operator=(const MixedIntVars& array);
	/// Copies the pointer from the \b array object.
  MixedIntVars& operator&=(const MixedIntVars& array);
	/// Copies the array without memory allocation.
  MixedIntVars& operator<<(const MixedIntVars& array);
	/// Set all binary variables to \b val.
  MixedIntVars& operator=(const char val);
	/// Set all general integer variables to \b val.
  MixedIntVars& operator=(const int val);
	/// Set all real variables to \b val.
  MixedIntVars& operator=(const double val);
	/// Checks to see if the current array equals \b array.
  int operator==(const MixedIntVars& array) const;
	/**
	 * Compares \a array with the current variables.
	 * Compares the binary, integer and then real variable arrays.
	 * If all are equal, then returns 0.  Otherwise, when one is
	 * non-zero, return that comparison.
	 */
  int compare(const MixedIntVars& array) const;
	/// Write the array to an output stream.
  int write(ostream& os) const;
	/// Read the array from an input stream.
  int read(istream& is);
	/// Pack the array into a \c PackBuffer class.
  int write(PackBuffer& os) const;
	/// Unpack the array from a \c UnPackBuffer class.
  int read(UnPackBuffer& is);
protected:
	/// The pointer to the internal array representation.
  MixedIntVarsRep* a;
	/// Method used by constructors to setup the \c MixedIntVars class.
  void construct(const int nbits, const int nints, const int ndlbs);
	/// Method used to delete the internal array classes.
  void free();
inline UTILIB_API PackBuffer& operator<< (PackBuffer& buff, 
						const MixedIntVars& vars)
        { vars.write(buff); return buff; }
inline UTILIB_API UnPackBuffer& operator>> (UnPackBuffer& buff, 
						MixedIntVars& vars)
        { vars.read(buff); return buff;}   
inline UTILIB_API ostream& operator<< (ostream& buff, const MixedIntVars& vars)
        { vars.write(buff); return buff; }
inline UTILIB_API istream& operator>> (istream& buff, MixedIntVars& vars)
        { vars.read(buff); return buff;}   
#endif
// MLL.h
#ifndef __MultiLL_h
#define __MultiLL_h
#ifdef __GNUC__
#pragma interface
#endif
//=========================================================================
// MLL.h - Class for static implementation of multiple linked lists
//             within shared data structure 
//=========================================================================
// PRELIMINARY DESCRIPTION:
// This class is meant to provide a single set of structures that supports
// the management of multiple linked lists that are dynamic in length.  
// Housekeeping methods keep the structures from growing too sparse, and 
// users may choose the level of housekeeping enforced in the structures
class UTILIB_API MultiLL
 public:
    MultiLL();
    ~MultiLL();
    // returns 1 if the value sought is found in the 
    // chain referenced, returns 0 otherwise
    int find_value(int type_id,int value);
    // inserts a new value into available slot in
    // the value table and manages chains
    int insert(int type_id, int value,int expiration);
    void remove_index(int type_id, int remove_index);
    // finds value in table, removes, manages chain
    int remove_value(int type_id,int value);
    void show_list(int maxtype);
    int sublist_empty(int type_id);
    void resize();
    void set_up(int number_of_types,int number_of_entries_per);
       /// expires all tabu entries that have expired
    void clean_up(int current_iteration);
 protected:
    int MAXTYPES;
    int MAXTABLESIZE;
    IntVector First;     // holds the index of the first entry 
                         // in table for each type 
    IntVector Last;      // holds the index of the first entry 
                         // in table for each type
    // provide doubly linked chaining                
    IntVector Next; 
    IntVector Prev;
    IntVector table;     // represents the table of entries
    IntVector timestamp; // holds expiration for each local tabu table entry
    IntVector Reserved; // 0/1 for whether a table slot is reserved
                        // for the next entry of some type
    // returns the table index of the earliest free spot in table
    int next_free();
    // contains a value in a chain.
    IntVector Value_Table; 
    // time Value entry made
    IntVector TimeStamp; 
#endif
// Num2DArray.h
 * \class Num2DArray
 * A 2D array data type for numerical data.  \c Num2DArray extends the
 * definition of \c Simple2DArray to include numerical array operations.
#ifndef __Num2DArray_h
#define __Num2DArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <math.h>
#else
#include <cmath>
#endif
template <class T>
class UTILIB_API Num2DArray;
template <class T>
Num2DArray<T> operator%    (const Num2DArray<T> & m1, const Num2DArray<T> & m2)
static Num2DArray<T> temp_mat(m1.nrows(), m2.ncols());
matmult(temp_mat, m1, m2);
return temp_mat;
template <class T>
NumArray<T> operator%    (const Num2DArray<T> & m, const NumArray<T> & v)
static NumArray<T> temp_vec(m.nrows());
matmult(temp_vec, m, v);
return temp_vec;
template <class T>
NumArray<T> operator%    (const NumArray<T> & v, const Num2DArray<T> & m)
static NumArray<T> temp_vec(m.ncols());
matmult(temp_vec,v,m);
return temp_vec;
template <class T>
void matmult(Num2DArray<T>& res, const Num2DArray<T> & m1, 
					const Num2DArray<T> & m2)
if (m1.ncols() != m2.nrows())
						m2.nrows()) );
if ((res.nrows() != m1.nrows()) || (res.ncols() != m2.ncols()))
T temp;
size_type M1Ncols = m1.ncols();
size_type M1Nrows = m1.nrows();
size_type M2Ncols = m2.ncols();
for (size_type i=0; i<M1Nrows; i++){
  for (size_type j=0; j<M2Ncols; j++){
    temp = m1[i][0] * m2[0][j];
    for (size_type k=1; k<M1Ncols; k++){
      temp += m1[i][k] * m2[k][j];
      }
    res[i][j] = temp;
    }
template <class T>
void matmult(NumArray<T>& res, const Num2DArray<T>& m, const NumArray<T>& v)
if (m.ncols() != v.size())
if (res.size() != m.nrows())
T temp;
size_type NRows = m.nrows();
size_type NCols = v.size();
for (size_type i=0; i<NRows; i++) {
  temp = m[i][0] * v[0];
  for (size_type j=1; j<NCols; j++)
    temp += m[i][j] * v[j];
  res[i] = temp;
template <class T>
void matmult(NumArray<T>& res, const NumArray<T> & v, const Num2DArray<T> & m)
if (m.nrows() != v.size())
if (res.size() != m.ncols())
T temp;
size_type NRows = v.size();
size_type NCols = m.ncols();
for (size_type i=0; i<NCols; i++) {
  temp = m[0][i] * v[0];
  for (size_type j=1; j<NRows; j++)
    temp += m[j][i] * v[j];
  res[i] = temp;
#ifdef SWIG
template <class T>
class Num2DArray: public Simple2DArray<T>
#else
template <class T>
class UTILIB_API Num2DArray: public Simple2DArray<T>
#endif
public:
	/// Empty constructor.
  Num2DArray()  : Simple2DArray<T>() {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Num2DArray(const BasicArray<T>& array, const int nrows=1,
                const EnumDataOwned own=DataNotOwned)
		: Simple2DArray<T>(array,nrows,own) {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c d object.
	 */
  Num2DArray(const int nrows, const int ncols, T *d=((T*)0),
                const EnumDataOwned own=DataNotOwned)
		: Simple2DArray<T>(nrows,ncols,d,own) {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Num2DArray(const int nrows, const int ncols, const BasicArray<T>& array,
                const EnumDataOwned own=DataNotOwned)
		: Simple2DArray<T>(nrows,ncols,array,own) {}
	/// Copy constructor.
  Num2DArray(const Num2DArray& array)
		: Simple2DArray<T>(array) {}
	/// Copies the \b array object by constructing a new \b Num2DArray
  Num2DArray<T>& operator=(const Num2DArray<T>& array)
                {Simple2DArray<T>::operator=(array); return *this;}
	/// Set all elements of the array to \b val.
  Num2DArray<T>& operator=(const T& array)
                {Simple2DArray<T>::operator=(array); return *this;}
	/// Sets the array equal to the pair-wise value \a x + \a y
  void plus  (const Num2DArray<T>& x, const Num2DArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x - \a y
  void minus (const Num2DArray<T>& x, const Num2DArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x * \a y
  void times (const Num2DArray<T>& x, const Num2DArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x / \a y
  void divide(const Num2DArray<T>& x, const Num2DArray<T>& y);
	/// Row-wise operations to set i-th row equal to \a x[i] + \a y
  void plus  (const Num2DArray<T>& x, const NumArray<T>& y);
	/// Row-wise operations to set i-th row equal to \a x[i] - \a y
  void minus (const Num2DArray<T>& x, const NumArray<T>& y);
	/// Row-wise operations to set i-th row equal to \a x[i] * \a y
  void times (const Num2DArray<T>& x, const NumArray<T>& y);
	/// Row-wise operations to set i-th row equal to \a x[i] / \a y
  void divide(const Num2DArray<T>& x, const NumArray<T>& y);
	/// Element-wise operations to add the value z
  void plus  (const Num2DArray<T>& x, const T& z);
	/// Element-wise operations to subtract the value z
  void minus (const Num2DArray<T>& x, const T& z);
	/// Element-wise operations to multiply the value z
  void times (const Num2DArray<T>& x, const T& z);
	/// Element-wise operations to divide the value z
  void divide(const Num2DArray<T>& x, const T& z);
	/// Changes the sign of elements in the array.
  Num2DArray<T> operator-    ();
	/// Adds the value of \a x element-wise to the current array.
  Num2DArray<T>& operator+= (const Num2DArray<T>& x);
	/// Subtracts the value of \a x element-wise to the current array.
  Num2DArray<T>& operator-= (const Num2DArray<T>& x);
	/// Multiplies the value of \a x element-wise to the current array.
  Num2DArray<T>& operator*= (const Num2DArray<T>& x);
	/// Divides the value of \a x element-wise to the current array.
  Num2DArray<T>& operator/= (const Num2DArray<T>& x);
	/// Adds \a element-wise to the rows of the current-array
  Num2DArray<T>& operator+=  (const NumArray<T>& y);
	/// Subtracts \a element-wise to the rows of the current-array
  Num2DArray<T>& operator-=  (const NumArray<T>& y);
	/// Multiplies \a element-wise to the rows of the current-array
  Num2DArray<T>& operator*=  (const NumArray<T>& y);
	/// Divides \a element-wise to the rows of the current-array
  Num2DArray<T>& operator/=  (const NumArray<T>& y);
	/// Adds \a z to the elements of the current array
  Num2DArray<T>& operator+=  (const T& z);
	/// Subtracts \a z to the elements of the current array
  Num2DArray<T>& operator-=  (const T& z);
	/// Multiplies \a z to the elements of the current array
  Num2DArray<T>& operator*=  (const T& z);
	/// Divides \a z to the elements of the current array
  Num2DArray<T>& operator/=  (const T& z);
  friend void matmult<T>(Num2DArray<T>& res, const Num2DArray<T>&, 
				const Num2DArray<T>&);
  friend void matmult<T>(NumArray<T>& res, const Num2DArray<T>&, 
				const NumArray<T>&);
  friend void matmult<T>(NumArray<T>& res, const NumArray<T>&, 
				const Num2DArray<T>&);
  friend Num2DArray<T> operator%<T>(const Num2DArray<T> &, const Num2DArray<T> &);
  friend NumArray<T> operator%<T>(const Num2DArray<T> &, const NumArray<T> &);
  friend NumArray<T> operator%<T>(const NumArray<T> &, const Num2DArray<T> &);
#define BINARYOP(opname,pseudonym)\
template <class T>\
inline UTILIB_API Num2DArray<T> opname (const Num2DArray<T>& a1, const Num2DArray<T>& a2)\
Num2DArray<T> res;\
res.pseudonym(a1,a2);\
return res;\
template <class T>\
inline UTILIB_API Num2DArray<T> opname (const Num2DArray<T>& a1, const NumArray<T>& val)\
Num2DArray<T> res;\
res.pseudonym(a1,val);\
return res;\
template <class T>\
inline UTILIB_API Num2DArray<T> opname (const NumArray<T>& val, const Num2DArray<T>& a1)\
Num2DArray<T> res;\
res.pseudonym(a1,val);\
return res;\
template <class T>\
inline UTILIB_API Num2DArray<T> opname (const Num2DArray<T>& a1, const T& val)\
Num2DArray<T> res;\
res.pseudonym(a1,val);\
return res;\
template <class T>\
inline UTILIB_API Num2DArray<T> opname (const T& val, const Num2DArray<T>& a1)\
Num2DArray<T> res;\
res.pseudonym(a1,val);\
return res;\
BINARYOP( operator+ , plus )
BINARYOP( operator- , minus )
BINARYOP( operator* , times )
BINARYOP( operator/ , divide )
#undef BINARYOP
#define BINARYOP(opname,op1,pseudonym, op)\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const Num2DArray<T>& a2)\
if ((a1.nrows() != a2.nrows()) || (a1.ncols() != a2.ncols()))\
resize(a1.nrows(),a2.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op a2[i][j];\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const NumArray<T>& array)\
if (a1.ncols() != array.size())\
resize(a1.nrows(),a1.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op array[j];\
template <class T>\
void Num2DArray<T>::pseudonym(const Num2DArray<T>& a1, const T& val)\
resize(a1.nrows(),a1.ncols());\
for (size_type i=0; i<a->Nrows; i++)\
  for (size_type j=0; j<a->Ncols; j++)\
    a->Data[i][j] = a1[i][j] op val;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const Num2DArray<T>& a1)\
if ((nrows() != a1.nrows()) || (ncols() != a1.ncols()))\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 a1.a->Data[i][j];\
return *this;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const NumArray<T>& a1)\
if (ncols() != a1.size())\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 a1.data()[j];\
return *this;\
template <class T>\
Num2DArray<T>& Num2DArray<T>::opname(const T& val)\
for (size_type i=0; i<nrows(); i++)\
  for (size_type j=0; j<ncols(); j++)\
    a->Data[i][j] op1 val;\
return *this;\
BINARYOP(operator+=,+=,plus, + )
BINARYOP(operator-=,-=,minus, - )
BINARYOP(operator*=,*=,times, * )
BINARYOP(operator/=,/=,divide, / )
#undef BINARYOP
template <class T>
Num2DArray<T> Num2DArray<T>::operator-    ()
Num2DArray<T> res;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    res.a->Data[i][j] = - a->Data[i][j];
return res;
#endif
// NumArray.h
 * \class NumArray
 * An array data type for numerical data.  \c NumArray extends the 
 * definition of \c SimpleArray to include numerical vector operations.
#ifndef __NumArray_h
#define __NumArray_h
#ifdef NON_ANSI
#include <math.h>
#else
#include <cmath>
#endif
#ifndef SWIG
template <class T>
class UTILIB_API NumArray;
template <class T>
class UTILIB_API Num2DArray;
#endif // SWIG
#ifdef SWIG
template <class T>
class NumArray: public SimpleArray<T> {
#else
template <class T>
class UTILIB_API NumArray: public SimpleArray<T> {
#endif
  friend Num2DArray<T>;
public:
	/// Empty constructor.
  NumArray() : SimpleArray<T>() {}
        /**
	 * Constructor that initializes the length and possibly data.
	 * The \a len parameter specifies the length of the array.
	 * If the \a d parameter is null, then the array is initialized to
	 * have a zero value. Otherwise, this array is
	 * assumed to have length \a len.  The initialization of the
	 * array then depends upon the value of the \a o parameter. If
	 * \a o is \b DataNotOwned (the default), then the data is
	 * copied from \a d.  Otherwise, the internal point is set to
	 * \a d and the internal ownership flag is set to \a o.
	 */
#ifndef NON_ANSI
  explicit 
#endif
  NumArray(const size_type len, T *d=((T*)0), const EnumDataOwned o=DataNotOwned)
                : SimpleArray<T>(len,d,o)
		{if (d == NULL) initialize(Data,0,len);}
	/// Copy constructor.
  NumArray(const NumArray& array)
                : SimpleArray<T>(array) {}
	/// Default destructor.
  ~NumArray() {}
	/// Copies the \b array object by constructing a new \b NumArray
  NumArray<T>& operator=(const NumArray<T>& array)
                {SimpleArray<T>::operator=(array); return *this;}
	/// Set all elements of the array to \b val.
  NumArray<T>& operator=(const T& array)
                {SimpleArray<T>::operator=(array); return *this;}
	/// Sets the array equal to the pair-wise value \a x + \a y.
  void plus  (const NumArray<T>& x, const NumArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x - \a y.
  void minus (const NumArray<T>& x, const NumArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x * \a y.
  void times (const NumArray<T>& x, const NumArray<T>& y);
	/// Sets the array equal to the pair-wise value \a x / \a y.
  void divide(const NumArray<T>& x, const NumArray<T>& y);
	/// Sets the array equal to the value \a x[i] + z.
  void plus  (const NumArray<T>& x, const T& z);
	/// Sets the array equal to the value \a x[i] - z.
  void minus (const NumArray<T>& x, const T& z);
	/// Sets the array equal to the value \a x[i] * z.
  void times (const NumArray<T>& x, const T& z);
	/// Sets the array equal to the value \a x[i] / z.
  void divide(const NumArray<T>& x, const T& z);
	/// Changes the sign of elements in the array
  NumArray<T> operator-    ();
	/// Adds the values of \a x elementwise to the current array.
  NumArray<T>& operator+= (const NumArray<T>& x);
	/// Subtracts the values of \a x elementw to the current array.ise
  NumArray<T>& operator-= (const NumArray<T>& x);
	/// Multiplies the values of \a x elementwise to the current array.
  NumArray<T>& operator*= (const NumArray<T>& x);
	/// Divides the values of \a x elementwise to the current array.
  NumArray<T>& operator/= (const NumArray<T>& x);
	/// Adds \a z to the elements of the current array.
  NumArray<T>& operator+=  (const T& z);
	/// Subtracts \a z to the elements of the current array.
  NumArray<T>& operator-=  (const T& z);
	/// Multiplies \a z to the elements of the current array.
  NumArray<T>& operator*=  (const T& z);
	/// Divides \a z to the elements of the current array.
  NumArray<T>& operator/=  (const T& z);
protected:
	/// Initializes the array to zero from \a start to \a stop.
  void initialize(T* data, const size_type start, const size_type stop);
#ifndef SWIG
#define BINARYOP(opname,pseudonym)\
template <class T>\
inline UTILIB_API NumArray<T> opname (const NumArray<T>& a1, const NumArray<T>& a2)\
NumArray<T> res;\
res.pseudonym(a1,a2);\
return res;\
template <class T>\
inline UTILIB_API NumArray<T> opname (const NumArray<T>& a1, const T& val)\
NumArray<T> res;\
res.pseudonym(a1,val);\
return res;\
template <class T>\
inline UTILIB_API NumArray<T> opname (const T& val, const NumArray<T>& a1)\
NumArray<T> res;\
res.pseudonym(a1,val);\
return res;\
BINARYOP( operator+ , plus )
BINARYOP( operator- , minus )
BINARYOP( operator* , times )
BINARYOP( operator/ , divide )
#undef BINARYOP
#endif // SWIG
template <class T>
T NumArray<T>::operator%(const NumArray<T>& a1, const NumArray<T>& a2)
T cum;
T *ptr1, *ptr2;
ptr1 = a1.a->Data;
ptr2 = a2.a->Data;
cum = *ptr1 * *ptr2;
ptr1++; ptr2++;
for (size_type i=1; i<a1.a->len; i++, ptr1++, ptr2++)
  cum += *ptr1 * *ptr2;
return cum;
#define BINARYOP(opname,op1,pseudonym, op)\
template <class T>\
void NumArray<T>::pseudonym(const NumArray<T>& a1, const NumArray<T>& a2)\
if (a1.size() != a2.size())\
resize(a1.size());\
T* tmp = Data;\
size_type mylen = size();\
for (size_type i=0; i<mylen; i++)\
  tmp[i] = a1[i] op a2[i];\
template <class T>\
void NumArray<T>::pseudonym(const NumArray<T>& a1, const T& val)\
resize(a1.size());\
T* tmp = Data;\
size_type mylen = size();\
for (size_type i=0; i<mylen; i++)\
  tmp[i] = a1[i] op val;\
template <class T>\
NumArray<T>& NumArray<T>::opname(const T& val)\
T* tmp = Data;\
size_type mylen = size();\
for (size_type i=0; i<mylen; i++) \
  tmp[i] op1 val;\
return(*this); \
template <class T>\
NumArray<T>& NumArray<T>::opname(const NumArray<T>& array)\
T* tmp = Data;\
T* arraytmp = array.Data;\
size_type mylen = size();\
for (size_type i=0; i<mylen; i++) \
  tmp[i] op1 arraytmp[i]; \
return(*this); \
BINARYOP(operator+=,+=,plus, + )
BINARYOP(operator-=,-=,minus, - )
BINARYOP(operator*=,*=,times, * )
BINARYOP(operator/=,/=,divide, / )
#undef BINARYOP
template <class T>
NumArray<T> NumArray<T>::operator-    ()
size_type mylen = size();
NumArray<T> res(mylen);
T* tmp = Data;
T* restmp = res.Data;
for (size_type i=0; i<mylen; i++)
  restmp[i] = - tmp[i];
return res;
template <class T>
void NumArray<T>::initialize(T* data, const size_type start, 
							const size_type stop)
for (size_type i=start; i < stop; i++)
  data[i] = ( T ) 0;
#endif
// OrderedList.h
 * \class OrderedList
 * A data type that defines an ordered doubly linked list.
 * List items are inserted after all other items with equal or lower 
 * values for their order parameter.  Note that OrderedList is not simply a 
 * subclass of LinkedList because we need to maintain a seperate pool of 
 * unused OrderedListItems 
#ifndef __OrderedList_h
#define __OrderedList_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stdlib.h>
#include <stddef.h>
#include <iostream.h>
#else
#include <cstdlib>
#include <cstddef>
#include <iostream>
#endif
template <class T,class V>
class UTILIB_API OrderedList;
 * \class OrderedListItem
 * A simple container class that is used by \c OrderedList.
 * This code includes the management of a list of unused OrderedListItems,
 * which are used first before new OrderedListItems are constructed.  The
 * user can clear the unused list if that is desirable.
template <class T, class V>
class UTILIB_API OrderedListItem {
  friend class OrderedList<T,V>;
public:
	/// Construct an item with a given data value and sort/order key.
  OrderedListItem( T Data_, V Key_) 
	: Data(Data_), Key(Key_) {next = prev = 0;}
	/// Return the item's data value.
  T& data()  {return Data;}
	/// Return the item's key.
  V key() {return Key;}
	/// Return \c TRUE if the key in \a item equals the key in the current item.
  int operator==(const OrderedListItem<T,V>& item) 
	{return (Key == item.Key);}
protected:
	/// The item's data value.
  T Data;
	/// The item's key.
  V Key;
	/// The next item in the list.
  OrderedListItem *next;
	/// The previous item in the list.
  OrderedListItem *prev;
	/// The pointer to the list of unused \c OrderedListItem objects.
  static OrderedListItem* unused;
	/// Deletes the list of unused \c OrderedListItem objects.
  static void delete_unused();
	/// Allocates a \c OrderedListItem, taking items off of the \c unused list first.
  void *operator new(size_t);
	/// Deletes a \c OrderedListItem, adding it to the \c unused list.
  void operator delete(void*, size_t);
template <class T,class V>
class UTILIB_API OrderedList
public:
	/// Empty constructor, which sets up an empty list.
  OrderedList() 
		{ counter++; first = last = 0; Len=0; }
	/// Copy constructor
  OrderedList(const OrderedList<T,V>& list)
		{ counter++; first = last = 0; Len=0; *this = list;}
	/** 
	 * Destructor.
	 * After deleting the list, the destructor deletes the list of
	 * additional unused \c OrderedListItem objects.
	 */
  virtual ~OrderedList();
	/// Copy equals
  OrderedList<T,V>& operator=(const OrderedList<T,V>& list);
	/**
	 * Find the \c OrderedListItem with value \a data in the list.
	 * If this data value is not found in the list, this method
	 * returns \c NULL.
	 */
  OrderedListItem<T,V>* find( V& key);
	/// Returns the head of the ordered list.
  OrderedListItem<T,V>* head() const
                {return first;}
	/// Returns the tail of the ordered list.
  OrderedListItem<T,V>* tail() const
                {return last;}
	/// Returns the next item in the list after \a item.
  OrderedListItem<T,V>* next(OrderedListItem<T,V>* item) const
                {return item->next;}         
	/// Returns the value of the next item that will be removed.
  T& top()
		if (Len == 0) {
		   exit(0);
		   }
		return first->data();
	/// Adds a list item.
  void add( T& data, V& key)
		{insert(data,key);}
	/// Adds a list item and returns the \c OrderedListItem object in the \a item argument.
  void add( T& data, V& key, OrderedListItem<T,V>*& item ) 
		{item = insert(data,key);}
	/// Removes the first item in the ordered list, returning the values \a data and \a key.
  void remove( T& data, V& key)
		{extract(first,data,key);}
	/// Removes \a item from the list
  void remove(OrderedListItem<T,V>*& item)
		{extract(item);}
	/// Removes \a item from the list, returning the values \a data and \a key.
  void remove(OrderedListItem<T,V>*& item, T& data, V& key)
		{extract(item,data,key);}
	/// Changes the key value for \a item, and repositions it in the list.
  void update(OrderedListItem<T,V>* item, V& key);
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  int empty() const;
	/// Returns \c TRUE if the list is empty and \c FALSE otherwise.
  operator int() const 
		{return (first == 0 ? FALSE : TRUE);}
	/// Returns the length of the list.
  int len() const 
		{return Len;}
protected:
	/// Removes \a item from the linked list after extracting its data and key.
  void extract(OrderedListItem<T,V>* item, T& data, V& key)
		{ data = item->Data; key = item->Key; extract(item); }
	/// Removes \a item from the linked list.
  void extract(OrderedListItem<T,V>* item);
	/// Creates an item in the list from \a data and \a key, and returns the pointer to the \c OrderedListItem.
  OrderedListItem<T,V>* insert( T& data, V& key);
	/// Removes all items from the list
  void extract_all();
	/// The first item in the list.
  OrderedListItem<T,V> *first;
	/// The last item in the list.
  OrderedListItem<T,V> *last;
	/// The length of the list.
  int Len;
	/// The number of unused \c OrderedListItem objects.
  static int counter;
// OrderedListItem methods
template <class T,class V>
OrderedListItem<T,V> *OrderedListItem<T,V>::unused = NULL;
template <class T,class V>
void OrderedListItem<T,V>::delete_unused()
OrderedListItem<T,V> *curr = unused;
OrderedListItem<T,V> *next;
while (curr) {
  next = curr->next;
  char* tmp = (char*) curr;
  delete [] tmp;
  curr = next;
unused = NULL;
template <class T,class V>
void* OrderedListItem<T,V>::operator new(size_t size)
if (!unused)
   return new char[size];
else {
   OrderedListItem<T,V> *ptr = unused;
   unused = unused->next;
   return ptr;
   }
template <class T,class V>
void OrderedListItem<T,V>::operator delete(void *p, size_t)
((OrderedListItem<T,V>*)p)->next = unused;
unused = (OrderedListItem<T,V>*)p;
// OrderedList methods
template <class T,class V>
int OrderedList<T,V>::counter=0;
template <class T,class V>
OrderedList<T,V>::~OrderedList()
extract_all();
counter--;
if (!counter)
   OrderedListItem<T,V>::delete_unused();
template <class T,class V>
void OrderedList<T,V>::extract_all()
while (!empty())
  extract(first);
template <class T, class V>
OrderedList<T,V>& OrderedList<T,V>::operator=(const OrderedList<T,V>& list)
extract_all();
OrderedListItem<T,V>* curr = list.head();
while (curr) {
  T tdata = curr->data();
  V tkey  = curr->key();
  add(tdata,tkey);
  curr = list.next(curr);
return *this;
// This is a stupid way of doing this.  I should simply update the key
// value and move the 'item'.
template <class T,class V>
void OrderedList<T,V>::update(OrderedListItem<T,V>* item, V& key)
insert(item->Data,key);
extract(item);
template <class T,class V>
int OrderedList<T,V>::empty() const
return (first == NULL ? TRUE : FALSE) ;
}      
template <class T,class V>
void OrderedList<T,V>::extract(OrderedListItem<T,V>* item)
if (empty()) {
   exit(-1);
   }
if (item->prev) 
   item->prev->next = item->next;
else
   first = item->next;
if (item->next)
   item->next->prev = item->prev;
else
   last = item->prev;
delete item;
Len--;
template <class T,class V>
OrderedListItem<T,V>* OrderedList<T,V>::insert( T& data, V& key)
OrderedListItem<T,V>* item = new OrderedListItem<T,V>(data,key);
OrderedListItem<T,V>* curr = last;
while (curr && (item->Key < curr->Key))
  curr = curr->prev;
if (curr) {
   item->prev = curr;
   if (curr->next)
      curr->next->prev = item;
   else
      last = item;
   item->next = curr->next;
   curr->next = item;
   }
else {			// insert at beginning of list
   item->prev = NULL;
   item->next = first;
   if (first)
      first->prev = item;
   first = item;
   if (!last) 
      last = item;
   }
Len++;
return item;
template <class T,class V>
OrderedListItem<T,V>* OrderedList<T,V>::find( V& key)
OrderedListItem<T,V>* curr = first;
while (curr) {
  if (key == curr->key()) break;
  curr = curr->next;
return curr;
}          
#endif
// OrderedSet.h
 * \class OrderedSet
 * An array-based set.
 * TODO: use a hash table to make the 'index' operation efficient.
#ifndef __OrderedSet_h
#define __OrderedSet_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stddef.h>
#include <iostream.h>
#include <stdlib.h>
#else
#include <iostream>
#include <cstddef>
#include <cstdlib>
#endif
typedef size_type OrderedSetIndex;
////
//// class OrderedSet<T>
////
template <class T>
class UTILIB_API OrderedSet
public:
	/// Empty constructor that sets up an empty set.
  OrderedSet();
	/// Destructor.
  virtual ~OrderedSet() {}
	/// Adds an element to the set.
  virtual int add( const T& val , const int unique=FALSE );
	/// Adds all of the elements from another set.
  virtual void add( const OrderedSet<T>&, const int unique=FALSE );
	/// Removes the first element, and returns the data value in \a data.
  virtual void remove( T& val );
	/// Returns \c TRUE if the set is empty and \c FALSE otherwise.
  int empty() const
		{return (Len == 0);}
	/// Returns \c TRUE if the set is empty and \c FALSE otherwise.
  operator int() const
		{return (Len > 0);}
	/// Returns the number of items in the set.
  size_type len() const
		{return Len;}
	/// Return the first element of the set, updating \c index.
  T& first( OrderedSetIndex& index, int& status);
	/// Return the next element of the set, updating \c index.
  T& next( OrderedSetIndex& index, int& status);
	/// Returns the (zero-based) index of \c val (and -1 if not a member)
  int index(const T& val);
	/// Returns TRUE if val is a member of the set
  int is_member(const T& val)
	{return (index(val) != -1);}
	/// Returns TRUE if set is disjoint from the current set.
  int is_disjoint(const OrderedSet<T>& set);
        /// Accesss the i-th element of the array and returns a const.
  const T & operator[](const int i) const
		{return Data[i];}
	/// Write out the set to an output stream.
  void write(ostream& os) const;
	/// Read the set from an input stream.
  void read(istream& is);
	/// Write out the set to a pack buffer.
  void write(PackBuffer& os) const;
	/// Read the set from an unpack buffer.
  void read(UnPackBuffer& is);
protected:
	/// The number of items in the set.
  size_type Len;
	/// The array used for storing the set.
  BasicArray<T> Data;
	///
template <class T>
inline UTILIB_API OrderedSet<T>& operator>>(OrderedSet<T>& list, T& val)
{list.remove(val); return list;}
	///
template <class T>
inline UTILIB_API OrderedSet<T>& operator<<(OrderedSet<T>& list, const T& val)
{list.add(val); return list;}
        /// Stream operator for writing
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, const OrderedSet<T>& set)
{ set.write(output); return(output); }
        /// Stream operator for reading
template <class T>
inline UTILIB_API istream& operator>>(istream& input, OrderedSet<T>& set)
{ set.read(input); return(input); }
        /// Stream operator for packing
template <class T>
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const OrderedSet<T>& set)
{ set.write(output); return(output); }
        /// Stream operator for unpacking
template <class T>
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, OrderedSet<T>& set)
{ set.read(input); return(input); }
template <class T>
OrderedSet<T>::OrderedSet()
 : Len(0), Data(1)
// Note: in order to make 'removes' effective, you need to be able to deal with
// 'holes' in the array.  This is messy, and I don't need this capability right
// now!  -- WEH
template <class T>
void OrderedSet<T>::remove( T& Value )
template <class T>
int OrderedSet<T>::add( const T& val, const int add_unique )
int ndx = index(val);
if (add_unique && (ndx != -1))
   return ndx;
if (Data.size() == Len)
   Data.resize(Len + max((Data.size() / 10),(size_type)10));
Data[Len] = val;
Len++;
return(Len-1);
template <class T>
void OrderedSet<T>::add( const OrderedSet<T>& set, const int add_unique )
for (size_type i=0; i<set.Len; i++)
  if (!add_unique || !is_member(set.Data[i]))
     add(set.Data[i]);
template <class T>
int OrderedSet<T>::index(const T& val)
for (size_type i=0; i<Len; i++)
  if (val == Data[i])
     return i;
return -1;
template <class T>
T& OrderedSet<T>::first( OrderedSetIndex& index, int& status)
if (Len == 0) {
   status = FALSE;
   return Data[0];
index = 1;
status=TRUE;
return Data[0];
template <class T>
T& OrderedSet<T>::next( OrderedSetIndex& index, int& status)
if (status == FALSE) return Data[0];
if (index >= Len) {
   status = FALSE;
   return Data[0];
   }
return Data[index++];
template <class T>
int OrderedSet<T>::is_disjoint(const OrderedSet<T>& set)
for (size_type i=0; i<Len; i++)
  for (size_type j=0; j<set.Len; j++)
    if (Data[i] == set.Data[j]) return FALSE;
return TRUE;
template <class T>
void OrderedSet<T>::write(ostream& os) const
if (Len > 0) {
   os << Data[0];
   for (size_type i=1; i<Len; i++)
   }
template <class T>
void OrderedSet<T>::read(istream& /*is*/)
template <class T>
void OrderedSet<T>::write(PackBuffer& os) const
os << Len;
for (size_type i=0; i<Len; i++)
  os << Data[i];
template <class T>
void OrderedSet<T>::read(UnPackBuffer& is)
is >> Len;
if (Data.len() <= Len)
   Data.resize(max(1,Len));
for (size_type i=0; i<Len; i++)
  is >> Data[i];
////
//// Define an iterator macro for ordered sets
////
#define ForAllElements(index,set,elt_type)\
if (set.len() > 0) {\
int index ## __first=TRUE, index ## __status=TRUE;\
OrderedSetIndex index ## __ndx;\
while (index ## __status == TRUE) {\
  const elt_type& index = (index ## __first == TRUE ? set.first(index ## __ndx, index ## __status) : set.next(index ## __ndx, index ## __status));\
  index ## __first = FALSE;\
  if (index ## __status == FALSE) break;
#endif
// QueueArray.h
 * \class QueueArray
 * An array-based queue.
#ifndef __QueueArray_h
#define __QueueArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stddef.h>
#include <iostream.h>
#include <stdlib.h>
#else
#include <iostream>
#include <cstddef>
#include <cstdlib>
#endif
////
//// class QueueArray<T>
////
template <class T>
class UTILIB_API QueueArray
public:
	/// Empty constructor that sets up an empty queue.
  QueueArray();
	/// Destructor.
  virtual ~QueueArray() {}
	/// Returns the value at the top of the queue, which is the next element that will be removed.
  virtual T& top()
		if (Len>0)
		   return Data[First];
		return Data[0];
	/// Adds a list item with data value \a data.
  virtual void add( const T& );
	/// Removes the next item, and returns the data value in \a data.
  virtual void remove( T& val );
	/// Returns \c TRUE if the queue is empty and \c FALSE otherwise.
  int empty() const
		{return (Len == 0);}
	/// Returns \c TRUE if the queue is empty and \c FALSE otherwise.
  operator int() const
		{return (Len > 0);}
	/// Returns the number of items in the queue.
  size_type len() const
		{return Len;}
	/// Empties the QueueArray
  void clear();
        /// Write out the queue to an output stream.
  void write(ostream& os) const;
        /// Read the queue from an input stream.
  void read(istream& is);
        /// Write out the queue from a pack buffer.
  void write(PackBuffer& os) const;
        /// Read the queue from an unpack buffer.
  void read(UnPackBuffer& is);
protected:
	/// The number of items in the queue.
  size_type Len;
	/// The index of the first element in the queue.
  size_type First;
	/// The index of the last element in the queue.
  size_type Last;
	/// The array used for storing the queue.
  BasicArray<T> Data;
	/// The array of next elements in the queue.
  BasicArray<size_t> next;
template <class T>
inline UTILIB_API QueueArray<T>& operator>>(QueueArray<T>& list, T& val)
{list.remove(val); return list;}
template <class T>
inline UTILIB_API QueueArray<T>& operator<<(QueueArray<T>& list, const T& val)
{list.add(val); return list;}
        /// Stream operator for writing
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, const QueueArray<T>& set)
{ set.write(output); return(output); }
        /// Stream operator for reading
template <class T>
inline UTILIB_API istream& operator>>(istream& input, QueueArray<T>& set)
{ set.read(input); return(input); }
        /// Stream operator for packing
template <class T>
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const QueueArray<T>& set)
{ set.write(output); return(output); }
        /// Stream operator for unpacking
template <class T>
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, QueueArray<T>& set){ set.read(input); return(input); }
// Note, we are using internal indeces that are 1-based, indexing into
// zero based arrays.  This is because the smallest value that the 'next'
// array can represent is zero.
template <class T>
QueueArray<T>::QueueArray()
 : Len(0), First(1), Last(1)
{ Data.resize(10); next.resize(10); next[0] = 0;}
template <class T>
void QueueArray<T>::clear()
Len=0;
First = 1;
Last = 1;
next[0] = 0;
template <class T>
void QueueArray<T>::remove( T& Value )
if (Len == 0)
size_type curr = First;
Value = Data[curr];
// Move the First pointer down the list
if (next[curr] == 0) {
   //
   // The 'next' value is empty, so return to initial conditions for
   // code.
   //
   Len=0;
   First = 1;
   Last = 1;
   }
else {
   Len--;
   First = next[curr];
   }
// Setup the 'free list'
size_type tmp = next[0];
next[0] = curr;
next[curr] = tmp;
template <class T>
void QueueArray<T>::add( const T& val )
Len++;
size_type curr;
if (next[0] == 0)
   curr = Len;
else {
   //
   // Remove an element from the free list
   //
   curr = next[0];
   next[0] = next[curr];
   }
if (Data.size() == curr) {
   Data.resize(curr + max((Data.size() / 10),(size_type)10));
   next.resize(curr + max((next.size() / 10),(size_type)10));
   }
if (Len == 1)
   First = curr;
next[curr] = 0;
if (Len > 1)
   next[Last] = curr;
Data[curr] = val;
Last = curr;
template <class T>
void QueueArray<T>::write(ostream& os) const
if (Len > 0) {
   size_type curr = First;
   os << Data[curr];
   for (size_type i=1; i<Len; i++) {
     curr = next[curr] ;
     }
   }
template <class T>
void QueueArray<T>::read(istream& /*is*/)
template <class T>
void QueueArray<T>::write(PackBuffer& os) const
os << Len;
size_type curr = First;
for (size_type i=0; i<Len; i++) {
  os << Data[curr];
  curr = next[curr];
template <class T>
void QueueArray<T>::read(UnPackBuffer& is)
is >> Len;
if (Data.len() <= (Len+1))
   Data.resize(max(1,(Len+1)));
Len=0;
First = 1;
Last = 1;
for (size_type i=0; i<Len; i++) {
  is >> Data[Len];
  add(Data[Len]);
#endif
// QueueList.h
 * \class QueueList
 * A data type that defines a queue using a doubly-linked
 * list data structure.  This class is a simple derivation of 
 * \c LinkedList that sets the the queue mode.
#ifndef __QueueList_h
#define __QueueList_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stddef.h>
#else
#include <cstddef>
#endif
#if !defined(QueueListT)
#ifndef USING_TEMPLATES
#define QueueListT(T) QueueList_##T
#else
#define QueueListT(T) QueueList<##T##>
#endif
#endif
////
//// class QueueList<T>
////
template <class T>
class UTILIB_API QueueList : public LinkedList<T>
public:
	/// Empty constructor
  QueueList() : LinkedList<T>() {mode = queueLL;}
#endif
 * \file RealMatrix.h
 * Depending on the value of REALType, define real matrices as floats or 
 * doubles.  This is not a robust mechanism and I've only used the default 
 * 'double' option.
#ifndef __RealMatrix_h
#define __RealMatrix_h
 * \typedef RealMatrix
 * The matrix class that contains elements of type REAL.
#if REALType == DoubleType
typedef DoubleMatrix RealMatrix ;
#else
typedef FloatMatrix RealMatrix ;
#endif
#endif
 * \file RealVector.h
 * Depending on the value of REALType, define real vectors as floats or doubles.
 * This is not a robust mechanism and I've only used the default 'double' 
 * option.
#ifndef __RealVector_h
#define __RealVector_h
 * \typedef RealVector
 * The vector class that contains elements of type REAL.
#if REALType == DoubleType
typedef DoubleVector RealVector ;
#else
typedef FloatVector RealVector ;
#endif
#endif
// Simple2DArray.h
 * \class Simple2DArray
 * A 2D array data type that manages the allocation and deallocation of memory. 
 * The \c Simple2DArray class extends the \c Basic2DArray class to include
 * I/O operations and comparison methods.
#ifndef __Simple2DArray_h
#define __Simple2DArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <stdlib.h>
#include <assert.h>
#else
#include <iostream>
#include <cstdlib>
#include <cassert>
#endif
#if !defined(Simple2DArrayT)
#ifdef USING_TEMPLATES
#define Simple2DArrayT(T) Simple2DArray<##T##>
#else
#define Simple2DArrayT(T) Simple2DArray_##T
#endif
#endif
#ifdef SWIG
template <class T>
class Simple2DArray : public Basic2DArray<T>
#else
template <class T>
class UTILIB_API Simple2DArray : public Basic2DArray<T>
#endif
public:
	/// Null constructor.
  Simple2DArray()  
		: Basic2DArray<T>() {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Simple2DArray(const BasicArray<T>& array, const size_type nrows=1,
                const EnumDataOwned own=DataNotOwned)
                : Basic2DArray<T>(array,nrows,own) {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c d object.
	 */
  Simple2DArray(const size_type nrows, const size_type ncols, T *d=((T*)0),
                const EnumDataOwned own=DataNotOwned)
                : Basic2DArray<T>(nrows,ncols,d,own) {}
	/**
	 * Constructor that initializes the 2D array using a given array.
	 * The 2D array only constructs the array of pointers, which point
	 * into the data owned by the \c array object.
	 */
  Simple2DArray(const size_type nrows, const size_type ncols, const BasicArray<T>& array,
                const EnumDataOwned own=DataNotOwned)
                : Basic2DArray<T>(nrows,ncols,array,own) {}
	/// Copy constructor.
  Simple2DArray(const Simple2DArray<T>& array)
                : Basic2DArray<T>(array) {}
	/// Copies the \b array object by constructing a new \b Simple2DArray
  Simple2DArray<T>& operator=(const Simple2DArray<T>& array)
		{Basic2DArray<T>::operator=(array); return *this;}
	/// Set all elements of the array to \b val.
  Simple2DArray<T>& operator=(const T& val)
		{Basic2DArray<T>::operator=(val); return *this;}
	/// Checks to see if the current array equals \b array.
  int  operator== (const Simple2DArray<T>& array) const;
	/// Checks to see if the current array does not equal \b array.
  int  operator!= (const Simple2DArray<T>& array) const;
	/**
	 * Compares the current array with \b array.
	 * If the current array is longer, then returns 1. If shorter, then
	 * returns -1.  Otherwise, does a pairwise comparison on elements of
	 * both arrays.  If there exists a nonequal pair of elements, then
	 * returns 1 if the current array is greater and -1 otherwise.
	 */
  int  compare(const Simple2DArray<T>& array) const;
/* BUG!  Let's see where this is used!
  int  operator<(const Simple2DArray<T>& array) const
                {return compare(array);}
	/**
	 * Write the array to the output stream.
	 * The format for this output is
	 * \verbatim <nrows> <ncols> <elt-1,1> <elt-1,2> ... <elt-1,m> ... <elt-n,m> \endverbatim
	 */
  virtual int write(ostream& output) const;       
	/// Read the array from the input stream
  virtual int read(istream& input);              
	/// Pack the array into a \b PackBuffer class
  virtual int write(PackBuffer& output) const;  
	/// Unpack the array from an \b UnPackBuffer class
  virtual int read(UnPackBuffer& input);       
	/// Stream operator for writing
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, const Simple2DArray<T>& array)
{ array.write(output); return(output); }
	/// Stream operator for reading
template <class T>
inline UTILIB_API istream& operator>>(istream& input, Simple2DArray<T>& array)
{ array.read(input); return(input); }
	/// Stream operator for packing
template <class T>
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const Simple2DArray<T>& array)
{ array.write(output); return(output); }
	/// Stream operator for unpacking
template <class T>
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, Simple2DArray<T>& array)
{ array.read(input); return(input); }
template <class T>
int Simple2DArray<T>::compare(const Simple2DArray<T>& array) const
if (array.a == a)
   return 0;
for (size_type i=0; i<min(a->Nrows,array.a->Nrows); i++)
  for (size_type j=0; j<min(a->Ncols,array.a->Nrows); j++)
    if (a->Data[i][j] < array.a->Data[i][j])
       return -1;
    else if (a->Data[i][j] > array.a->Data[i][j])
       return 1;
if ((array.a->Nrows == a->Nrows) && (array.a->Ncols == a->Ncols))
   return 0;
if ((array.a->Nrows < a->Nrows) || (array.a->Nrows < a->Nrows))
   return -1;
return 1;
template <class T>
int Simple2DArray<T>::operator==(const Simple2DArray<T>& array) const
if (array.a == a)
   return 1;
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
   return 0;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    if (a->Data[i][j] != array.a->Data[i][j])
       return 0;
return 1;
template <class T>
int Simple2DArray<T>::operator!=(const Simple2DArray<T>& array) const
if ((array.a->Nrows != a->Nrows) || (array.a->Ncols != a->Ncols))
   return 1;
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    if (a->Data[i][j] != array.a->Data[i][j])
       return 1;
return 0;
template <class T>
int Simple2DArray<T>::write(PackBuffer& os) const
os << a->Nrows << a->Ncols;
if (a->Data) {
   for (size_type i=0; i<a->Nrows; i++)
     for (size_type j=0; j<a->Ncols; j++)
       os << a->Data[i][j];
   }
return OK;
template <class T>
int Simple2DArray<T>::write(ostream& os) const
if (a->Data) {
   for (size_type i=0; i<a->Nrows; i++) {
     for (size_type j=0; j<a->Ncols; j++)
     os << endl;
     }
   }
return OK;
template <class T>
int Simple2DArray<T>::read(UnPackBuffer& is)
size_type nrows,ncols;
is >> nrows >> ncols;
resize(nrows,ncols);
for (size_type i=0; i<a->Nrows; i++)
  for (size_type j=0; j<a->Ncols; j++)
    is >> a->Data[i][j];
return OK;
template <class T>
int Simple2DArray<T>::read(istream& /*is*/)
free();
// TODO
return OK;
#endif
// SimpleArray.h
 * \class SimpleArray
 * An array data type that manages the allocation and
 * deallocation of memory.  The \c SimpleArray class extends the 
 *  BasicArray class to include I/O operations and comparison methods.
#ifndef __SimpleArray_h
#define __SimpleArray_h
#ifdef NON_ANSI
#include <stdlib.h>
#include <assert.h>
#include <iostream.h>
#else
#include <cstdlib>
#include <cassert>
#include <iostream>
using namespace std;
#endif
#ifdef SWIG
template <class T>
class SimpleArray : public BasicArray<T> {
#else
template <class T>
class UTILIB_API SimpleArray : public BasicArray<T> {
#endif
public:
	/// Null constructor.
  SimpleArray() : BasicArray<T>() {}
        /**
         * Constructor that initializes the length and possibly data.
	 * The \a len parameter specifies the length of the array.
	 * If the \a d parameter is not null, then this array is
	 * assumed to have length \a len.  The initialization of the
	 * array then depends upon the value of the \a o parameter. If
	 * \a o is \b DataNotOwned (the default), then the data is
	 * copied from \a d.  Otherwise, the internal point is set to
	 * \a d and the internal ownership flag is set to \a o.
	 */
#ifndef NON_ANSI
  explicit 
#endif
  SimpleArray(const int len, T *d=((T*)0), const EnumDataOwned o=DataNotOwned)
		: BasicArray<T>(len,d,o) {}
	/// Copy constructor.
  SimpleArray(const SimpleArray<T>& array)
		: BasicArray<T>(array) {}
	/// Copies the \b array object by constructing a new \b SimpleArray
  SimpleArray<T>& operator=(const SimpleArray<T>& array)
                {BasicArray<T>::operator=(array); return *this;}
	/// Set all elements of the array to \b val.
  SimpleArray<T>& operator=(const T& val)
                {BasicArray<T>::operator=(val); return *this;}
	/// Destructor
  virtual ~SimpleArray() {}
	/// Checks to see if the entire array equals \b val.
  int  operator==(const T& val) const;
	/// Checks to see if the entire array does not equal \b val.
  int  operator!=(const T& val) const;
	/// Checks to see if the current array equals \b array.
  int  operator==(const SimpleArray<T>& array) const;
	/// Checks to see if the current array does not equal \b array.
  int  operator!=(const SimpleArray<T>& array) const;
	/**
         * Compares the current array with \b array.
	 * If the current array is longer, then returns 1. If shorter, then
         * returns -1.  Otherwise, does a pairwise comparison on elements of
         * both arrays.  If there exists a nonequal pair of elements, then
         * returns 1 if the current array is greater and -1 otherwise.
         */
  int  compare(const SimpleArray<T>& array) const;
/*  BUG!  Let's see where this is used!
  int  operator<(const SimpleArray<T>& array) const
		{return compare(array);}
	/**
	 * Write the array to an output stream.
	 * The format for this output is
	 * \verbatim <len> : <elt-1> ... <elt-n> \endverbatim
	 */
  virtual int write(ostream& os) const;
	/// Read the array from an input stream.
  virtual int read(istream& is);
	/// Pack the array into a \c PackBuffer class.
  virtual int write(PackBuffer& os) const;
	/// Unpack the array from an \c UnPackBuffer class.
  virtual int read(UnPackBuffer& is);
#ifndef SWIG
	/// Stream operator for writing 
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, const SimpleArray<T>& array)
{ array.write(output); return(output); }
	/// Stream operator for reading 
template <class T>
inline UTILIB_API istream& operator>>(istream& input, SimpleArray<T>& array)
{ array.read(input); return(input); }
	/// Stream operator for packing 
template <class T>
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const SimpleArray<T>& array)
{ array.write(output); return(output); }
	/// Stream operator for unpacking 
template <class T>
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, SimpleArray<T>& array)
{ array.read(input); return(input); }
#endif // SWIG
template <class T>
int SimpleArray<T>::operator==(const T& val) const
T* tmp = Data;
size_type mylen = size();
for (size_type i=0; i<mylen; i++)
  if (tmp[i] != val)
     return 0;
return 1;
template <class T>
int SimpleArray<T>::operator!=(const T& val) const
T* tmp = Data;
size_type mylen = size();
for (size_type i=0; i<mylen; i++)
  if (tmp[i] != val)
     return 1;
return 0;
template <class T>
int SimpleArray<T>::operator==(const SimpleArray<T>& array) const
if (array.Data == Data)
   return 1;
if (array.size() != size())
   return 0;
T* tmp = Data;
T* arraytmp = array.Data;
size_type mylen = size();
for (size_type i=0; i<mylen; i++)
  if (tmp[i] != arraytmp[i])
     return 0;
return 1;
template <class T>
int SimpleArray<T>::compare(const SimpleArray<T>& array) const
if (array.Data == Data)
   return 0;
size_type mylen = size();
size_type arraylen = array.size();
if (arraylen > mylen)	
   return 1;
if (arraylen < mylen)	
   return -1;
T* tmp = Data;
T* arraytmp = array.Data;
for (size_type i=0; i<mylen; i++) {
  if (tmp[i] != arraytmp[i]) {
     if (tmp[i] < arraytmp[i]) return -1;
     else return 1;
     }
return 0;
template <class T>
int SimpleArray<T>::operator!=(const SimpleArray<T>& array) const
if (array.Data == Data)
   return 0;
size_type mylen = size();
if (array.size() != mylen)
   return 1;
T* tmp = Data;
T* arraytmp = array.Data;
for (size_type i=0; i<mylen; i++)
  if (tmp[i] != arraytmp[i])
     return 1;
return 0;
template <class T>
inline int SimpleArray<T>::write(PackBuffer& os) const
size_type mylen = size();
os << mylen;
T* tmp = Data;
for (size_type i=0; i<mylen; i++, tmp++)
  os << *tmp;
return OK;
template <class T>
inline int SimpleArray<T>::write(ostream& os) const
size_type mylen = size();
T* tmp = Data;
for (size_type i=0; i<mylen; i++, tmp++)
return OK;
template <class T>
inline int SimpleArray<T>::read(UnPackBuffer& is)
size_type len;
is >> len;
resize(len);
T* tmp = Data;
for (size_type i=0; i<len; i++, tmp++)
  is >> *tmp;
return OK;
template <class T>
inline int SimpleArray<T>::read(istream& is)
size_type len;
is >> len;
resize(len);
char c;
is >> c;
T* tmp = Data;
for (size_type i=0; i<len; i++, tmp++)
  is >> *tmp;
return OK;
#endif
// SimpleHashTable.h
 * \class SimpleHashTable
 * A hash table class that uses standard C/C++ data types for keys.
 * The \c SimpleHashTable class is derived from \c AbstractHashtable, which 
 * defines the basic operations of the hash table.  This particular 
 * instantiation of hash tables uses a simple data type for the key, and
 * no auxillary data is associated with the key.  This greatly simplifies the
 * definition of the hash table, but it assumes that copying the key
 * is relatively inexpensive (e.g. no memory allocation/deallocation is
 * required).
 * \par
 * This template class can be instantiated with a data type for which the
 * following methods are defined:
 *  - operator<
 *  - operator>
 *  - operator==
 *  - operator<<(ostream& os)
 * \sa GenericHashTable
#ifndef __SimpleHashTable_h
#define __SimpleHashTable_h
#ifdef __GNUC__
#pragma interface
#endif
template <class T>
class UTILIB_API SimpleHashTable;
template <class T>
class SimpleHashTableItem
  friend class AbstractHashTable<SimpleHashTableItem<T>,T >;
public:
	///
  void write(ostream& os) const {os << Key;}
	/// Return the key.
  T* key() {return &Key;}
	///
  int compare(T* key)
		{return ::compare(Key,*key);}
private:
	/// The key object.
  T Key;
	/// Constructor, which requires a key.
  SimpleHashTableItem(T* Key_) : Key(*Key_) {}
template <class T>
class SimpleHashTable : public AbstractHashTable<SimpleHashTableItem<T>,T >
public:
	/// Constructor, which specifies the name for the hash table.
        : AbstractHashTable<SimpleHashTableItem<T>,T>(nameBuff) {}
	/// Constructor, which specifies the size and name for the hash table.
	: AbstractHashTable<SimpleHashTableItem<T>,T>(init_size, nameBuff) {}
#endif
// SimpleHeap.h
 * \class SimpleHeap
 * A heap class that uses standard C/C++ data types for keys.
 * The \c SimpleHeap class is derived from \c AbstractHeap, which 
 * defines the basic operations of the heap. 
 * \par
 * This template class can be instantiated with a data type for which the
 * following methods are defined:
 *  -	operator<
 *  -	operator>
 *  -	operator==
 *  -	operator<<
 * Additionally, it assumes that operator=, construction and destruction are
 * efficient operations.  
 * \sa GenericHeap
#ifndef __SimpleHeap_h
#define __SimpleHeap_h
#ifdef __GNUC__
#pragma interface
#endif
#if !defined(BasicArrayT)
#ifdef USING_TEMPLATES
#define SimpleHeapItemT(T) SimpleHeapItem<##T##>
#define SimpleHeapT(T) SimpleHeap<##T##>
#else
#define SimpleHeapItemT(T) SimpleHeapItem_##T
#define SimpleHeapT(T) SimpleHeap_##T
#endif
#endif
template <class T>
class UTILIB_API SimpleHeap;
 * \class SimpleHeapItem
 * Extends the \c AbstractHeapItem to include a standard data type for 
 * a key.
template <class T>
class UTILIB_API SimpleHeapItem : public AbstractHeapItem
  friend class SimpleHeap<T>;
public:
	/// Write the key to an output stream.
  void write(ostream& os) {os << Key;}
private:
	/// The key object.
  T Key;
	/// Return the key.
  void* key() {return &Key;}
	/// Constructor, which requires a key.
  SimpleHeapItem(const T Key_) : Key(Key_) {}
template <class T>
class UTILIB_API SimpleHeap : public AbstractHeap
public:
	/// Constructor, which specifies a name for the heap.
       int initSize = defaultSize,
       int quantumChoice = defaultQuantum) 
	: AbstractHeap(nameBuff,initSize,quantumChoice) {}
	/// Destructor.
  ~SimpleHeap();
	/**
	 * Find the \c SimpleHeapItem with value \a key.
	 * If this data value is not found, this method returns \c NULL.
	 */
  SimpleHeapItem<T>* find( T& key);
	/// Return the top of the heap.
  SimpleHeapItem<T>* top()
		{return (SimpleHeapItem<T>*) AbstractHeap::top();}
	/// Adds a key to the heap.
  void add( const T& key)
                {insert(key);}
	///Adds a key to the tree and returns a \c SimpleHeapItem object in the \a item argument.
  void add( const T& key, SimpleHeapItem<T>*& item)
                {item = insert(key);}
	/**
	 * Removes a heap item with the given key.
	 * The status flag is \c TRUE if the key was found and \c FALSE 
	 * otherwise.
	 */
  void remove( T& key, int& status)
                {
		SimpleHeapItem<T>* tmp = find(key);
		if (tmp)
		   AbstractHeap::remove(tmp,status);
	        else
		   status = FALSE;
	/**
	 * Removes a heap item.
	 * The status flag is \c TRUE if the key was found and \c FALSE
	 * otherwise.
	 */
  void remove(SimpleHeapItem<T>* item, int& status)
                {
                if (!item)
                   status = FALSE;
                else
                   AbstractHeap::remove(item,status);
                }    
	/**
	 * Removes a heap item and returns the item's key.
	 * the status flag is \c TRIE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(SimpleHeapItem<T>* item, T& key, int& status)
                {
		if (!item)
                   status = FALSE;
		else {
		   key = item->Key;
		   AbstractHeap::remove(item,status);
		   }
protected:
	/// Inserts an item into the heap.
  SimpleHeapItem<T>* insert( const T& key)
		SimpleHeapItem<T>* item = new SimpleHeapItem<T>(key);
		AbstractHeap::add(item);
		return item;
	///
  int compare(const void* key1, const void* key2);
	/// 
  void write_item(ostream& output, AbstractHeapItem* item) const
		{output << ((SimpleHeapItem<T>*)item)->Key;}
	///
  void read_item(istream& is, AbstractHeapItem*& item);
	///
  void deleteElement(const int element);
template <class T>
inline UTILIB_API ostream& operator<<(ostream& output, 
						const SimpleHeap<T>& heap)
{ heap.write(output); return(output); }
template <class T>
inline UTILIB_API istream& operator>>(istream& input, SimpleHeap<T>& heap)
{ heap.read(input); return(input); }
template <class T>
int SimpleHeap<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
if (*key1 < *key2) return -1;
if (*key1 > *key2) return 1;
return 0;
template <class T>
SimpleHeap<T>::~SimpleHeap<T>()
for (int i = size(); i>0; i--)
  deleteElement(i);
template <class T>
void SimpleHeap<T>::deleteElement(const int element)
SimpleHeapItem<T>* item = (SimpleHeapItem<T>*) member(element);
delete item;
// For right now, this is done with a linear search through the
// heap array.  A more efficient method could be designed, but I don't
// expect to use this method much, so...
template <class T>
SimpleHeapItem<T>* SimpleHeap<T>::find( T& key)
for (int i=1; i<= size(); i++)
  if (((SimpleHeapItem<T>*)member(i))->Key == key)
     return (SimpleHeapItem<T>*) member(i);
return NULL;
template <class T>
void SimpleHeap<T>::read_item(istream& is, AbstractHeapItem*& item)
T key;
is >> key;
item = new SimpleHeapItem<T>(key);
}        
#endif
// SimpleSplayTree.h
 * \class SimpleSplayTree
 * A splay tree class that uses standard C/C++ data types for keys.
 * The \c SimpleSplayTree class is derived from \c AbstractSplayTree, which
 * defines the basic operations of the splay tree.   This particular
 * instantiation of splay trees uses a simple data type for the key, and
 * no auxillary data is associated with the key.  This greatly simplifies
 * the definition of the splay tree, and there are many practical contexts
 * when this type of class would be useful.
 * \par
 * This template class can be instantiated with a data type for which the 
 * following methods are defined:
 *  - operator<
 *  - operator>
 *  - operator==
 *  - operator<<
 * \sa GenericSplayTree
#ifndef __SimpleSplayTree_h
#define __SimpleSplayTree_h
#ifdef __GNUC__
#pragma interface
#endif
template <class T>
class UTILIB_API SimpleSplayTree;
 * \class SimpleSplayTreeItem
 * Extends the \c AbstractSplayTreeItem to include a standard data type
 * for a key.
template <class T>
class UTILIB_API SimpleSplayTreeItem : public AbstractSplayTreeItem
  friend class SimpleSplayTree<T>;
public:
	/// Write the key to an output stream.
  void write(ostream& os) {os << key_val;}
	/// Return the \c ctr counter.
  int counter() {return ctr;}
	/// Return the key.
  T& key()
		{return key_val;}
private:
	/// Return the key.
  void* Key() {return (void*)(&key_val);}
	/// The key object.
  T key_val;
	///The number of instances of \c Key that have been inserted into this splay tree.
  int ctr;
	/// Constructor, which requires a key.
  SimpleSplayTreeItem( T& Key_) : key_val(Key_), ctr(0) {}
	/// Dummy, virtual destructor
  virtual ~SimpleSplayTreeItem() {}
template <class T>
class UTILIB_API SimpleSplayTree : public AbstractSplayTree
public:
	/// Constructor, which specifies a name for the tree.
	: AbstractSplayTree(nameBuff), duplicate_flag(0),
			check_duplicates_flag(0) {}
	/// Destructor.
  virtual ~SimpleSplayTree();
	/**
	 * Find the \c SimpleSplayTreeItem with value \a key.
	 * If this key is not found, this method returns \c NULL.
	 */
  SimpleSplayTreeItem<T>* find( const T& key)
		{return (SimpleSplayTreeItem<T>*) 
				AbstractSplayTree::find(&key);}
	///
  int rank(const T& key)
		{find(key); return AbstractSplayTree::rank();}
	///
  SimpleSplayTreeItem<T>* find_rank(int r)
		{return (SimpleSplayTreeItem<T>*)
				AbstractSplayTree::find_rank(r);}
	/// Return the top of the splay tree.
  SimpleSplayTreeItem<T>* top()
		{return (SimpleSplayTreeItem<T>*)AbstractSplayTree::top();}
	/// Returns the value of \c duplicate_flag.
  int& duplicate() {return duplicate_flag;}
	/// Returns the value of \c check_duplicates_flag.
  int& check_duplicates() {return check_duplicates_flag;}
	/// Adds a key to the tree.
  void add( T& key)
                {insert(key);}
	/// Adds a key to the tree and returns the \c SimpleSplayTreeItem object in the \a item argument.
  void add( T& key, SimpleSplayTreeItem<T>*& item)
                {item = insert(key);}
	/**
	 * Removes a splay tree item with the given key.
	 * The status flag is \c TRUE if the key was found and \c FALSE
	 * otherwise.
	 */
  void remove( const T& key, int& status)
                {
		SimpleSplayTreeItem<T>* item = find(key);
		if (item)
		   AbstractSplayTree::remove(item,status);
	        else
		   status = FALSE;
	/**
	 * Removes a splay tree item.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(SimpleSplayTreeItem<T>* item, int& status)
                {
		if (!item)
		   status = FALSE;
		else
		   AbstractSplayTree::remove(item,status);
	/**
	 * Removes a splay tree item and returns the item's key.
	 * The status flag is \c TRUE if the item was found and \c FALSE
	 * otherwise.
	 */
  void remove(SimpleSplayTreeItem<T>* item, T& key, int& status)
                {
		if (!item)
		   status = FALSE;
		else {
		   key = item->Key;
		   AbstractSplayTree::remove(item,status);
		   }
	/// Perform a splay operation starting from the root of the tree.
  void splay(const T& key)
                {AbstractSplayTree::splay(&key);}
protected:
	/// TODO
  int duplicate_flag;
	/// TODO
  int check_duplicates_flag;
        /// Deletes an \c AbstractSplayTreeItem (used by the AbstractSplayTree class).
  void delete_item(AbstractSplayTreeItem* item)
                { delete item; }
	/// Inserts an item into the splay tree.
  SimpleSplayTreeItem<T>* insert(T& key);
	///
  int compare(const void* key1, const void* key2);
	///
  void write_item(ostream& os, AbstractSplayTreeItem* item);
	///
  void read_item(istream& is, AbstractSplayTreeItem*& item);
template <class T>
SimpleSplayTreeItem<T>* SimpleSplayTree<T>::insert(T& key)
splay(key);
SimpleSplayTreeItem<T>* treeitem = (SimpleSplayTreeItem<T>*)top();
duplicate_flag = 0;
if (check_duplicates_flag && (treeitem != NULL)) {
   if (compare(&key,treeitem->Key())==0) {	// it's already there
      treeitem->ctr++;
      duplicate_flag = 1;
      return treeitem;
      }
   }
SimpleSplayTreeItem<T>* newroot = new SimpleSplayTreeItem<T>(key);
if (newroot == NULL) 
AbstractSplayTree::add(newroot);
return newroot;
template <class T>
int SimpleSplayTree<T>::compare(const void* key1_, const void* key2_)
T* key1 = (T*) key1_;
T* key2 = (T*) key2_;
if (*key1 < *key2) return -Sense;
if (*key1 > *key2) return Sense;
return 0;
template <class T>
SimpleSplayTree<T>::~SimpleSplayTree<T>()
int Size=size();
for (int i=0; i<Size; i++) {
  SimpleSplayTreeItem<T>* item = top();
  int status;
  remove(item,status);
  delete item;
template <class T>
void SimpleSplayTree<T>::read_item(istream& is, AbstractSplayTreeItem*& item)
T key;
is >> key;
item = new SimpleSplayTreeItem<T>(key);
template <class T>
void SimpleSplayTree<T>::write_item(ostream& os, AbstractSplayTreeItem* item)
if (check_duplicates_flag)
((SimpleSplayTreeItem<T>*)item)->write(os);
#endif
// SparseMatrix.h
 * \class SparseMatrix
 * A kernel for sparse matrix classes.
 * Adapted from the sparse matrix classes developed by Kalyan S. Perumalla 
 * and Jeff T. Linderoth.
 * Note: this code uses integer indeces.  This limits the total size of the
 * sparse matrix to a smaller size than would be possible if 'long integers'
 * were used for indexing, but this is compatable with CPLEX's use of 
 * sparse arrays.
 * \class CMSparseMatrix
 * A column-major sparse matrix class.
 * Adapted from the CMatrix class of Kalyan S. Perumalla and Jeff T. Linderoth.
 * \class RMSparseMatrix
 * A row-major sparse matrix class.
 * Adapted from the RMatrix class of Kalyan S. Perumalla and Jeff T. Linderoth.
#ifndef __SparseMatrix_h
#define __SparseMatrix_h
//--- INCLUDES ---//
//--- CONSTANTS ---//
//--- TYPES ---//
template <class T>
class UTILIB_API CMSparseMatrix; // Forward decl
template <class T>
class UTILIB_API RMSparseMatrix; // Forward decl
// Note:  is this numerically stable?
template <class T>
inline void product(NumArray<T>& res, const RMSparseMatrix<T>& mat, 
						const NumArray<T>& vec)
res.resize(mat.get_nrows());
int nrows=mat.get_nrows();
for (int i=0; i<nrows; i++) {
  res[i] = 0.0;
  const T* val = &(mat.matval[mat.matbeg[i]]);
  const int*    col = &(mat.matind[mat.matbeg[i]]);
  for (int k=0; k<mat.matcnt[i]; k++, val++, col++) {
    res[i] += vec[*col] * (*val);
    }
//---------------------------------------------------------------------------
template <class T>
class UTILIB_API SparseMatrix
public:
	/// Returns the number of columns in the matrix.
  int get_ncols( void ) const { return ncols; }
	/// Returns the number of rows in the matrix.
  int get_nrows( void ) const { return nrows; }
	/// Returns the number of non-zeros in the matrix.
  int get_nnzero( void ) const {return nnzeros;}
	/// Returns the \c matbeg array.
  IntVector& get_matbeg( void ) { return matbeg; }
	/// Returns the \c matcnt array.
  IntVector& get_matcnt( void ) { return matcnt; }
	/// Returns the \c matind array.
  IntVector& get_matind( void ) { return matind; }
	/// Returns the \c matval array.
  NumArray<T>& get_matval( void ) { return matval; }
	/// Returns the value of the element at the \a row-th row and \a col-th column
  virtual T& operator()(const int row, const int col) = 0;
	/// Returns the value of the element at the \a row-th row and \a col-th column
  virtual const T& operator()(const int row, const int col) const = 0;
	/// Print out the matrix in a pretty format
  virtual int pretty_print(ostream& ostr) const;
	/// Write out the matrix to an output stream.
  virtual int write(ostream& ostr) const = 0;
	/// Read in the matrix from an input stream.
  virtual int read(istream& istr) = 0;
	/// Write out the matrix to a pack buffer
  int write(PackBuffer& ostr) const;
	/// Read in the matrix from a pack buffer
  int read(UnPackBuffer& istr);
	/// Delete the \a i-th row.
  virtual void delete_row(const int i) = 0;
	/// Delete the \a i-th column.
  virtual void delete_col(const int i) = 0;
	/// Delete the \a (row,col)-th element.
  virtual void delete_element(const int row, const int col) = 0;
protected:
	/// A protected constructor, which initializes elements in this class.
  SparseMatrix( void ) :
	ncols(0), nrows(0), nnzeros(0) {}
	/// Dummy destructor
  virtual ~SparseMatrix() {}
	/// Initialize a sparse matrix
  virtual void initialize(int nrow, int ncol, int nnzero) = 0;
	/// Initialize the memory of a sparse matrix
  void setup(int ncol, int nrow, int nnzero, int flag);
	/// The number of columns in the matrix
  int          ncols;
	/// The number of rows in the matrix
  int          nrows;
	/// The number of nonzeros in the matrix
  int	       nnzeros;
	/// Index where the \a i-th row/column begins in matval.
  IntVector    matbeg;
	/// The number of values in the \a i-th row/column
  IntVector    matcnt;
	/// matind[i] is the column/row number for the \a i-th value in row/column
  IntVector    matind;
	/// The vector of values in the matrix
  NumArray<T> matval;
template <class T>
inline ostream& operator<<(ostream& output, const SparseMatrix<T>& array)
{ array.write(output); return(output); }
template <class T>
inline istream& operator>>(istream& input, SparseMatrix<T>& array)
{ array.read(input); return(input); }
        /// Stream operator for packing
template <class T>
inline UTILIB_API PackBuffer& operator<<(PackBuffer& output, const SparseMatrix<T
>& array)
{ array.write(output); return(output); }
        /// Stream operator for unpacking
template <class T>
inline UTILIB_API UnPackBuffer& operator>>(UnPackBuffer& input, SparseMatrix<T>&
array)
{ array.read(input); return(input); }
//---------------------------------------------------------------------------
template <class T>
class UTILIB_API CMSparseMatrix : public SparseMatrix<T>
public:
  friend RMSparseMatrix<T>;
	/// Empty constructor.
  CMSparseMatrix( void ) {}
	/// Construct the matrix and resize the internal data.
  CMSparseMatrix( int nrow, int ncol, int nnzero )
		{setup(nrow,ncol,nnzero,1);}
	///
  CMSparseMatrix( CMSparseMatrix<Ereal<T> >& mat);
  	/// Dummy virtual destructor
  ~CMSparseMatrix() {}
	/// Setup a SparseMatrix that will be filled in later.
  void initialize(int nrow, int ncol, int nnzero)
		setup(nrow,ncol,nnzero,1);
		ncols=ncol;
		nrows=nrow;
		nnzeros=nnzero;
	/// Returns the value of the element at the \a row-th row and \a col-th column
  T& operator()(const int row, const int col);
	/// Returns the value of the element at the \a row-th row and \a col-th column
  const T& operator()(const int row, const int col) const;
	/// Add a column to the matrix.
  int adjoinColumn(int count, int* rowPosition, T* value);
	/// Write out the matrix to an output stream.
  int write(ostream& ostr) const;
	/// Read in the matrix from an input stream.
  int read(istream& istr);
	/// Convert a row-major matrix to a column-major matrix.
  void convert(const RMSparseMatrix<T>& rowmajor);
	/// Delete the \a i-th row.
  void delete_row(const int i);
	/// Delete the \a i-th column.
  void delete_col(const int i);
	/// Delete the \a (row,col)-th element.
  void delete_element(const int row, const int col);
//---------------------------------------------------------------------------
template <class T>
class UTILIB_API RMSparseMatrix : public SparseMatrix<T>
public:
  friend CMSparseMatrix<T>;
  friend UTILIB_API void product<T>(NumArray<T>& res, 
				const RMSparseMatrix<T>& mat, 
				const NumArray<T>& vec);
	/// Empty constructor.
  RMSparseMatrix( void ) {}
	/// Construct the matrix and resize the internal data.
  RMSparseMatrix( int nrow, int ncol, int nnzero )
		{setup(nrow,ncol,nnzero,0);}
	/// Dummy virtual destructor
  virtual ~RMSparseMatrix() {}
	/// Setup a SparseMatrix that will be filled in later.
  void initialize(int nrow, int ncol, int nnzero)
		setup(nrow,ncol,nnzero,0);
		ncols=ncol;
		nrows=nrow;
		nnzeros=nnzero;
	/// Resize the \a rowndx-th row to length \a rowlen.
  void resize(const int rowndx, const int rowlen);
	/// Returns the value of the element at the \a row-th row and \a col-th column
  T& operator()(const int row, const int col);
	/// Returns the value of the element at the \a row-th row and \a col-th column
  const T& operator()(const int row, const int col) const;
	/// Add a row to the matrix.
  int adjoinRow(int count, int* colPosition, T* value);
	/// Write out the matrix to an output stream.
  int write(ostream& ostr) const;
	/// Read in the matrix from an input stream.
  int read(istream& istr);
	/// Convert a column-major matrix to a row-major matrix.
  void convert(const CMSparseMatrix<T>& colmajor);
	/// Delete the \a i-th row.
  void delete_row(const int i);
	/// Delete the \a i-th column.
  void delete_col(const int i);
	/// Delete the \a (row,col)-th element.
  void delete_element(const int row, const int col);
// This just sets up the memory, but does not modify the ncols, nrows or
// nnzeros values
template <class T>
void SparseMatrix<T>::setup(int nrow, int ncol, int nnzero, int flag)
matind.resize(nnzero);
matval.resize(nnzero);
if (flag) {
   matbeg.resize(ncol);
   matcnt.resize(ncol);
   }
else {
   matbeg.resize(nrow);
   matcnt.resize(nrow);
   }
template <class T>
CMSparseMatrix<T>::CMSparseMatrix( CMSparseMatrix<Ereal<T> >& mat)
initialize(mat.get_nrows(), mat.get_ncols(), mat.get_nnzero());
matind << mat.get_matind();
matval << mat.get_matval();
matbeg << mat.get_matbeg();
matcnt << mat.get_matcnt();
template <class T>
T& CMSparseMatrix<T>::operator()(const int row, const int col)
if ((row < 0) || (row >= nrows) || (col < 0) || (col >= ncols))
int pt = matbeg[col];
for (int i=0; i<matcnt[col]; i++)
  if (matind[pt+i] == row)
     return matval[pt+i];
return matval[0];
template <class T>
const T& CMSparseMatrix<T>::operator()(const int row, const int col) const
if ((row < 0) || (row >= nrows) || (col < 0) || (col >= ncols))
int pt = matbeg[col];
for (int i=0; i<matcnt[col]; i++)
  if (matind[pt+i] == row)
     return matval[pt+i];
return matval[0];
template <class T>
T& RMSparseMatrix<T>::operator()(const int row, const int col)
if ((row < 0) || (row >= nrows) || (col < 0) || (col >= ncols))
int pt = matbeg[row];
for (int i=0; i<matcnt[row]; i++)
  if (matind[pt+i] == col)
     return matval[pt+i];
return matval[0];
template <class T>
const T& RMSparseMatrix<T>::operator()(const int row, const int col) const
if ((row < 0) || (row >= nrows) || (col < 0) || (col >= ncols))
int pt = matbeg[row];
for (int i=0; i<matcnt[row]; i++)
  if (matind[pt+i] == col)
     return matval[pt+i];
return matval[0];
template <class T>
int SparseMatrix<T>::pretty_print(ostream& ostr) const
for (int i=0; i<nrows; i++) {
  for (int j=0; j<ncols; j++)
  ostr << endl;
return OK;
template <class T>
int CMSparseMatrix<T>::write(ostream& ostr) const 
int ndx=0;
for (int i=0; i<ncols; i++)
  for (int j=0; j<matcnt[i]; j++) {
    ndx++;
    }
return OK;
template <class T>
int CMSparseMatrix<T>::read(istream& istr)
return ERR;
template <class T>
int SparseMatrix<T>::write(PackBuffer& ostr) const 
ostr << nrows << ncols << nnzeros;
ostr << matbeg << matcnt << matind << matval;
return OK;
template <class T>
int SparseMatrix<T>::read(UnPackBuffer& istr)
int ntmp, ctmp, ztmp;
istr >> ntmp >> ctmp >> ztmp;
initialize(ntmp,ctmp,ztmp);
istr >> matbeg >> matcnt >> matind >> matval;
return OK;
template <class T>
int RMSparseMatrix<T>::write(ostream& ostr) const 
int ndx=0;
for (int i=0; i<nrows; i++)
  for (int j=0; j<matcnt[i]; j++) {
    ndx++;
    }
return OK;
template <class T>
int RMSparseMatrix<T>::read(istream& istr)
return ERR;
template <class T>
void RMSparseMatrix<T>::delete_row(const int i)
// Delete all of the elements in the row
while (matcnt[i] > 0)
  delete_element(i,matind[matbeg[i]]);
// Delete the row itself
for (int j=i; j<(nrows-1); j++) {
  matbeg[j] = matbeg[j+1];
  matcnt[j] = matcnt[j+1];
nrows--;
template <class T>
void RMSparseMatrix<T>::delete_col(const int i)
// Delete all of the elements in the column
for (int j=0; j<nrows; j++) {
  //
  // Look for column i in row j
  //
  int k=0;
  while (k < matcnt[j]) {
    if (matind[matbeg[j]+k] == i)
       delete_element(j,i);
    else {
       if (matind[matbeg[j]+k] > i)
          matind[matbeg[j]+k]--;
       k++;
       }
    }
// Delete the column itself (the column indeces are decremented above!)
ncols--;
template <class T>
void RMSparseMatrix<T>::delete_element(const int rowndx, const int colndx)
int k=0;
for (; k<matcnt[rowndx]; k++)
  if (matind[matbeg[rowndx]+k] == colndx) {
     break;
     }
if (k == matcnt[rowndx]) return;
for (int i=matbeg[rowndx]+k; i<(nnzeros-1); i++) {
  matind[i] = matind[i+1];
  matval[i] = matval[i+i];
matcnt[rowndx]--;
for (int j=rowndx+1; j<nrows; j++)
  matbeg[j]--;
nnzeros--;
template <class T>
void RMSparseMatrix<T>::resize(const int rowndx, const int rowlen)
if (rowlen == matcnt[rowndx])
   return;
else if (rowlen > matcnt[rowndx]) {
   // TODO - resize the array up!
   }
else {
   int diff = rowlen-matcnt[rowndx];
   if (diff < 0) {
      for (int i=matbeg[rowndx]+rowlen; i<(nnzeros+diff); i++) {
        matind[i] = matind[i-diff];
        matval[i] = matval[i-diff];
        }
      }
   matcnt[rowndx] += diff;
   for (int j=rowndx+1; j<nrows; j++)
     matbeg[j] += diff;
   nnzeros += diff;
   }
template <class T>
void CMSparseMatrix<T>::convert(const RMSparseMatrix<T>& rowmajor)
matval.resize(rowmajor.nnzeros);
matind.resize(rowmajor.nnzeros);
ncols = rowmajor.ncols;
nrows = rowmajor.nrows;
nnzeros = rowmajor.nnzeros;
matcnt.resize(ncols);
matcnt=0;
matbeg.resize(ncols);
IntVector rowndx(nrows);
rowndx=0;
int prev_cndx=0;
for (int i=0; i<nnzeros; i++) {
  //
  // Set dummy values for cndx and rndx
  //
  int cndx=ncols;
  int rndx=-1;
  //
  // Find the point in the matrix with the next highest column index
  //
  for (int j=0; j<nrows; j++) {
    if ((rowmajor.matcnt[j] > 0) && (rowmajor.matcnt[j] > rowndx[j])) {
       if (rowmajor.matind[rowmajor.matbeg[j]+rowndx[j]] < cndx) {
          cndx = rowmajor.matind[rowmajor.matbeg[j]+rowndx[j]];
          rndx = j;
          }
       }
    if (cndx == prev_cndx)	// Can stop early because we're in the same col
       break;
    }
  //
  // Add this new point to the CM matrix
  //
  if (matcnt[cndx] == 0)
     matbeg[cndx] = i;
  matcnt[cndx]++;
  matind[i] = rndx;
  matval[i] = rowmajor.matval[rowmajor.matbeg[rndx]+rowndx[rndx]];
  rowndx[rndx]++;
  prev_cndx=cndx;
template <class T>
void RMSparseMatrix<T>::convert(const CMSparseMatrix<T>& colmajor)
matval.resize(colmajor.nnzeros);
matind.resize(colmajor.nnzeros);
ncols = colmajor.ncols;
nrows = colmajor.nrows;
nnzeros = colmajor.nnzeros;
matcnt.resize(nrows);
matcnt=0;
matbeg.resize(nrows);
IntVector colndx(ncols);
colndx=0;
int prev_rndx=0;
for (int i=0; i<nnzeros; i++) {
  //
  // Find the point in the matrix with the next highest row index
  //
  int cndx=-1;
  int rndx=nrows;
  for (int j=0; j<ncols; j++) {
    if ((colmajor.matcnt[j] > 0) && (colmajor.matcnt[j] > colndx[j])) {
       if (colmajor.matind[colmajor.matbeg[j]+colndx[j]] < rndx) {
          cndx = j;
          rndx = colmajor.matind[colmajor.matbeg[j]+colndx[j]];
          }
       }
    if (prev_rndx == rndx)	// Can stop because we are on the same row
       break;
    }
  //
  // Add this new point to the RM matrix
  //
  if (matcnt[rndx] == 0)
     matbeg[rndx] = i;
  matcnt[rndx]++;
  matind[i] = cndx;
  matval[i] = colmajor.matval[colmajor.matbeg[cndx]+colndx[cndx]];
  colndx[cndx]++;
  prev_rndx=rndx;
template <class T>
int CMSparseMatrix<T>::adjoinColumn(int count, int* rowPosition, T* value)
if (ncols == (int) matcnt.size()) {
   matcnt.resize(ncols+32);
   matbeg.resize(ncols+32);
   }
if (nnzeros + count > (int) matval.size()) {
   matval.resize(nnzeros+max(count,64));
   matind.resize(nnzeros+max(count,64));
   }
matbeg[ncols] = nnzeros;
matcnt[ncols++] = count;
for (int i=0; i<count; i++) {
  matind[nnzeros]   = rowPosition[i];
  // If we're building from scratch, number of rows is the highest row
  // number seen so far (+1 since 0 based)
  if (rowPosition[i] >= nrows)
    nrows = rowPosition[i] + 1;
  matval[nnzeros++] = value[i];
return nnzeros;
template <class T>
void CMSparseMatrix<T>::delete_col(const int i)
// Delete all of the elements in the col 
while (matcnt[i])
  delete_element(matind[matbeg[i]],i);
// Delete the col itself
for (int j=i; j<(ncols-1); j++) {
  matbeg[j] = matbeg[j+1];
  matcnt[j] = matcnt[j+1];
ncols--;
template <class T>
void CMSparseMatrix<T>::delete_row(const int i)
// Delete all of the elements in the column
for (int j=0; j<ncols; j++) {
  //
  // Look for row i in row j
  //
  int k=0;
  while (k < matcnt[j]) {
    if (matind[matbeg[j]+k] == i)
       delete_element(i,j);
    else {
       if (matind[matbeg[j]+k] > i)
          matind[matbeg[j]+k]--;
       k++;
       }
    }
// Delete the row itself (the row indeces are decremented above!)
nrows--;
template <class T>
void CMSparseMatrix<T>::delete_element(const int rowndx, const int colndx)
int k=0;
for (; k<matcnt[colndx]; k++)
  if (matind[matbeg[colndx]+k] == rowndx) {
     break;
     }
if (k == matcnt[colndx]) return;
for (int i=matbeg[colndx]+k; i<(nnzeros-1); i++) {
  matind[i] = matind[i+1];
  matval[i] = matval[i+1];
matcnt[colndx]--;
for (int j=colndx+1; j<ncols; j++)
  matbeg[j]--;
nnzeros--;
template <class T>
int RMSparseMatrix<T>::adjoinRow(int count, int* colPosition, T* value)
if (nrows == (int) matcnt.size()) {
   matcnt.resize(nrows+32);
   matbeg.resize(nrows+32);
   }
if (nnzeros + count > (int) matval.size()) {
   matval.resize(nnzeros+max(count,64));
   matind.resize(nnzeros+max(count,64));
   }
matbeg[nrows] = nnzeros;
matcnt[nrows++] = count;
for (int i=0; i<count; i++) {
  matind[nnzeros]   = colPosition[i];
  matval[nnzeros++] = value[i];
return nnzeros;
#endif
// StackArray.h
 * \class StackArray
 * An array-based stack.
#ifndef __StackArray_h
#define __StackArray_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stddef.h>
#include <iostream.h>
#include <stdlib.h>
#else
#include <iostream>
#include <cstddef>
#include <cstdlib>
#endif
#if !defined(StackArrayT)
#ifndef USING_TEMPLATES
#define StackArrayT(T) StackArray_##T
#else
#define StackArrayT(T) StackArray<##T##>
#endif
#endif
////
//// class StackArray<T>
////
template <class T>
class UTILIB_API StackArray
public:
	/// Empty constructor that sets up an empty stack.
  StackArray();
	/// Constructor that sets up an empty stack using a shared array.
  StackArray(BasicArray<T>& data);
	/// Destructor.
  virtual ~StackArray() {}
	/// Returns the value at the top of the stack, which is the next element that will be removed.
  virtual T& top()
		if (Len>0)
		   return Data[Len-1];
		return Data[0];
	/// Adds a item with data value \a data.
  virtual void add( const T& );
	/// Removes the next item, and returns the data value in \a data.
  virtual void remove( T& );
	/// Returns \c TRUE if the stack is empty and \c FALSE otherwise.
  int empty() const
		{return (Len == 0);}
	/// Returns \c TRUE if the stack is empty and \c FALSE otherwise.
  operator int() const
		{return (Len > 0);}
	/// Returns the number of items in the stack.
  size_type len() const
		{return Len;}
  BasicArray<T>& get_data()
		{Data.resize(Len); return(Data);}
protected:
	/// The number of items in the stack.
  size_type Len;
	/// The array used for storing the stack.
  BasicArray<T> Data;
template <class T>
inline UTILIB_API StackArray<T>& operator>>(StackArray<T>& list, T& val)
{list.remove(val); return list;}
template <class T>
inline UTILIB_API StackArray<T>& operator<<(StackArray<T>& list, const T& val)
{list.add(val); return list;}
template <class T>
StackArray<T>::StackArray()
 : Len(0)
template <class T>
StackArray<T>::StackArray(BasicArray<T>& data)
 : Len(0)
{ Data &= data; }
template <class T>
void StackArray<T>::remove( T& Value )
if (Len == 0)
Value = Data[--Len];
template <class T>
void StackArray<T>::add( const T& val )
if (Data.size() == Len)
   Data.resize(max((Data.size() / 10),10));
Data[Len++] = val;
#endif
// StackList.h
 * \class StackList
 * A data type that defines a stack using a doubly-linked
 * list data structure.  This class is a simple derivation of 
 * \c LinkedList that sets the stack mode.
#ifndef __StackList_h
#define __StackList_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <stddef.h>
#else
#include <cstddef>
#endif
#if !defined(StackListT)
#ifndef USING_TEMPLATES
#define StackListT(T) StackList_##T
#else
#define StackListT(T) StackList<##T##>
#endif
#endif
////
//// class StackList<T>
////
template <class T>
class UTILIB_API StackList : public LinkedList<T>
public:
	/// Empty constructor.
  StackList() : LinkedList() {mode = stackLL;}
#endif
// Tuple.h
 * \class Tuple1
 * Implements a 1-tuple which provides a fixed length list with
 * syntactic differentiation of the elements.
#ifndef __Tuple_h
#define __Tuple_h
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif
template <class T1> class Tuple1;
template <class T1, class T2> class Tuple2;
template <class T1, class T2, class T3> class Tuple3;
template <class T1, class T2, class T3, class T4> class Tuple4;
template <class T1, class T2, class T3, class T4, class T5> class Tuple5;
template <class T1, class T2, class T3, class T4, class T5, class T6> class Tuple6;
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7> class Tuple7;
template <class T1> class Tuple1
public:
  friend class BasicArray<Tuple1<T1> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple1(T1 _val1) 
		: val1(_val1) {num_elements=1;}
	///
  int operator==(const Tuple1<T1>& tuple) const
		{return (tuple.val1 == val1);}
	///
  T1 val1;
	///
  void write(ostream& os) const
		if (num_elements == 1)
	///
  void write(PackBuffer& os) const
		{os << val1;}
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val1;}
protected:
	///
  Tuple1() {num_elements=0;}
	///
  unsigned int num_elements;
template <class T1, class T2>
class Tuple2 : public Tuple1<T1>
public:
  friend class BasicArray<Tuple2<T1,T2> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple2(T1 _val1, T2 _val2) 
		: Tuple1<T1>(_val1), val2(_val2) {num_elements=2;}
	///
  int operator==(const Tuple2<T1,T2>& tuple) const
		{return (Tuple1<T1>::operator==(tuple) && 
			(tuple.val2 == val2));}
	///
  T2 val2;
	///
  void write(ostream& os) const
		Tuple1<T1>::write(os);
		if (num_elements == 2)
	///
  void write(PackBuffer& os) const
		{Tuple1<T1>::write(os);os << val2; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val2; Tuple1<T1>::read(is);}
protected:
	///
  Tuple2() {num_elements=0;}
template <class T1, class T2, class T3>
class Tuple3 : public Tuple2<T1,T2>
public:
  friend class BasicArray<Tuple3<T1,T2,T3> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple3(T1 _val1, T2 _val2, T3 _val3) 
		: Tuple2<T1,T2>(_val1,_val2), val3(_val3) {num_elements=3;}
	///
  int operator==(const Tuple3<T1,T2,T3>& tuple) const
		{return (Tuple2<T1,T2>::operator==(tuple) && 
			(tuple.val3 == val3));}
	///
  T3 val3;
	///
  void write(ostream& os) const
		Tuple2<T1,T2>::write(os);
		if (num_elements == 3)
	///
  void write(PackBuffer& os) const
		{Tuple2<T1,T2>::write(os);os << val3; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val3; Tuple2<T1,T2>::read(is);}
protected:
	///
  Tuple3() {num_elements=0;}
template <class T1, class T2, class T3, class T4>
class Tuple4 : public Tuple3<T1,T2,T3>
public:
  friend class BasicArray<Tuple4<T1,T2,T3,T4> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple4(T1 _val1, T2 _val2, T3 _val3, T4 _val4) 
		: Tuple3<T1,T2,T3>(_val1,_val2,_val3), val4(_val4) {num_elements=4;}
	///
  int operator==(const Tuple4<T1,T2,T3,T4>& tuple) const
		{return (Tuple3<T1,T2,T3>::operator==(tuple) && 
			(tuple.val4 == val4));}
	///
  T4 val4;
	///
  void write(ostream& os) const
		Tuple3<T1,T2,T3>::write(os);
		if (num_elements == 4)
	///
  void write(PackBuffer& os) const
		{Tuple3<T1,T2,T3>::write(os);os << val4; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val4; Tuple3<T1,T2,T3>::read(is);}
protected:
	///
  Tuple4() {num_elements=0;}
template <class T1, class T2, class T3, class T4, class T5>
class Tuple5 : public Tuple4<T1,T2,T3,T4>
public:
  friend class BasicArray<Tuple5<T1,T2,T3,T4,T5> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple5(T1 _val1, T2 _val2, T3 _val3, T4 _val4, T5 _val5) 
		: Tuple4<T1,T2,T3,T4>(_val1,_val2,_val3,_val4), val5(_val5) {num_elements=5;}
	///
  int operator==(const Tuple5<T1,T2,T3,T4,T5>& tuple) const
		{return (Tuple4<T1,T2,T3,T4>::operator==(tuple) && 
			(tuple.val5 == val5));}
	///
  T5 val5;
	///
  void write(ostream& os) const
		Tuple4<T1,T2,T3,T4>::write(os);
		if (num_elements == 5)
	///
  void write(PackBuffer& os) const
		{Tuple4<T1,T2,T3,T4>::write(os);os << val5; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val5; Tuple4<T1,T2,T3,T4>::read(is);}
protected:
	///
  Tuple5() {num_elements=0;}
template <class T1, class T2, class T3, class T4, class T5, class T6>
class Tuple6 : public Tuple5<T1,T2,T3,T4,T5>
public:
  friend class BasicArray<Tuple6<T1,T2,T3,T4,T5,T6> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple6(T1 _val1, T2 _val2, T3 _val3, T4 _val4, T5 _val5, T6 _val6) 
		: Tuple5<T1,T2,T3,T4,T5>(_val1,_val2,_val3,_val4,_val5),
		  val6(_val6) {num_elements=6;}
	///
  int operator==(const Tuple6<T1,T2,T3,T4,T5,T6>& tuple) const
		{return (Tuple5<T1,T2,T3,T4,T5>::operator==(tuple) && 
			(tuple.val6 == val6));}
	///
  T6 val6;
	///
  void write(ostream& os) const
		Tuple5<T1,T2,T3,T4,T5>::write(os);
		if (num_elements == 6)
	///
  void write(PackBuffer& os) const
		{Tuple5<T1,T2,T3,T4,T5>::write(os);os << val6; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val6; Tuple5<T1,T2,T3,T4,T5>::read(is);}
protected:
	///
  Tuple6() {num_elements=0;}
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
class Tuple7 : public Tuple6<T1,T2,T3,T4,T5,T6>
public:
  friend class BasicArray<Tuple7<T1,T2,T3,T4,T5,T6,T7> >;
	///
#ifndef NON_ANSI
  explicit 
#endif
  Tuple7(T1 _val1, T2 _val2, T3 _val3, T4 _val4, T5 _val5, T6 _val6,
				T7 _val7) 
		: Tuple6<T1,T2,T3,T4,T5,T6>(_val1,_val2,_val3,_val4,_val5,_val6),
		  val7(_val7) {num_elements=7;}
	///
  int operator==(const Tuple7<T1,T2,T3,T4,T5,T6,T7>& tuple) const
		{return (Tuple6<T1,T2,T3,T4,T5,T6>::operator==(tuple) && 
			(tuple.val7 == val7));}
	///
  T7 val7;
	///
  void write(ostream& os) const
		Tuple6<T1,T2,T3,T4,T5,T6>::write(os);
		if (num_elements == 7)
	///
  void write(PackBuffer& os) const
		{Tuple6<T1,T2,T3,T4,T5,T6>::write(os);os << val7; }
	///
  void read(istream& /*is*/) 
		{;}
	///
  void read(UnPackBuffer& is)
		{is >> val7; Tuple6<T1,T2,T3,T4,T5,T6>::read(is);}
protected:
	///
  Tuple7() {num_elements=0;}
// Template operator<< ostream functions
template <class T1>
inline ostream& operator<<(ostream& os, const Tuple1<T1>& obj)
{ obj.write(os); return os; }
template <class T1, class T2>
inline ostream& operator<<(ostream& os, const Tuple2<T1,T2>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3>
inline ostream& operator<<(ostream& os, const Tuple3<T1,T2,T3>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4>
inline ostream& operator<<(ostream& os, const Tuple4<T1,T2,T3,T4>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5>
inline ostream& operator<<(ostream& os, const Tuple5<T1,T2,T3,T4,T5>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5, class T6>
inline ostream& operator<<(ostream& os, const Tuple6<T1,T2,T3,T4,T5,T6>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline ostream& operator<<(ostream& os, const Tuple7<T1,T2,T3,T4,T5,T6,T7>& obj)
{ obj.write(os); return os; }
// Template operator<< PackBuffer functions
template <class T1>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple1<T1>& obj)
{ obj.write(os); return os; }
template <class T1, class T2>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple2<T1,T2>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple3<T1,T2,T3>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple4<T1,T2,T3,T4>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple5<T1,T2,T3,T4,T5>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5, class T6>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple6<T1,T2,T3,T4,T5,T6>& obj)
{ obj.write(os); return os; }
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline PackBuffer& operator<<(PackBuffer& os, const Tuple7<T1,T2,T3,T4,T5,T6,T7>& obj)
{ obj.write(os); return os; }
// Template operator>> istream functions
template <class T1>
inline istream& operator>>(istream& is, Tuple1<T1>& obj)
{ obj.read(is); return is; }
template <class T1, class T2>
inline istream& operator>>(istream& is, Tuple2<T1,T2>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3>
inline istream& operator>>(istream& is, Tuple3<T1,T2,T3>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4>
inline istream& operator>>(istream& is, Tuple4<T1,T2,T3,T4>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5>
inline istream& operator>>(istream& is, Tuple5<T1,T2,T3,T4,T5>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5, class T6>
inline istream& operator>>(istream& is, Tuple6<T1,T2,T3,T4,T5,T6>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline istream& operator>>(istream& is, Tuple7<T1,T2,T3,T4,T5,T6,T7>& obj)
{ obj.read(is); return is; }
// Template operator>> UnPackBuffer functions
template <class T1>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple1<T1>& obj)
{ obj.read(is); return is; }
template <class T1, class T2>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple2<T1,T2>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple3<T1,T2,T3>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple4<T1,T2,T3,T4>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple5<T1,T2,T3,T4,T5>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5, class T6>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple6<T1,T2,T3,T4,T5,T6>& obj)
{ obj.read(is); return is; }
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
inline UnPackBuffer& operator>>(UnPackBuffer& is, Tuple7<T1,T2,T3,T4,T5,T6,T7>& obj)
{ obj.read(is); return is; }
#endif
// TwoBitArray.h
 * \class TwoBitArray
 * An array of two-bit values.   The main elements of 
 * this array have the same look and feel as a \c SimpleArray object.  However, 
 * this class uses a special, compact representation of the data elements, 
 * which forces it to be a separate class.  This class does not impose a 
 * restriction on the maximum length of the array.
#ifndef __TwoBitArray
#define __TwoBitArray
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <math.h>
#else
#include <iostream>
#include <cmath>
#endif
// I'm not sure that this would work if BYTESIZE != 8
#define BYTESIZE 8      /* bits per char */
 * \def TwoBitArraySanityChecking
 * If the macro ArraySanityChecking=1 then some routine sanity checks will
 * be performed when accessing vectors.  Sanity checking generally degrades
 * performance.  The default is is to perform sanity checking.
 * -O is used, you can define some files with ArraySanityChecking=0 to
 * acheive better performance, while using the default debugging mode in the
 * rest of the code.
#if !defined(TwoBitArraySanityChecking)
#define	TwoBitArraySanityChecking	1
#endif
class UTILIB_API TwoBitArray : public BitArrayBase {
public:
	/// Empty constructor.
  TwoBitArray() : BitArrayBase() {}
	/// Construct with data provided by the \a d array.
  TwoBitArray(const size_type len, const size_type nbytes=0, char* d=(char*)0, 
			 const EnumDataOwned o=DataNotOwned)
		{construct(len,
                        (nbytes==0 ?  (len+BYTESIZE-1)/(BYTESIZE/element_size())                                
                                   : nbytes), 
                        d,o); }
	/// Copy constructor.
  TwoBitArray(const TwoBitArray& array)
		: BitArrayBase(array) {}
	/// 
  int operator()(const size_type ndx) const;
	///
  void put(const size_type ndx, const int val);
	/// Read the array from an input stream.
  int read(istream& input);
protected:
	///
  int operator[](const size_type ndx) const;
        ///
  int element_size() const
                {return 2;}
inline int TwoBitArray::operator()(const size_type idx) const
#if (TwoBitArraySanityChecking==1)
if (idx >= array_len)
#endif
unsigned char X = Data[(2*idx)/BYTESIZE];
size_type i = 2*idx;
unsigned char val = (X & (char)(3 << (i & (BYTESIZE - 1))));
val = val >> (i & (BYTESIZE - 1));
return (int)val;
inline int TwoBitArray::operator[](const size_type idx) const
#if (TwoBitArraySanityChecking==1)
if (idx >= array_len)
#endif
unsigned char X = Data[(2*idx)/BYTESIZE];
size_type i = 2*idx;
unsigned char val = (X & (char)(3 << (i & (BYTESIZE - 1))));
val = val >> (i & (BYTESIZE - 1));
return (int)val;
inline void TwoBitArray::put(const size_type idx, const int val)
#if (TwoBitArraySanityChecking==1)
if (idx >= array_len)
#endif
unsigned char X = Data[(2*idx)/BYTESIZE];
size_type i = 2*idx;
unsigned char qwerty = (3 << (i & (BYTESIZE - 1)));
unsigned char qwertydata = X & qwerty;
X ^= qwertydata;
X |= ((val & 3) << (i & (BYTESIZE - 1)));
Data[(2*idx)/BYTESIZE] = X;
#endif
 * \file comments.h
 * \author William E. Hart
#ifndef __comments_h
#define __comments_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
 * Move the stream counter forward, passing over whitespace and 
 * comment lines, which begin with a '#'.
 * The argument \a line_counter returns the number of lines that were 
 * skipped.
UTILIB_API istream& comment_lines(istream& ins, int& line_counter);
 * Move the stream counter forward, passing over whitespace and 
 * comment lines, which begin with a '#'.
inline UTILIB_API istream& comment_lines(istream& ins)
int tmp=0;
return (comment_lines(ins,tmp));
 * Move the stream counter forward, passing over whitespace.
 * This serves the same role as 'ws', but this operator does not work
 * under Solaris 6.0 compilers.
UTILIB_API istream& whitespace(istream& ins);
#endif
 * \file	CommonIO.h
 * \author 	William E. Hart
 * \class CommonIO
 * Class that provides globally accessible stream definitions.  This allows
 * I/O to be routed through a common point in the code.  Including this class
 * allows I/O from the standard ostreams cout and cerr to be implicitly 
 * routed through a strstream buffer, which is used to add tagging information.
 * Further, the standard ostreams can be globally replaced with other ostreams,
 * which allows for a single point of control for routing all I/O in a 
 * program through a single string (e.g. to a file via an ofstream).
 * \par
 * Including the CommonIO.h header file provides macro-based definitions for
 * the symbols ucout, ucerr and ucin.  By default, these symbols are mapped
 * to the standard C++ I/O streams.  I/O can be directed to/from other 
 * streams using the set_streams, set_cout, set_cerr and set_cin methods.
 * CommonIO also allows users to masking these streams, which adds 
 * information about the processor ID and/or line number of the I/O.
 * To begin masking, the user executes CommonIO::begin(), and 
 * similarly CommonIO::end() is called to end the masking of these streams.  
 * For example:
 * \verbatim
    CommonIO::begin()
    CommonIO::end()
   \endverbatim
 * Note that calls to CommonIO::begin() and CommonIO::end() can be nested,
 * enabling subroutines to use CommonIO without worrying whether the IO
 * has already been redirected.  However, note that the formatting
 * options for CommonIO streams described below are NOT reset after
 * a call to CommonIO::end(); the user is responsible for reseting the
 * state of the CommonIO streams after their use.
 * \par
 * Because a begin-end block can be nested in this fashion, calling 
 * CommonIO::end() does not necessarily turn off IO mapping;  IO mapping
 * could have been initialed from an enclosing begin-end block.  The method
 * CommonIO::map_off() can be called to explicitly turn off IO mapping
 * regardless whether mapping has been initiated by a previous
 * call to CommonIO::begin().  CommonIO::map_on() must be used to 
 * restart IO mapping; a subsequent call to CommonIO::begin() will be
 * masked by the the CommonIO::off() method.  Finally, note that an error is 
 * detected if a matching Common()::end() is not called for every 
 * CommonIO::begin() when the last CommonIO object is destructed.
 * \par
 * CommonIO provides routines that manage parallel debugging, prepending 
 * tagging information, and providing a global debugging flag.  Tagging
 * information is prepended after begin_tagging() is called. An optional
 * argument specifies the value of the the numDigits variable (by default
 * numDigits=0). The format of the prepended IO is:
 * \verbatim
    [r]-000ii
   \endverbatim
 * where 'r' is the rank of the current process and 'ii' is the index of the
 * current IO; the index field has numDigits digits.  Tagging is stopped when
 * end_tagging() is called.
 * \par
 * To facilitate tagging, the ucout/ucerr macros map to strstream buffers.  
 * When the stream is flushed by calling 'CommonIO::flush()' or
 * by using the IO manipulator 'Flush',
   \verbatim 
 	ucout << Flush
   \endverbatim
 * the IO is processed to insert the rank information after every end-of-line
 * in the stream.  Using this facility makes it difficult to support the 'flush'
 * method for streams, as <stream>.flush() gets mapped to a flush operation
 * on an strstream object.  This does NOT flush the <stream> object as with
 * standard ucout/ucerr streams.  Consequently, the 'Flush' IO manipulator has 
 * been created to provide a convenient means of flushing CommonIO streams.
 * \par
 * CommonIO can also be used to buffer IO generated by a process.  If 
 * CommonIO::begin_buffered() is called, then the IO is mapped via 
 * strstream objects, but the IO is not flushed until CommonIO::end() is called.
 * If a new CommonIO begin/end block is started within a buffered begin/end
 * block, IO within this block will continue to be buffered.
 * \par
 * The setIORank() method can be used to limit debugging IO to a limited 
 * number of processors.  By default, the verbosity() check allows all 
 * processors to perform IO.  By calling setIORank(x), where x != rank(), 
 * future calls to verbosity() will return FALSE, thereby turning off 
 * debugging IO.
#ifndef __CommonIO_h
#define __CommonIO_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
using namespace std;
#endif
#ifdef _MSC_VER
#include <strstrea.h>
#else
#include <strstream.h>
#endif
 * Generic function for printing a stream to cout.  Useful for writing
 * C code that uses C++ streams without tieing stdio and C++ streams
 * directly.
void cout_print(const char* str);
 * Generic function for printing a stream to cerr.  Useful for writing
 * C code that uses C++ streams without tieing stdio and C++ streams
 * directly.
void cerr_print(const char* str);
#define DEBUG_COMMONIO
#ifndef SWIG
// Macros for overriding the C++ streams
class CommonIO;
 * The globally defined CommonIO object that is used for functions.
extern CommonIO global_CommonIO;
 * Definition for \c ucout masks the standard definition of the cout stream,
 * redirecting I/O through the CommonIO method \c outs.
#define ucout    (**CommonIO::MapCout)
 * Definition for \c ucerr masks the standard definition of the cerr stream,
 * redirecting I/O through the CommonIO method \c errs.
#define ucerr    (**CommonIO::MapCerr)
 * Definition for \c ucin masks the standard definition of the cin stream,
 * redirecting I/O through the CommonIO method \c ins.
#define ucin    (**CommonIO::MapCin)
 * A macro that is always maps to the standard cout stream.
#define stdcout (*CommonIO::std_cout)
 * A macro that is always maps to the standard cerr stream.
#define stdcerr (*CommonIO::std_cerr)
 * A macro that is always maps to the standard cin stream.
#define stdcin  (*CommonIO::std_cin)
// Used for syncronizing output on MIMD machines
	/// TODO
UTILIB_API void clear_print_marker_queue();
	/// TODO
UTILIB_API void set_sync_print(const int flag);
	/// TODO
UTILIB_API void get_print_marker();
	/// TODO
UTILIB_API void return_print_marker();
#ifdef  DEBUGGING
  #ifdef DEBUGPR
  #undef DEBUGPR
  #endif
	/// Executes \p cmd if \c verbosity(dlevel) is true.
  #define DEBUGPR(dlevel,cmd)  if (verbosity(dlevel)) {cmd; CommonIO::flush();}
	/// Similar to \c DEBUGPR but does not flush the output.
  #define DEBUGPRP(dlevel,cmd) if (verbosity(dlevel)) { cmd; }
	/**
 	 * Similar to \c DEBUGPR, but uses a pointer to another CommonIO-based
	 * class. It can be used to debug output from a class not based
	 * on CommonIO, provided the verbosity method is defined for that 
	 * class.
	 */
  #define DEBUGPRX(dlevel,ptr,stuff) \
     if (ptr->verbosity(dlevel)) { ucout << stuff; CommonIO::flush(); }
	/**
 	 * Similar to \c DEBUGPRX, but does not flush the output.
	 */
  #define DEBUGPRXP(dlevel,ptr,stuff) \
     if (ptr->verbosity(dlevel)) { ucout << stuff; }
	/**
 	 * Declares that the debug level of the class should be taken from
	 * the object pointed to by \p pointer.
	 */
  #define REFER_DEBUG(pointer) \
    virtual int verbosity(int level) { return pointer->verbosity(level); };
#else
  #define DEBUGPR(dlevel,cmd)          /* Nothing */
  #define DEBUGPRP(dlevel,cmd)         /* Nothing */
  #define DEBUGPRX(ptr,dlevel,stuff)   /* Nothing */
  #define DEBUGPRXP(ptr,dlevel,stuff)  /* Nothing */
  #define REFER_DEBUG(pointer)         /* Nothing */
#endif
#endif // SWIG
#ifndef SWIG
class UTILIB_API CommonIO {
#else
class CommonIO {
#endif
  friend void cppMessage_abort();
  friend UTILIB_API ostream& Flush(ostream& outstr);
public:
	/// Constructor
  CommonIO();
	/// Destructor - flushes the I/O streams
  virtual ~CommonIO();
	/// Begin using CommonIO to redirect IO
  static void begin();
	/// Begin using CommonIO to redirect IO using buffered IO
  static void begin_buffered();
	/// End the use of CommonIO to redirect IO
  static void end();
	/// Turn off CommonIO mapping (by default it is on)
  static void map_off()
		{flush(); io_mapping = OFF; reset_map();}
	/// Turn on the CommonIO mapping
  static void map_on()
		{ io_mapping = ON; reset_map();}
	/// Resets the I/O streams to the C++ standard streams
  static void reset();
	/// Specifies the debugging level (0 means no debugging)
  int debug;
	/// The maximum number of digits needed to print the I/O counter
  static int numDigits;
	/// Returns true if I/O is allowed from this process
  virtual int  verbosity(const int level)
    		{
      		if ((IO_Rank != -1) && (IO_Rank != Rank))
		   return 0;
      		else
		   return (debug >= level);
    		}
	/// Set the debugging field
  void  setDebug(int level)       	{ debug = level; }
	/// Set the rank of the processor that is allowed to do I/O 
  static void  setIORank(int Rank_)   	{ IO_Rank = Rank_; }
	/// Set the flag to indicate whether I/O is explicitly flushed
  static void  setIOFlush(int flush_) 	{ flush_flag = flush_; };
	/// Rank of the current process
  static int rank()     { return Rank; };
	/// Rank of the current process
  static int io_rank()     { return IO_Rank; };
	/// Number of processes
  static int numProcs() { return Size; };
	/// Returns a stream that 'wraps' the common_cout
  static ostream& outs()
		{return o_stream(0);}
	/// Returns a stream that 'wraps' the common_cerr
  static ostream& errs()
		{return o_stream(1);}
	/// Returns a stream that 'wraps' the common_cin
  static istream& ins()
		{return (*common_cin);}
	/// The function for reseting the streams.  Null streams are unchanged.
  static void set_streams(ostream* cout_, ostream* cerr_, istream* cin_)
		if (cout_) common_cout = cout_; 
		if (cerr_) common_cerr = cerr_; 
		if (cin_) common_cin = cin_;
	/// The function for reseting the cout stream.
  static void set_cout(ostream* cout_)
		{ if (cout_) common_cout = cout_; }
	/// The function for reseting the cerr stream.
  static void set_cerr(ostream* cerr_)
		{ if (cerr_) common_cerr = cerr_; }
	/// The function for reseting the cin stream.
  static void set_cin(istream* cin_)
		{ if (cin_) common_cin = cin_; }
	/// Redirect ucout/ucerr I/O to seperate output streams for each processor
  static void set_ofile(const char* ofile);
	/// TODO
  static void begin_tagging()
		{IOflush(); tagging=ON;}
	/// TODO
  static void begin_tagging(const int numDigits_)
		{IOflush(); numDigits = numDigits_; tagging=ON;}
	/// TODO
  static void end_tagging()
		{IOflush(); tagging=OFF;}
	/// TODO
  static void flush()
		{IOflush(); common_cout->flush(); common_cerr->flush();}
	/// Synchronized the C++ streams with the STDIO streams
  static void sync_stdio()
		{ios::sync_with_stdio();}
	/// static reference to the system cout stream
  static ostream* std_cout;
	/// static reference to the system cerr stream
  static ostream* std_cerr;
	/// static reference to the system cin stream
  static istream* std_cin;
	/// The C++ stream object used to process ucout stream information
  static ostream** MapCout;
	/// The C++ stream object used to process ucerr stream information
  static ostream** MapCerr;
	/// The C++ stream object used to process ucin stream information
  static istream** MapCin;
protected:
	/// End the use of CommonIO to redirect IO, completely reseting 
  static void end_all();
private:
	/// Flag which indicates whether CommonIO is used for IO mapping
  static int io_mapping;
	/// Integer of the number of nest CommonIO blocks that are buffered
  static int io_buffering;
	/// The number of calls to \a CommonIO::begin() that haven't ended
  static int begin_end_counter;
	/// The rank of the processor that is allowed to do debugging I/O
  static int IO_Rank;
	/// TODO
  static int tagging;
	/// TODO
  static int nref;
	/// Flag that indicates whetner 
  static int flush_flag;
	/// The number of I/O lines that have been printed
  static int seqNum;
	/// The rank of the current process
  static int Rank;
	/// The number of parallel processes
  static int Size;
	/// Sets up internal variables and returns an output stream
  static ostream& o_stream(const int flag);
	/// Output stream flag: 0 = common_cout, 1 = common_cerr
  static int stream_flag;
	/// If true, then try to print the rank header before next character
  static int header_flag;
	/// TODO
  static void IOflush();
	/// TODO
  static void flush_stream(strstream& stream, ostream* tmp);
	/// the common ofstream 
  static ofstream common_ofstr;
	/// Resets the values of the Map# streams based on the current state
  static void reset_map();
	/// the common cout stream
  static ostream* common_cout;
	/// the common cerr stream
  static ostream* common_cerr;
	/// the common cin stream
  static istream* common_cin;
	/// The C++ stream object used to process cout stream information
  static strstream StrCout;
	/// The C++ stream object used to process cerr stream information
  static strstream StrCerr;
	/// 'Temporary' pointers.
  static ostream* pStrCout;
	/// 'Temporary' pointers.
  static ostream* pStrCerr;
#ifndef SWIG
 * TODO.
inline UTILIB_API ostream& Flush(ostream& outstr)
CommonIO::flush();
if ((&outstr != &CommonIO::StrCout) && (&outstr != &CommonIO::StrCerr))
   outstr.flush();
return outstr;
#endif
#endif
// logEvent.H
 * \class logEvent
 * Routines for doing event logging/tracing of parallel codes using MPE.
#ifndef __logEvent_H
#define __logEvent_H
#ifdef __GNUC__
#pragma interface
#endif
#if defined(USING_MPI) && defined(DEBUGGING) && defined(MPE)
#include <values.h>
class logEvent
public:
	/// The global parameter of the logging level.
  CLASS_PARAMETER(eventLog);
	///
  enum { undefinedState = -MAXINT };
	/// Initializes the MPI event logging capability.
  static void init()  { MPE_Init_log(); };
	/**
	 * Opens an event file (event.alog or event.clog in the current default
	 * directory. Call after calling \c init() but before any
	 * \c log_xxx calls.
	 */
  static void open();
	/**
	 * Writes and closes the log file.
	 * This can be quite slow, depending on the system.
	 */
  static void close();
	/**
	 * Defines a state to desplay in the log file.
	 * \p descrip is the name.
	 * \p color is an X windows color for the visualizer to use.
	 */
  static int defineState(const char* description,const char* color);
	/// Indicate the start of a state (states can be nested).
  static void log_start(int stateNumber) { event(stateNumber*2); };
	/// Indicate the end of a state.
  static void log_end(int stateNumber)   { event(stateNumber*2 + 1); };
	/// Equivalent to \c log_start(stateNumber) followed by \c log_end(stateNumber).
  static void log_point(int stateNumber)
    {
      log_start(stateNumber);
      log_end(stateNumber);
    };
private:
	/// Log event \c eventNumber.
  static void event(int eventNumber) 
    { 
    };
	/// Number of states that can be logged.
  static int numberOfStates;
	/// Code that is executed if MPE logging is in use.
#define IF_LOGGING_COMPILED(arbitraryCode) arbitraryCode
	/// Executes \p action if the event log is greater or equal to \p level.
#define IF_LOGGING_EVENTS(level,action) \
   if (logEvent::eventLog() >= level) action
	/// Wraps a call to \c log_<how> using \p state if the logging level is greater or equal to \p level.
#define LOG_EVENT(level,how,state) \
   IF_LOGGING_EVENTS(level,logEvent::log_##how(state);)
	/// Wraps a call to \c log_<how> if \p cond is satisfied.
#define LOG_EVENT_CONDITIONAL(level,cond,how,state) \
   IF_LOGGING_EVENTS(level,if (cond) logEvent::log_##how(state);)
	/// Indicates that the logging macros are not empty.
#define EVENT_LOGGING_PRESENT 1
#else
#define IF_LOGGING_COMPILED(arbitraryCode)          /* Nothing */
#define IF_LOGGING_EVENTS(level,action)             /* Nothing */
#define LOG_EVENT(level,how,state)                  /* Nothing */
#define LOG_EVENT_CONDITIONAL(level,cond,how,state) /* Nothing */
#undef  EVENT_LOGGING_PRESENT
#endif
#endif
// mpiUtil.h
// Jonathan Eckstein
 * \class uMPI
 *  using MPI a little easier.
#ifdef __GNUC__
#pragma interface
#endif
#ifndef __mpiUtil_H
#define __mpiUtil_H
#ifdef USING_MPI
// To compile code for logging of all messages.
#ifdef EVENT_LOGGING_PRESENT
#define LOG_SEND(a,b,c,d)   if (messageLog()) logSend(a,b,c,d)
#define LOG_RECV(s)         if (messageLog()) logRecv(s)
#else
#define LOG_SEND(a,b,c,d)               // Nothing
#define LOG_RECV(s)                     // Nothing
#endif
class UTILIB_API uMPI 
public:
	/// The MPI communicator group used for communication.
  static MPI_Comm comm;
	/// The rank of the current process in \c comm.
  static int rank;
	/// The number of processes in \c comm.
  static int size;
	/**
	 * The rank of a single process that can do I/O, guaranteed to 
	 * always be the same value across all processors.
	 */
  static int ioProc;
	/// A flag that is \c TRUE if the current process can perform I/O.
  static int iDoIO;
	/// The error code from the previous MPI call.
  static int errorCode;
#ifdef EVENT_LOGGING_PRESENT
  CLASS_PARAMETER(messageLog);
	/// Log a send event.
  static void logSend(int dest,int tag,int count,MPI_Datatype t);
	/// Log a receive event.
  static void logRecv(MPI_Status* status);
#endif
	/// Returns \c TRUE if MPI is already running.
  static int running()
    {
      int running;
      MPI_Initialized(&running);
      return(running);
    };
	/**
 	 * Takes a buffer of length \p m and expands it to account for 
	 * possible wastage due to packing alignment.  This code is very
	 * conservative at present.
	 */
  static int packSlop(int m)
    {
      return 2*m + 32;
    };
	/// TODO.
  static int sizeOf(MPI_Datatype t);
	/// Initializes MPI.
  static void init(int* argcP,char*** argv, MPI_Comm comm_=MPI_COMM_WORLD);
	/// Cleans up and finishes MPI.
  static void done();
	/// Executes a synchronous barrier command.
  static void barrier()
    {
      errorCode = MPI_Barrier(comm);
      if (errorCode)
    }
	/// Executes a parallel reduction.
  static void reduce(void* sendbuf,void* recvbuf,int count,
		     MPI_Datatype datatype,MPI_Op op,int root)
    {
      errorCode = MPI_Reduce(sendbuf,recvbuf,count,datatype,op,root,
			     comm);
      if (errorCode)
    };
	/// Computes a parallel sum of integers.
  static int sum(int value,int root = ioProc)
    {
      int result = 0;
      errorCode = MPI_Reduce(&value,&result,1,MPI_INT,MPI_SUM,root,
			     comm);
      if (errorCode)
      return result;
    };
	/// Computes a parallel sum of doubles.
  static double sum(double value,int root = ioProc)
    {
      double result = 0;
      errorCode = MPI_Reduce(&value,&result,1,MPI_DOUBLE,MPI_SUM,root,
			     comm);
      if (errorCode)
      return result;
    };
	/// Computes a parallel maximization of integers.
  static int max(int value,int root = ioProc)
    {
      int result = 0;
      errorCode = MPI_Reduce(&value,&result,1,MPI_INT,MPI_MAX,root,
			     comm);
      if (errorCode)
      return result;
    };
	/// Computes a parallel maximization of doubles.
  static double max(double value,int root = ioProc)
    {
      double result = 0;
      errorCode = MPI_Reduce(&value,&result,1,MPI_DOUBLE,MPI_MAX,root,
			     comm);
      if (errorCode)
      return result;
    };
	/// Perform a broadcast.
  static void broadcast(void* buffer,int count,MPI_Datatype datatype,int root)
    {
      errorCode = MPI_Bcast(buffer,count,datatype,root,comm);
      if (errorCode)
    };
	/// Perform a reduction followed by a broadcast of the result.
  static void reduceCast(void* sendbuf,void* recvbuf,int count,
			 MPI_Datatype datatype,MPI_Op op)
    {
      reduce(sendbuf,recvbuf,count,datatype,op,0);
      broadcast(recvbuf,count,datatype,0);
    };
      
	/// TODO.
  static void isend(void* buffer,int count,MPI_Datatype datatype,int dest,
		    int tag,MPI_Request* request)
    {
      LOG_SEND(dest,tag,count,datatype);
      errorCode = MPI_Isend(buffer,count,datatype,dest,tag,comm,
			    request);
      if (errorCode)
    };
	/**
	 * Perform an Isend without a user-supplied request object.
	 * This method automatically frees the request object.
	 */
  static void isend(void* buffer,int count,MPI_Datatype datatype,int dest,
		    int tag)
    {
      MPI_Request request;
      isend(buffer,count,datatype,dest,tag,&request);
      requestFree(&request);
    };
	/// Perform an Send.
  static void send(void* buffer,int count,MPI_Datatype datatype,int dest,
		   int tag)
    {
      LOG_SEND(dest,tag,count,datatype);
      errorCode = MPI_Send(buffer,count,datatype,dest,tag,comm);
      if (errorCode)
    }
      
	/// Free a request object.
  static void requestFree(MPI_Request* request)
    {
      errorCode = MPI_Request_free(request);
      if (errorCode)
    };
	/// Perform an Issend.
  static void issend(void* buffer,int count,MPI_Datatype datatype,int dest,
		     int tag,MPI_Request* request)
    {
      LOG_SEND(dest,tag,count,datatype);
      errorCode = MPI_Issend(buffer,count,datatype,dest,tag,comm,
			     request);
      if (errorCode)
    };
	/// Perform an Irecv.
  static void irecv(void* buffer,int count,MPI_Datatype datatype,int source,
		    int tag,MPI_Request* request)
    {
      errorCode = MPI_Irecv(buffer,count,datatype,source,tag,comm,
			    request);
      if (errorCode)
    };
	/// Perform a Recv.
  static void recv(void* buffer,int count,MPI_Datatype datatype,int source,
		   int tag,MPI_Status* status)
    {
      errorCode = MPI_Recv(buffer,count,datatype,source,tag,comm,
			    status);
      if (errorCode)
      LOG_RECV(status);
    };
	/// Get the count from a data type.
  static int getCount(MPI_Status* status,MPI_Datatype datatype)
    {
      int count;
      errorCode = MPI_Get_count(status,datatype,&count);
      if (errorCode)
      return count;
    };
	/// Test a request, returning the result in argument \a flag.
  static void test(MPI_Request* request,int* flag,MPI_Status* status)
    {
      errorCode = MPI_Test(request,flag,status);
      if (errorCode)
#ifdef EVENT_LOGGING_PRESENT
      if (*flag)
	LOG_RECV(status);
#endif
    };
	/// Test a request, returning the result.
  static int test(MPI_Request* request,MPI_Status* status)
    {
      int flag;
      test(request,&flag,status);
      return flag;
    };
	/// Test a request, returning the result and ignoring the status.
  static int test(MPI_Request* request)
    {
      MPI_Status status;
      return test(request,&status);
    };
	/// Call Testsome.
  static int testsome(int incount, MPI_Request* request_array,
		int& outcount, int* array_of_indeces, MPI_Status* status_array)
    {
      errorCode = MPI_Testsome(incount,request_array,&outcount,
				array_of_indeces,status_array);
      if (errorCode != MPI_SUCCESS)
#ifdef EVENT_LOGGING_PRESENT
      for(int i=0; i<outcount; i++)
	LOG_RECV(status_array+i);
#endif
      return (outcount > 0);
    };
	/// Cancel a request.
  static void cancel(MPI_Request* request)
    {
#ifndef COUGAR
      errorCode = MPI_Cancel(request);
      if (errorCode)
#else
#endif
    };
	/// Wait on a request.
  static void wait(MPI_Request* request,MPI_Status* status)
    {
      errorCode = MPI_Wait(request,status);
      if (errorCode)
      LOG_RECV(status);
    };
	/// Cancel send requests.
  static void killSendRequest(MPI_Request* request);
	/// Cancel receive requests.
  static void killRecvRequest(MPI_Request* request);
#else
//  If no MPI, don't define anything except running(), which returns FALSE.
class uMPI 
public:
  static int running() { return FALSE; };
#endif
#endif
 * \file nicePrint.h
 * \author Jonathan Eckstein
 * Helper functions for printing.
#ifndef __nicePrint_h
#define __nicePrint_h
#ifdef __GNUC__
#pragma interface
#endif
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif
 * TODO.
int digitsNeededFor(double value);
 * TODO.
ostream& hyphens(ostream& stream,int n);
 * TODO.
 * TODO.
ostream& printPercent(ostream& stream,
		      double numerator, 
		      double denominator = 1);
#endif
// PackBuf.h
 * \class PackBuffer
 * A class that provides a facility for packing messages, using the MPI 
 * packing facilities. The \c PackBuffer class dynamically resizes the
 * internal buffer to contain enough memory to pack the entire object.  When 
 * deleted, the \c PackBuffer object deletes this internal buffer.
 * \class UnPackBuffer
 * A class that provides a facility for unpacking messages, using the MPI 
 * packing facilities.
#ifndef __PackBuf_h
#define __PackBuf_h
#ifdef __GNUC__
#pragma interface
#endif
typedef unsigned char unsigned_char;
typedef unsigned short unsigned_short;
typedef unsigned int unsigned_int;
typedef unsigned long unsigned_long;
//---------------------------------------------------------------------
// PackBuffer
//---------------------------------------------------------------------
class UTILIB_API PackBuffer {
public:
	/// Constructor, which allows the default buffer size to be set.
  PackBuffer(int size_=1024) {index=0; size=size_; buffer = new char [size_];}
	/// Desctructor.
  ~PackBuffer() {if (buffer) delete buffer;}
	/// Returns a pointer to the internal buffer that has been packed.
  const char* buf() {return buffer;}
	/// The number of bytes of packed data.
  int len() {return index;}
	/// Resets the buffer index in order to reuse the internal buffer.
  void reset() {index=0;}
	/// Pack one or more \b int's
  void pack(const int* data, const int num=1);
	/// Pack one or more \b unsigned \b int's
  void pack(const unsigned_int* data, const int num=1);
	/// Pack one or more \b long's
  void pack(const long* data, const int num=1);
	/// Pack one or more \b unsigned \b long's
  void pack(const unsigned_long* data, const int num=1);
	/// Pack one or more \b short's
  void pack(const short* data, const int num=1);
	/// Pack one or more \b unsigned \b short's
  void pack(const unsigned_short* data, const int num=1);
	/// Pack one or more \b char's
  void pack(const char* data, const int num=1);
	/// Pack one or more \b unsigned \b char's
  void pack(const unsigned_char* data, const int num=1);
	/// Pack one or more \b double's
  void pack(const double* data, const int num=1);
	/// Pack one or more \b float's
  void pack(const float* data, const int num=1);
	/// Pack one or more \b bool's
  void pack(const bool* data, const int num=1);
	/// Pack a \b int
  void pack(const int data) 		{pack(&data);}
	/// Pack a \b unsigned \b int
  void pack(const unsigned_int data)	{pack(&data);}
	/// Pack a \b long
  void pack(const long data) 		{pack(&data);}
	/// Pack a \b unsigned \b long
  void pack(const unsigned_long data)	{pack(&data);}
	/// Pack a \b short
  void pack(const short data) 		{pack(&data);}
	/// Pack a \b unsigned \b short
  void pack(const unsigned_short data)	{pack(&data);}
	/// Pack a \b char
  void pack(const char data) 		{pack(&data);}
	/// Pack a \b unsigned \b char
  void pack(const unsigned_char data)	{pack(&data);}
	/// Pack a \b double
  void pack(const double data) 		{pack(&data);}
	/// Pack a \b float
  void pack(const float data) 		{pack(&data);}
	/// Pack a \b bool
  void pack(const bool data) 		{pack(&data);}
protected:
	/// The internal buffer for packing
  char* buffer;
	/// The index into the current buffer
  int index;
	/// The total size that has been allocated for the buffer
  int size;
	/// Resizes the internal buffer
  void resize(const int newsize);
inline PackBuffer& operator<< (PackBuffer& buff, const int data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const unsigned_int data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const long data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const unsigned_long data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const short data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const unsigned_short data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const char data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const unsigned_char data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const double data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const float data)
	{buff.pack(data); return buff;}
inline PackBuffer& operator<< (PackBuffer& buff, const bool data)
	{buff.pack(data); return buff;}
//---------------------------------------------------------------------
// UnPackBuffer
//---------------------------------------------------------------------
class UTILIB_API UnPackBuffer {
public:
	/// Method that does the setup for the constructors
  void setup(char* buf_, int size_, int flag=0);
	/// Default constructor.
  UnPackBuffer() : buffer(0), own_flag(0)
	{setup(0,0,0);}
	/// Constructor that specifies the size of the buffer
  UnPackBuffer(int size_) : buffer(0), own_flag(0)
	{setup(new char [size_],size_,1);}
	/// Constructor that sets the internal buffer to the given array
  UnPackBuffer(char* buf_, int size_, int flag=0) : buffer(0), own_flag(0)
	{setup(buf_,size_,flag);}
	/// Destructor.
  ~UnPackBuffer() {if (buffer && own_flag) delete buffer;}
	/// Resizes the internal buffer
  void resize(const int newsize);
	/// Returns a pointer to the internal buffer
  const char* buf() {return buffer;}
	/// Returns the length of the buffer.
  int len() {return size;}
	/// Returns the number of bytes that have been unpacked from the buffer.
  int curr() {return index;}
	/// Resets the index of the internal buffer.
  void reset() {index=0;}
	/// Unpack one or more \b int's
  void unpack(int* data, const int num=1);
	/// Unpack one or more \b unsigned \b int's
  void unpack(unsigned_int* data, const int num=1);
	/// Unpack one or more \b long's
  void unpack(long* data, const int num=1);
	/// Unpack one or more \b unsigned \b long's
  void unpack(unsigned_long* data, const int num=1);
	/// Unpack one or more \b short's
  void unpack(short* data, const int num=1);
	/// Unpack one or more \b unsigned \b short's
  void unpack(unsigned_short* data, const int num=1);
	/// Unpack one or more \b char's
  void unpack(char* data, const int num=1);
	/// Unpack one or more \b unsigned \b char's
  void unpack(unsigned_char* data, const int num=1);
	/// Unpack one or more \b double's
  void unpack(double* data, const int num=1);
	/// Unpack one or more \b float's
  void unpack(float* data, const int num=1);
	/// Unpack one or more \b bool's
  void unpack(bool* data, const int num=1);
	/// Unpack a \b int
  void unpack(int& data) 		{unpack(&data);}
	/// Unpack a \b unsigned \b int
  void unpack(unsigned_int& data)	{unpack(&data);}
	/// Unpack a \b long
  void unpack(long& data) 		{unpack(&data);}
	/// Unpack a \b unsigned \b long
  void unpack(unsigned_long& data)	{unpack(&data);}
	/// Unpack a \b short
  void unpack(short& data) 		{unpack(&data);}
	/// Unpack a \b unsigned \b short
  void unpack(unsigned_short& data)	{unpack(&data);}
	/// Unpack a \b char
  void unpack(char& data) 		{unpack(&data);}
	/// Unpack a \b unsigned \b char
  void unpack(unsigned_char& data)	{unpack(&data);}
	/// Unpack a \b double
  void unpack(double& data) 		{unpack(&data);}
	/// Unpack a \b float
  void unpack(float& data) 		{unpack(&data);}
	/// Unpack a \b bool
  void unpack(bool& data) 		{unpack(&data);}
protected:
	/// The internal buffer for unpacking
  char* buffer;
	/// The index into the current buffer
  int index;
	/// The total size that has been allocated for the buffer
  int size;
	/// If \c TRUE, then this class owns the internal buffer
  int own_flag;
inline UnPackBuffer& operator>> (UnPackBuffer& buff, int& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, unsigned_int& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, long& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, unsigned_long& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, short& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, unsigned_short& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, char& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, unsigned_char& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, double& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, float& data)
	{buff.unpack(data); return buff;}
inline UnPackBuffer& operator>> (UnPackBuffer& buff, bool& data)
	{buff.unpack(data); return buff;}
//---------------------------------------------------------------------
// PackSize
//---------------------------------------------------------------------
int PackSize(const int& data, const int num=1);
int PackSize(const unsigned_int& data, const int num=1);
int PackSize(const long& data, const int num=1);
int PackSize(const unsigned_long& data, const int num=1);
int PackSize(const short& data, const int num=1);
int PackSize(const unsigned_short& data, const int num=1);
int PackSize(const char& data, const int num=1);
int PackSize(const unsigned_char& data, const int num=1);
int PackSize(const double& data, const int num=1);
int PackSize(const float& data, const int num=1);
int PackSize(const bool& data, const int num=1);
#endif // __PackBuf_h
// paramTable.H
 * \class parameter 
 *  Class that allows reading named numeric parameters from the command line
 *  via -<paramName>=<value> or from a file via -param=<file>.
 *  Note: for now the format of the parameter file is described in 
 *  \p utilib/src/io/paramTable.doc.
 * \author Jonathan Eckstein
#ifndef __paramTable_H
#define __paramTable_H
#ifdef __GNUC__
#pragma interface
#endif
class parameter
public:
	/// Returns the current value of the parameter.
  double operator()() { return value; };
	/**
	 * Processes the arguement list.
	 * Note: \p minArgs and \p maxArgs refer to the number of 
	 * command-line arguments that can \b not be parsed as parameters. If
	 * the number of such arguments is outside the range 
	 * [\p minArgs, \p maxArgs ], an error is signalled.
	 */
  static void readAll(int argc,char** argv,int minArgs = 0,int maxArgs = 1);
	///
  void changeValue(double newValue);
	///
  int hasBeenChanged() { return changeCounter > 0; };
	///
  static int howMany() { return numParameters; };
	///
  parameter(const char* name_,double minValue_,double value_,double maxValue_);
	///
  ~parameter();
	///
  enum { tableSize=101 };     // Define local constant.
private:
	///
  double     value;
	///
  double     maxValue;
	///
  double     minValue;
	///
  const char*      name;
	///
  int        changeCounter;
	///
  parameter* next;
	///
  parameter* prev;
	///
  static int numParameters;
	///
  static parameter* hashHeader[tableSize];
	///
  static unsigned int hash(const char* name_);
	///
  static parameter* lookup(const char* name_,int hashValue_);
	///
  static parameter* lookup(const char* name_) { return lookup(name_,hash(name_)); };
	///
  static void parseLine(int argc,char** arv,int minArgs = 0,int maxArgs = 1);
	///
  static void readFromFile(const char* fileName);
	///
  static double convert(const char* buffer, const char* errorKey);
#define CLASS_PARAMETER(name) \
   static parameter name
#define GLOBAL_PARAMETER(name) \
   extern parameter name
#define CLASS_PARAMETER_DEF(class,name,min,default,max) \
   parameter class::name(#name,min,default,max)
#define GLOBAL_PARAMETER_DEF(name,min,default,max) \
   parameter name(#name,min,default,max)
#endif
 * \file	linpack.h
 * Headers for linpack's fortran routines.
 * Note:  I've only done as many as I've needed here.
#ifdef __cplusplus
#endif
/** Chapter 3 **/
UTILIB_API void dpofa_ _((double* A, int* lda, int* n, int* info));
UTILIB_API void dpoco_ _((double* A, int* lda, int* n, double* rcond, double* Z, int* info));
/* A[lda, n]	-	Contains the symmetrix matrix whose factorization
				is to be computed.
   rcond	-	an estimate of the reciprocal condition.
   Z[n]		-	work space
   info		-	error conditions:
				0	A positive definite and successfully
						factored
				K>0	Leading submatrix of order K is not
						positive definite.
/** Chapter # **/
void dqrdc_ _((double* x, int* ldx, int* n, int* p, double* qraux,
		int* jpvt, double* work, int* job));
/* x[n,p]	-	matrix whose QR decomposition is computed
   jpvt[p]	-	array to control pivotting
   work[p]	-	work array (not referenced if job=0) 
   job		-	integer which initiates column pivotting.  If
				job=0, pivoting is not done.
   qraux[p]	-	contains info for recovering the orthogonal part
				of the decomposition
void dqrsl_ _((double* x, int* ldx, int* n, int* k, double* qraux,
		double* y, double* qy, double* qty, double* b,
		double* rsd, double* xb, int* job, int* info));
/* x[n,p]	-	the output array from dqrdc
   qraux[p]	-	output from dqrdc
   y[n]		-	??
   job		-	determines what is to be computed
				a != 0		qy computed
				b,c,d,or e !=0	qty computed
				c != 0		b computed
				d != 0		rsd computed
				e != 0		xb computed
   qy[n]	-	contains Qy
   qty[n]	-	contains Q'y
   b[p]		-	contains soln to ls problem |y - X_kb|
   rsd[n]	-	contains residual vector y - X_kb
   xb[n]	-	contains least squares approximation to Xb
   information	-	zero unless requested to compute B, and R is
				exactly singular.  In that case, INFO is the 
				index of the first zero diagonal elt of R.
/* Routine from LinPack p. 9.11 
   The params for this command are explained above.  The dqrst code
   automatically transforms the X matrix to column major order,
   so the user can treat this command like any other C routine. */
void dqrst _((double** x, int ldx, int n, int p, double* y, double tol,
                double* b, double* rsd, int* k, int* jpvt, double* qraux,
                double* work, int trans_flag));
/* Adaptation of dqrst which handles multiple regression problems */
void lsfit1 _((double** x, int ldx, int n, int p, double** y, int nregs,
                double tol, double** b, int* k, int trans_flag));
int lsfit2 _((double** x, int ldx, int n, int p, double** y, int nregs,
                double tol, double** b));
int lsfit2_nr _((double** x, int ldx, int n, int p, double** y, int nregs,
                double tol, double** b, double* w, double** v));
#ifdef __cplusplus
#endif
 * \file	_math.h
 * Defines and constants for numerical operations.
#ifndef ___math_h
#define ___math_h
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <math.h>
#else
#include <cmath>
#endif
/// DEFINE MATHEMATICAL CONSTANTS
#ifndef _MSC_VER
#include <values.h>
#else
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <limits.h>
#include <float.h>
#else
#include <climits>
#include <cfloat>
#endif
#define MAXINT INT_MAX
#define MAXDOUBLE DBL_MAX
#endif
#ifdef SOLARIS
#include <sunmath.h>
#endif
#ifdef _MSC_VER					/// THESE SHOULD BE UPDATED...
/// A definition for pi.
#define M_PI 3.14159265358979323846 
/// A definition for e.
#define M_E exp(1.0)
#endif
/// A definition for pi.
#ifndef PI
#define PI M_PI
#endif
 * \def MAXINT
 * A macro that defines the maximum integer value.  Not all systems seem
 * to have a built-in value for this.
#ifndef MAXINT
#define MAXINT (int)(~((int)0) ^ (1 << (sizeof(int)*8-1)))
#endif
/// 
/// OPERATIONS ON SIMPLE VALUES
#ifndef USING_STL
#ifdef min
#undef min
#endif
/// Return the minimum of two values.
template <class T, class V>
inline UTILIB_API T min(T x, V y)
{return ((x)<(y)? (x) : (y));}
#ifdef max
#undef max
#endif
/// Return the maximum of two values.
template <class T, class V>
inline UTILIB_API T max(T x, V y)
{return ((x)>(y)? (x) : (y));}
/// Swap two values.
template <class T>
inline UTILIB_API void swap(T& i, T& j)
{ T tmp = i; i = j; j = tmp;}
#else
#include <algorithm>
#endif
/// MISCELLANEOUS 
#ifdef __cplusplus
#endif
/// Compute the number of lines in file \a filename.
UTILIB_API int calc_filesize(char* filename);
 * Return the integer value of the rounded value of \a x.  
 * If the fractional part of \a x is less than 0.5, then \a x is
 * rounded down.  Otherwise, \a x is rounded up.
UTILIB_API int round _((double x));
/// Setup the data structures for \c bufexp.
UTILIB_API void setup_bufexp _((int tabsz, double xmin, double xmax));
/// Compute the exponential function using fast buffered interpolation.
UTILIB_API double bufexp _((double x));
#if defined(PARAGON) | defined(nCUBE2) | defined(RS6K) | defined(SGI) | defined(COUGAR)
/// Returns \c TRUE if \a x is infinite.
int isinf(double x);
/// Returns \c TRUE if \a x is not-a-number.
int isnan(double x);
/// Returns the value of 2^x.
double exp2(double x);
#endif
#if defined(PARAGON) | defined(nCUBE2) | defined(COUGAR)
/// Sets a char array \a b to null values.
void bzero(char* b, int length);
#endif
#ifdef __cplusplus
#endif
 * \def Exp(x)
 * A macro masks the 'exp' function, possibly replacing it with 'bufexp' to 
 * accelerate the calculation of 'exp'.
#ifdef BUFFERED_EXP
#define Exp(x)	bufexp(x)
#else
#define Exp(x)	exp(x)
#endif
#if defined(__BasicArray_h) && !defined(BasicArray_DEFN)
#define __math_h_NO_ARRAYS
#else
#ifndef __math_h_NO_ARRAYS
class BitArray;
#endif
#endif
#ifndef __math_h_NO_ARRAYS
/// OPERATIONS ON ARRAYS
/// Sum up the values in an array.
template <class T>
UTILIB_API T sum(const BasicArray<T>& vec)
T ans=0;
for (size_type i=0; i<vec.size(); i++)
  ans += vec[i];
return(ans);
 * Shuffle an array.
 * Shuffle performed is Algorithm P (Shuffling) from page 139 of
 * \if GeneratingLaTeX Knuth~\cite{Knu}. \endif
 * Only \a num values are shuffled into the * first \a num positions on 
 * the array.
template <class T>
UTILIB_API void shuffle(BasicArray<T>& vec, RNG* rng, size_type num)
Uniform urnd(rng);
T temp;
for (size_type i = 0; i<num; i++) {
  size_type j = Discretize(urnd(), i, vec.size()-1);
  temp = vec[j];
  vec[j] = vec[i];
  vec[i] = temp;
/// Shuffle a bit array using the given random number generator.
UTILIB_API void shuffle(BitArray& vec, RNG* rng=&default_rng);
/// Shuffle a basic array using the given random number generator.
template <class T>
inline UTILIB_API void shuffle(BasicArray<T>& vec, RNG* rng=&default_rng)
{shuffle(vec,rng,vec.size());}
 * Shuffle a subset of an array starting from \a start and ending at \a end - 1.
 * Within the range from \a start to \a end, the method operates like the
 * \c shuffle function.
template <class T>
UTILIB_API void subshuffle(BasicArray<T>& vec, RNG* rng, size_type start, 
		size_type end)
DUniform urnd(rng);
T temp;
for (size_type i = start; i<end; i++) {
  size_type j = urnd(i,end-1);
  temp = vec[j];
  vec[j] = vec[i];
  vec[i] = temp;
/// Compute the L_2 norm of the numerical array.
template <class T>
UTILIB_API double length(const BasicArray<T>& a)
double ans=0.0;
for (size_type i=0; i<a.size(); i++)
  ans += a[i]*a[i];
return sqrt(ans);
/// Compute the distance between two numerical arrays
template <class T>
UTILIB_API double dist(const BasicArray<T>& a, const BasicArray<T>& b)
double ans=0.0;
for (size_type i=0; i<a.size(); i++)
  ans += (a[i]-b[i])*(a[i]-b[i]);
return sqrt(ans);
/// Return the index of the minimal element of the array.
template <class T>
UTILIB_API size_type argmin(const BasicArray<T>& vector)
size_type i, temp=0;
if (vector.size() == 1)
   return(0);
for (i=1; i<vector.size(); i++)
  if (vector[i] < vector[temp])  temp=i;
return(temp);
/// Return the index of the maximal element of the array.
template <class T>
UTILIB_API size_type argmax(const BasicArray<T>& vector)
size_type i, temp=0;
if (vector.size() == 1)
   return(0);
for (i=1; i<vector.size(); i++)
  if (vector[i] > vector[temp])  temp=i;
return(temp);
/// Return the index of the median element of the array.
size_type argmedian(double* x, size_type n, int* ws, RNG* rng);
               
/// Return the index of the median element of the array.
template <class T>
UTILIB_API size_type argmedian(const BasicArray<T>& vector, RNG* rng=&default_rng)
T* tmp_array = (T*)&(vector[0]);
return argmedian( tmp_array, vector.size(), 0, rng );
/// Return the index of the median element of the array.
template <class T>
UTILIB_API size_type argmedian(const BasicArray<T>& vec, BasicArray<int>& ws, 
			RNG* rng=NULL)
{ return argmedian(vec.data(), vec.size(), ws.data(), rng); }
/// Return the minimal element of an array.
template <class T>
inline UTILIB_API T min(const BasicArray<T>& vec) 
{ return vec[argmin(vec)]; }
/// Return the maximal element of an array.
template <class T>
inline UTILIB_API T max(const BasicArray<T>& vec) 
{ return vec[argmax(vec)]; }
/// Return the median element of an array.
template <class T>
inline UTILIB_API T median(const BasicArray<T>& vec) 
{ return vec[argmedian(vec)]; }
/// Concatenate two arrays together
template <class T>
UTILIB_API BasicArray<T> concat(const BasicArray<T>& a, const BasicArray<T>& b)
BasicArray<T> ans(a.size() + b.size());
for (size_type i=0; i<a.size(); i++)
  ans[i] = a[i];
for (size_type j=a.size(); j<(a.size()+b.size()); j++)
  ans[j] = b[j-a.size()];
return(ans);
/// Compute the mean of an array
template <class T>
double mean(const BasicArray<T>& array)
double temp=0.0;
for (size_type i=0; i<array.size(); i++)
  temp += array[i];
return( temp/array.size() );
/// Compute the trimmed mean of an array
template <class T>
double trimmed_mean(BasicArray<T>& array, const double percent)
double temp=0.0;
sort(array);
size_type boundary = (size_type) floor(array.size() * percent);
for (size_type i=boundary; i<(array.size()-boundary); i++)
  temp += array[i];
return( temp/(array.size() - 2.0*boundary) );
/// Compute the variance of an array
template <class T>
double var(const BasicArray<T>& array, const int sampleflag=TRUE)
double array_mean = mean(array);
double temp=0.0;
for (size_type i=0; i<array.size(); i++)
  temp += (array[i] - array_mean) * (array[i] - array_mean);
if ((sampleflag == FALSE) || (array.size() == 1))
   return( temp / array.size() );
else
   return( temp / (array.size() - 1) );
/// Compute the MAD (mean absolute deviation) of an array, given workspace
template <class T>
double mad(BasicArray<T>& array, BasicArray<double>& work)
double meanval = mean(array);
for (size_type i=0; i<work.size(); i++)
  work[i] = fabs(array[i] - meanval);
return median(work);
/// Compute the MAD (mean absolute deviation) of an array
template <class T>
double mad(BasicArray<T>& array)
BasicArray<double> tmparray(array.size());
return mad(array,tmparray);
/// Apply the function \c val to the elements of \c vec.
template <class T>
UTILIB_API void lapply(BasicArray<T>& vec, double (*func)(T val))
for (size_type i=0; i<vec.size(); i++)
  vec[i] = (*func)(vec[i]);
/// Compute the inner product between two numerical arrays.
template <class T>
UTILIB_API double inner_product(const BasicArray<T>& v1,
                                const BasicArray<T>& v2)
double ans = 0.0;
for (size_type i=0; i<v1.size(); i++)
  ans += v1[i]*v2[i];
return ans;
/// OPERATIONS ON 2D ARRAYS AND MATRICES
/// Compute the means of the rows of a 2D array
template <class T>
NumArray<double> mean(const Basic2DArray<T>& matrix, const int stats_flag)
NumArray<double> temp(matrix.ncols());
temp = 0.0;
for (size_type j=0; j<matrix.nrows(); j++)
  for (size_type i=0; i<matrix.ncols(); i++)
    temp[i] += matrix[j][i];
if (stats_flag == TRUE)
     temp /= ((double) (matrix.nrows() - 1));
else
     temp /= ((double) matrix.nrows());
return( temp );
/// Compute the variances of the rows of a matrix
template <class T>
DoubleVector var(const Basic2DArray<T>& mat, const int sampleflag=TRUE)
DoubleVector array_mean;
return( var(mat, array_mean, sampleflag) );
/// Compute the variances of the rows of a 2D array, given the means
template <class T>
DoubleVector var(const Basic2DArray<T>& mat, BasicArray<double>& array_mean, 
							const int sampleflag=TRUE)
DoubleVector ans(mat.ncols());
array_mean &= mean(mat);
ans = 0.0;
for (size_type i=0; i<mat.nrows(); i++)
  for (size_type j=0; j<ans.size(); j++)
    ans[j] += ((mat[i][j] - array_mean[j]) * (mat[i][j] - array_mean[j]));
if ((sampleflag == FALSE) || (mat.nrows() == 1))
   ans /= (double) (mat.nrows());
else
   ans /= (double)(mat.nrows()-1);
return ans;
/// Return the minimal element of a 2D array.
template <class T>
UTILIB_API int min(const Basic2DArray<T>& mat)
T ans,tmp;
ans = mat[0][0];
for (size_type i=0; i<mat.nrows(); i++)
  for (size_type j=0; j<mat.ncols(); j++) {
    tmp = mat[i][j];
    if (tmp < ans) ans=tmp;
    }
return ans;
/// Return the maximal element of a 2D array.
template <class T>
UTILIB_API T max(const Basic2DArray<T>& mat)
T ans,tmp;
ans = mat[0][0];
for (size_type i=0; i<mat.nrows(); i++)
  for (size_type j=0; j<mat.ncols(); j++) {
    tmp = mat[i][j];
    if (tmp > ans) ans=tmp;
    }
return ans;
/// Return the sum of the elements of a 2D array.
template <class T>
UTILIB_API T sum(const Basic2DArray<T>& mat)
T ans;
ans = 0;
for (size_type i=0; i<mat.nrows(); i++)
  for (size_type j=0; j<mat.ncols(); j++)
    ans += mat[i][j];
return ans;
/// Scale the rows of a 2D array by \a a.
template <class T>
void rowscale(Basic2DArray<T>& a)
double tmp;
size_type j,i;
for (i=0; i<a.nrows(); i++) {
  tmp = 0.0;
  for (j=0; j<a.ncols(); j++)
    tmp += a[i][j];
  if (tmp != 0.0)
     for (j=0; j<a.ncols(); j++)
       a[i][j] /= tmp;
 * Compute the Cholesky decomposition of \a A.
 * This code assumes that \a A is symmetric positive definite.  It generates
 * a lower triangular \a G s.t. A = G*G'. This code assumes that the memory in 
 * \a G has been allocated contiguously.
UTILIB_API int cholesky (DoubleMatrix& A, DoubleMatrix& G, int n);
#endif // __math_h_NO_ARRAYS
#endif
// pyutilib.h
// This header file defines the basic hooks needed to add modules
// that augment the module defined by pyutilib
#ifndef __pyutilib_h
#define __pyutilib_h
#ifdef __cplusplus
#endif
void swig_add_module(char *name, void (*initfunc)());
void augment_pyutilib_modules();
int python_main(int argc, char **argv);
#ifdef __cplusplus
#endif
#endif
 * \file	compare.h
 * Header for comparison routines.
#ifndef __compare_h
#define __compare_h
template <class T>
int compare(const T& x, const T& y)
if (x<y) return -1;
if (x>y) return 1;
return 0;
#endif
 * \file	sort.h
 * Header for sort routines that can be used by C++.
#ifndef __sort_h
#define __sort_h
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <stdlib.h>
#else
#include <cstdlib>
#endif
#ifdef __cplusplus
#endif
 * \def SORT_VOID
 * `VOID' type used to pass in the array for sorting.
 * \def COMP_VOID
 * The pointer type that is passed into the comparison function.
 * \def SORT_RETVAL
 * The return type for the sorting routine.
 * \def SORT_RETURN
 * The return value used in the source files for the normal termination.
 * \def SORT_ARGS
 * The argument specification for a sorting routine.
#if defined(SUNOS)
#ifdef __GNUC__
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	int
#define SORT_RETURN	0
#define SORT_ARGS (SORT_VOID* base, long unsigned int nel, long unsigned int width, \
                                compare_fn_type compare )
#else
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, int nel, int width, \
                                compare_fn_type compare )
#endif
#endif
#if defined(SGI)
#ifdef __GNUC__
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	void
#define SORT_RETURN	0
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#else
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#endif
#endif
#if defined(SOLARIS)
#if defined(__GNUC__)
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#else
#define SORT_VOID	void
#define COMP_VOID	const void
#define SORT_RETVAL	void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, unsigned int nel, unsigned int width, \
                                compare_fn_type compare )
#endif
#endif
#ifdef PARAGON
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif COUGAR
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif OSF
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif CPLANT
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif HPUX
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif UWIN
#ifdef __GNUC__
/* TODO */
#else
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#endif
#elif _MSC_VER
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif LINUX
#define SORT_VOID       void
#define COMP_VOID       __const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#elif RS6K
#define SORT_VOID       void
#define COMP_VOID       const void
#define SORT_RETVAL     void
#define SORT_RETURN	
#define SORT_ARGS (SORT_VOID* base, size_t nel, size_t width, \
                                compare_fn_type compare )
#endif
#ifdef __cplusplus
#endif
/** A typedef for generic comparison functions used in C */
typedef int (*compare_fn_type)(COMP_VOID*,COMP_VOID*);
#ifdef __cplusplus
#endif
/** Functional form of a sorting routine. */
#define SORT_FORM	SORT_RETVAL (*) SORT_ARGS
#ifdef __cplusplus
#endif
/** Insertion sort. */
SORT_RETVAL   ins_sort _( SORT_ARGS );
/** Heap sort. */
SORT_RETVAL  heap_sort _( SORT_ARGS );
/** quick sort. */
SORT_RETVAL quick_sort _( SORT_ARGS );
/** Merge sort. */
SORT_RETVAL merge_sort _( SORT_ARGS );
/** Shell sort. */
SORT_RETVAL shell_sort _( SORT_ARGS );
/** Integer comparison used for sorting. */
UTILIB_API int compare_int _((COMP_VOID*, COMP_VOID*));
/** Float comparison used for sorting. */
UTILIB_API int compare_float _((COMP_VOID*, COMP_VOID*));
/** Double comparison used for sorting. */
UTILIB_API int compare_double _((COMP_VOID*, COMP_VOID*));
 * Misc sorting utilities
 * Fills the array \a ndx with the vector of indeces in order.
 * ndx[i] is the index for the element of \a base with rank i.
UTILIB_API void orderx _((int *ndx, int n, SORT_VOID* base, int width, 
	compare_fn_type compar, SORT_FORM));
 * Fills the array \a rank_vec with the rank of the elements in the original 
 * array.  This function uses the index array generated by \c orderx.
UTILIB_API void rank _((int* ndx_vec, int* rank_vec, int n));
 * TODO.
void order_k _((SORT_VOID* base, int nel, int width, compare_fn_type compar,
                                int k));
 * TODO.
void order_ki _((SORT_VOID* base, int nel, int width,
                                compare_fn_type compar, int k, int* ndx));
#ifdef __cplusplus
/** Sort an array using an implicitly defined comparison function */
template <class T>
inline UTILIB_API void sort(BasicArray<T>& array)
{ qsort((SORT_VOID*)(vec.data()), array.size(), (int)sizeof(T), compare); }
/** Sort an array using an explicit comparison function */
template <class T>
inline UTILIB_API void sort(BasicArray<T>& array, compare_fn_type compare_fn)
{ qsort((SORT_VOID*)(array.data()), array.size(), (int)sizeof(T), compare_fn); }
/** Order an array. */
template <class T>
inline UTILIB_API void order(BasicArray<int>& ndx, const BasicArray<T>& v,
				compare_fn_type compare_fn)
orderx(ndx.data(), ndx.size(), (SORT_VOID*)(v.data()), (int)sizeof(T),
					compare_fn,qsort);
/** Rank an array. */
template <class T>
inline UTILIB_API void rank(BasicArray<int>& rvec, BasicArray<T>& v,
						compare_fn_type compare_fn)
BasicArray<int> ovec(v.size());
order(ovec, v, compare_fn);
rank(ovec.data(), rvec.data(), rvec.size());
/** Sort an integer array. */
inline UTILIB_API void sort(BasicArray<int>& array)
{ sort(array, compare_int); }
/** Sort a float array. */
inline UTILIB_API void sort(BasicArray<float>& array)
{ sort(array, compare_float); }
/** Sort a double array. */
inline UTILIB_API void sort(BasicArray<double>& array)
{ sort(array, compare_double); }
/** Order an integer array. */
inline UTILIB_API void order(BasicArray<int>& ndx, BasicArray<int>& array)
{ order(ndx, array, compare_int); }
/** Order a float array. */
inline UTILIB_API void order(BasicArray<int>& ndx, BasicArray<float>& array)
{ order(ndx, array, compare_float); }
/** Order a double array. */
inline UTILIB_API void order(BasicArray<int>& ndx, BasicArray<double>& array)
{ order(ndx, array, compare_double); }
/** Rank an integer array. */
inline UTILIB_API void rank(BasicArray<int>& ndx, BasicArray<int>& array)
{ rank(ndx, array, compare_int); }
/** Rank a float array. */
inline UTILIB_API void rank(BasicArray<int>& ndx, BasicArray<float>& array)
{ rank(ndx, array, compare_float); }
/** Rank a double array. */
inline UTILIB_API void rank(BasicArray<int>& ndx, BasicArray<double>& array)
{ rank(ndx, array, compare_double); }
#endif
#endif
 * \file	alloc.h
 * Header for generic allocation routines.
 * These routines are derived from similar methods in Numerical Recipies in
 * C.  These routines have largely been supplanted by the \c BasicArray 
 * class and its derived classes.  However, on occassion I find that I _really_
 * need to program with C, and these come in handy.  For that reason, these
 * should probably be better documented, but not right now...
 * \author William E. Hart
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <stdio.h>
#include <stdlib.h>
#else
#include <cstdio>
#include <cstdlib>
#endif
/* vector\matrix allocate statements */
#define vector(nl,nh)			dvector(nl,nh)
#define matrix(nrl,nrh,ncl,nch)		dmatrix(nrl,nrh,ncl,nch)
#define array(nrl,nrh,ncl,nch,nzl,nzh)	darray(nrl,nrh,ncl,nch,nzl,nzh)
#define fvector(nl, nh)	\
		(float *) generic_make_vector(nl,nh,sizeof(float))
#define ivector(nl, nh)	\
		(int *) generic_make_vector(nl,nh,sizeof(int))
#define dvector(nl, nh)	\
		(double *) generic_make_vector(nl,nh,sizeof(double))
#define fmatrix(nrl, nrh, ncl, nch) \
		(float **) generic_make_matrix(nrl,nrh,ncl,nch,sizeof(float))
#define imatrix(nrl, nrh, ncl, nch) \
		(int **) generic_make_matrix(nrl,nrh,ncl,nch,sizeof(int))
#define dmatrix(nrl, nrh, ncl, nch) \
		(double **) generic_make_matrix(nrl,nrh,ncl,nch,sizeof(double))
#define farray(nrl, nrh, ncl, nch, nzl, nzh) \
		(float ***) generic_make_array(nrl,nrh,ncl,nch,nzl,nzh, \
							sizeof(float))
#define iarray(nrl, nrh, ncl, nch, nzl, nzh) \
		(int ***) generic_make_array(nrl,nrh,ncl,nch,nzl,nzh, \
							sizeof(int))
#define darray(nrl, nrh, ncl, nch, nzl, nzh) \
		(double ***) generic_make_array(nrl,nrh,ncl,nch,nzl,nzh, \
							sizeof(double))
/* vector\matrix free statements */
#define free_vector(v,nl,nh)			free_dvector(v,nl,nh)
#define free_matrix(v,nrl,nrh,ncl,nch)		free_dmatrix(v,nrl,nrh,ncl,nch)
#define free_array(v,nrl,nrh,ncl,nch,nzl,nzh)	free_darray(v,nrl,nrh,ncl,nch,nzl,nzh)
#define free_fvector(v, nl, nh) \
		generic_free_vector((VOID *) v,nl,nh,sizeof(float))
#define free_ivector(v, nl, nh) \
		generic_free_vector((VOID *) v,nl,nh,sizeof(int))
#define free_dvector(v, nl, nh) \
		generic_free_vector((VOID *) v,nl,nh,sizeof(double))
#define free_fmatrix(v, nrl, nrh, ncl, nch) \
		generic_free_matrix((VOID **) v,nrl,nrh, ncl, nch,sizeof(float))
#define free_imatrix(v, nrl, nrh, ncl, nch) \
		generic_free_matrix((VOID **) v,nrl,nrh, ncl, nch,sizeof(int))
#define free_dmatrix(v, nrl, nrh, ncl, nch) \
		generic_free_matrix((VOID **) v,nrl,nrh,ncl, nch,sizeof(double))
#define free_farray(v, nrl, nrh, ncl, nch, nzl, nzh) \
		generic_free_array((VOID ***) v,nrl,nrh, ncl, nch,nzl,nzh,\
						sizeof(float))
#define free_iarray(v, nrl, nrh, ncl, nch, nzl, nzh) \
		generic_free_array((VOID ***) v,nrl,nrh, ncl, nch,nzl,nzh,\
						sizeof(int))
#define free_darray(v, nrl, nrh, ncl, nch, nzl, nzh) \
		generic_free_array((VOID ***) v,nrl,nrh, ncl,nch,nzl,nzh,\
						sizeof(double))
/* matrix transpose statements */
#define transpose_fmatrix(m, nrl, nrh, ncl, nch) \
	(float **) generic_transpose_matrix((VOID **) m,nrl,nrh, ncl, nch,\
				sizeof(float))
#define transpose_imatrix(m, nrl, nrh, ncl, nch) \
	(int **) generic_transpose_matrix((VOID **) m,nrl,nrh, ncl, nch,\
				sizeof(int))
#define transpose_dmatrix(m, nrl, nrh, ncl, nch) \
	(double **) generic_transpose_matrix((VOID **)m,nrl,nrh, ncl, nch,\
				sizeof(double))
/** EXTERNS **/
#if defined(__cplusplus)
#endif
#if defined(__STDC__) || defined(__cplusplus)
VOID	*generic_make_vector(int nl, int nh, unsigned size);
VOID	**generic_make_matrix(int nrl, int nrh, int ncl, int nch, 
			unsigned size);
VOID	***generic_make_array(int nrl, int nrh, int ncl, int nch, int nzl, 
			int nzh, unsigned size);
void	generic_free_vector(char* v, int nl, int nh, unsigned size);
void	generic_free_matrix(char** v, int nrl, int nrh, int ncl, int nch, 
			unsigned size);
void	generic_free_array(char*** v, int nrl, int nrh, int ncl, int nch, 
			int nzl, unsigned size);
VOID 	**generic_transpose_matrix(VOID **matrix, int nrl, int nrh, int ncl, 
			int nch, unsigned size);
int print_ivector(int* v, int nl, int nh, FILE* fp);
int print_fvector(float* v, int nl, int nh, FILE* fp);
int print_dvector(double* v, int nl, int nh, FILE* fp);
int print_imatrix(int** v, int nrl, int nrh, int ncl, int nch, FILE* fp);
int print_fmatrix(float** v, int nrl, int nrh, int ncl, int nch, FILE* fp);
int print_dmatrix(double** v, int nrl, int nrh, int ncl, int nch, FILE* fp);
int print_farray(float*** v, int nrl, int nrh, int ncl, int nch, int nzl,
						int nzh, FILE* fp);
int read_ivector(int* v, int nl, int nh, FILE* fp);
int read_dvector(double* v, int nl, int nh, FILE* fp);
int read_fvector(float* v, int nl, int nh, FILE* fp);
int read_dmatrix(double** v, int nrl, int nrh, int ncl, int nch, FILE* fp);
#else
extern VOID 	*generic_make_vector();
extern VOID	**generic_make_matrix();
extern VOID	***generic_make_array();
extern void	generic_free_vector();
extern void	generic_free_matrix();
extern void	generic_free_array();
extern VOID	**generic_transpose_matrix();
extern int	print_ivector();
extern int	print_fvector();
extern int	print_dvector();
extern int	print_imatrix();
extern int	print_fmatrix();
extern int	print_dmatrix();
extern int	print_farray();
extern int 	read_ivector();
extern int 	read_dvector();
extern int 	read_fvector();
extern int	read_dmatrix();
#endif
#ifdef __cplusplus
#endif
#ifndef __cplusplus
#define new(type)		(type *) malloc((size_t) sizeof( type ))
#define new_array(type, n) 	(type*) malloc((size_t) sizeof(type)*n)
#endif
 * \file	Boolean.h
 * My stab at defining a boolean type.  Unfortunately, compilers are
 * inconsistent with the definition of booleans right now, so I'm not using 
 * this in practice.  Hopefully, this will be resolved in ANSI C++.
 * Note: \c TRUE and \c FALSE are also defined in \c _generic.h.
 * \author William E. Hart
#ifndef __Boolean_h
#define __Boolean_h 
#ifdef __GNUG__
#include <bool.h>
#endif
#ifdef TRUE
#undef TRUE
#undef FALSE
#endif
#ifdef true
#undef true
#undef false
#endif
enum bool { FALSE = 0, false = 0, TRUE = 1, true = 1 };
#if defined(__cplus_plus)
#include <iostream.h>
inline UTILIB_API ostream& operator<<(ostream& os, const bool val)
{ os << (int)val; return os; }
inline UTILIB_API istream& operator>>(istream& is, bool& val)
{ int tmp; is >> tmp; val = (bool) tmp; return is; }
#endif
#endif
 * \file	errmsg.h
 * \author 	William E. Hart
 * This header defines macros and functions that can be used to notify
 * the user of errors, as well as abort or exit from some code.
 * These error facilites are designed to be compileable into C or C++ code.
 * However, the code that is executed calls a C++-compiled routine that
 * sends its output to \c ucout.  Consequently, these routines can only be
 * used for code that ultimately gets compiled by C++.  This is unfortunate,
 * but necessary because of the incompatability between \c stdout and \c ucout.
#ifndef __errmsg_h
#define __errmsg_h
/** Write a warning message. */
#define Warning(str)  DoWarning(__FILE__,__LINE__,str);
/** Write a warning message and return with value \c ERR. */
#define ErrReturn(str) {Warning(str); return ERR;}
/** Write a warning message and abort. */
#define ErrAbort(str) DoErrAbort(__FILE__,__LINE__,str);
/** Write a warning message and exit. */
#define ErrExit(str)  DoErrExit(__FILE__,__LINE__,str);
#if defined(__cplusplus)
#endif
/** Used to compose a message, using the format specified by \a string. */
UTILIB_API char* errmsg(const char* string, ...);
/** Call \c errmsg_abort to indicate that all messages cause aborts. */
UTILIB_API void errmsg_abort(const int flag);
typedef void (*null_fn_type)(void);
/** Call \c errmsg_exit_fn to indicate that exit and abort calls are preceded by
	a call to a user-provided exit function. */
UTILIB_API void errmsg_exit_fn(null_fn_type fn);
/** Create a warning about an error in \a file at line \a line, printing string \a str */
UTILIB_API void DoWarning(const char* file , const int line , const char* str);
/** Print an error in \a file at line \a line, printing string \a str and then abort. */
UTILIB_API void DoErrAbort(const char* file, const int line, const char* str);
/** Print an error in \a file at line \a line, printing string \a str and then exit. */
UTILIB_API void DoErrExit(const char* file, const int line, const char* str);
#if defined(__cplusplus)
#endif
#endif
 * \file	general.h
 * This header defines macros that provide a simple, C-based method for
 * handling flags. This macro-based approach works very well for C 
 * code, though it can certainly be done better for C++ code.
 * \author Anonymous
#ifndef __general_h
#define __general_h
/** 
 * \def DO_STANDARD_COMMAND_LINE(stmts)
 * Processes argv[1..argc-1] according to the (semicolon-separated) 
 * statements in \a stmts.  Possible statements include 
 *  - \c SIMPLE_FLAG_OPTN
 *  - \c FLAG_OPTN
 *  - \c SIMPLE_CFLAG_OPTN
 *  - \c CFLAG_OPTN
 *  - \c DATA_OPTN
 *  - \c DATA_OPTN2
 *  - \c REQ_ARG
 *  - \c OPT_ARG
 *  - \c NON_SWITCH
 *  - \c FREE_ARGS
 *  - \c FREE_ARGS_CONT
 *  - \c ANY_OPTION
 * In case an error is detected, an error message is constructed from
 * the flag names and descriptive text, and the program exits
 * abnormally after printing the message.  Within one of the statements,
 * the programmer can cause such an error message and termination with
 * the macro \c COMMAND_LINE_ERROR.
 * \def SIMPLE_FLAG_OPTN(s,var)
 * Sets \a var to \c TRUE on encountering the flag -s (s is an unquoted 
 * string of letters and digits).
 * \def FLAG_OPTN(s,stmt)
 * Executes \a stmt on encountering -s.
 * \def SIMPLE_CFLAG_OPTN(s,var) 
 * Like \c SIMPLE_FLAG_OPTN but requires \a s to be a single character and 
 * allows multiple flags to be concatenated (as in ls -AF).
 * \def CFLAG_OPTN(s,stmt)
 * Like \c FLAG_OPTN but requires \a s to be a single character and allows
 * multiple flags to be concatenated (as in ls -AF).
 * \def DATA_OPTN(s,desc,stmt)
 * Assumes a switch of the form -sdata or -s data, and executes \a stmt 
 * with _OPTION_ set to the start of the data string.  The \a desc is used as 
 * \def DATA_OPTN2(s,desc,stmt1,stmt2)
 * Assumes a switch of the form -sdata1 data2 or -s data1 data2, and 
 * executes \a stmt1 with _OPTION_ set to the start of the data string and 
 * \a stmt2 with _OPTION_ set to the start of the NEXT data string.  The 
 * \def REQ_ARG(desc,stmt)
 * set to the argument.
 * \def OPT_ARG(desc,stmt)
 * \c REQ_ARG, this is an optional argument.
 * \def NON_SWITCH(desc,stmt)
 * Executes \a stmt for the rest of the arguments.  Here, \a desc is used 
 * \def FREE_ARGS_CONT()
 * Ends the argument processing if the given flag is found.  The \a argc and 
 * \a argv arguments are set so \a argv[1] has the first free argument.
 * \def FREE_ARGS()
 * Ends the arguement processing by setting the \a argc and \a argv arguments.
 * These are set so \a argv[0] has the first free argument.
 * \def ANY_OPTION(desc,stmt)
 * Executes \a stmt for any argument.  The \a desc is as for NON_SWITCH.  
 * _OPTION_ is set to the argument.
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#else
#include <cstring>
#include <cstdlib>
#include <cstdio>
#endif
#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	1
#endif
 * \def PPRINT_DO_COMMAND
 * If this macro is defined, then the '-h' flag prints the 
 * argument list in a nice, multiline format.  Otherwise, the argument list
 * is printed in a compact format on one line.
#ifdef PPRINT_DO_COMMAND
#else
#endif
      ACTION INDEX
	0 - Process flags
	1 - ERR
	2 - Used to make CFLAGS
	3 - Used to print out errors
	4 - Used to print out errors
	5 - Used to print out errors
	6 - Process required arguments
	7 - Exit the processing
#define SIMPLE_FLAG_OPTN(string,var) \
  FLAG_OPTN(string, (var) = TRUE)
#define FLAG_OPTN(string,stmt) \
  if (__ACTION__ == 0) { \
      {stmt;} \
      continue; \
    } \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr);  \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define CFLAG_OPTN(char,stmt) \
  if (__ACTION__ == 0 && _OPTION_[1] == (#char)[0]) { \
    __ACTION__ = 2; \
    _OPTION_ += 1; \
  }  \
  if (__ACTION__ == 2 && _OPTION_[0] == (#char)[0]) { \
    {stmt;} \
    continue; \
  } else if (__ACTION__ == 1) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    __ACTION__ = 3; \
  } else if (__ACTION__ == 3) { \
    (void) fputs(#char, stderr); \
  } else if (__ACTION__ == 5) { \
    __ACTION__ = 4; \
#define SIMPLE_CFLAG_OPTN(char,var) \
  CFLAG_OPTN(char, (var) = 1)
#define DATA_OPTN(string,desc,stmt) \
  if (__ACTION__ == 0 \
      __i__ += 1; \
      if (__i__ >= argc) __ACTION__ = 1; \
      _OPTION_ = argv[__i__]; \
    } \
    if (__ACTION__ != 1) {stmt;} \
    continue; \
  } else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define DATA_OPTN2(string,desc,stmt1,stmt2) \
  if (__ACTION__ == 0 \
      __i__ += 1; \
      if (__i__ >= argc) __ACTION__ = 1; \
      _OPTION_ = argv[__i__]; \
    } \
    if (__ACTION__ != 1) { \
	stmt1; \
	__i__ += 1; \
	if (__i__ >= argc) \
	   __ACTION__ = 1; \
	else { \
	   _OPTION_ = argv[__i__]; \
	   stmt2; \
	   } \
	} \
    continue; \
  } else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define NON_SWITCH(desc,stmt) \
  if (__ACTION__ == 6) { \
     while (__i__ < argc) { \
       _OPTION_ = argv[__i__]; \
       stmt; \
       __i__++; \
       } \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define FREE_ARGS_CONT() \
  if (__ACTION__ == 6) { \
     int i; \
     char* tmp = argv[0];\
     for (i=1; i<__i__; i++) \
       argv++; \
     argv[0] = tmp;\
     argc -= __i__-1; \
     __ACTION__ = 7; \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) \
    (void) fputs(DO_COMMAND_EOLN, stderr);
#define FREE_ARGS() \
  if (__ACTION__ == 6) { \
     int i; \
     for (i=1; i<__i__; i++) \
       argv++; \
     argc -= __i__-1; \
     __ACTION__ = 7; \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define REQ_ARG(desc,stmt) \
  if (__ACTION__ == 6) { \
    if (__i__ >= argc) { \
       __ACTION__ = 1; \
       continue; \
    } \
    stmt; \
    __i__ += 1; \
    if (__i__ < argc) \
       _OPTION_ = argv[__i__]; \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB, stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define OPT_ARG(desc,stmt) \
  if ((__ACTION__ == 6) && (__i__ < argc)) { \
    stmt; \
    __i__ += 1; \
    if (__i__ < argc) \
       _OPTION_ = argv[__i__]; \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define ANY_OPTION(desc,stmt) \
  if (__ACTION__ == 0) { \
    stmt; \
    continue; \
  } \
  else if (__ACTION__ == 1 || __ACTION__ == 4) { \
    (void) fputs(DO_COMMAND_TAB,stderr); \
    (void) fputs(DO_COMMAND_EOLN, stderr); \
#define COMMAND_LINE_ERROR { __ACTION__ = 1; continue;}
#define DO_STANDARD_COMMAND_LINE(stmts) \
  { \
    int __i__; \
    int __ACTION__; \
    char *_OPTION_ = NULL; \
    __i__ = 0; \
    __ACTION__ = 0; \
    while (1) { \
      if (__ACTION__ == 2) { \
        _OPTION_ += 1; \
        if (_OPTION_[0] == '\0') __ACTION__ = 0; \
      } \
      if ((__ACTION__ == 0) || (__ACTION__ == 6)) { \
        __i__ += 1; \
        if (__i__ >= argc) \
	   __ACTION__ = 6; \
	else \
           _OPTION_ = argv[__i__]; \
      } \
      if (__ACTION__ == 0 && _OPTION_[0] != '-') \
         __ACTION__ = 6; \
      stmts; \
      if (__ACTION__ == 6) {\
        if (__i__ < argc) { \
          __ACTION__ = 1; \
          continue; \
        } \
        else \
          break; \
      } \
      if (__ACTION__ == 7) \
         break; \
      if (__ACTION__ == 1 || __ACTION__ == 4) { \
        exit(__ACTION__); \
      } \
      if (__ACTION__ == 3) { \
        (void) fputs(DO_COMMAND_EOLN, stderr); \
        __ACTION__ = 5; \
      } else { \
         __ACTION__ = 1; \
      } \
    } \
#endif
 * \file _generic.h
 * Defines and typedefs used everywhere.
#ifdef CPLANT
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <stdio.h>
#else
#include <cstdio>
#endif
#endif
#ifndef _GENERIC_H
#ifdef _GNUG_
#pragma once
#endif
#define _GENERIC_H
#include <sys/types.h>
 * \def PAUSE
 * A macro that waits for the user to hit a key.
#define PAUSE()	fflush(stdout); while(fgetc(stdin) == EOF);
 * generic defines
 * \def BUF_SIZE
 * A default size for buffers
#ifndef BUF_SIZE
#define BUF_SIZE	256
#endif
 * \def ERR
 * The default value of error values.
#ifndef ERR
#define ERR		-999
#endif
 * \def OK
 * Value used to indicate that an operation worked.
#ifndef OK
#define OK		0
#endif
 * \def TRUE
 * The boolean value for \i true.
#ifndef TRUE
#define TRUE		1
#endif
 * \def FALSE
 * The boolean value for \i false.
#ifndef FALSE
#define FALSE		0
#endif
 * \def ON
 * Used to incidate the \i on state.
#ifndef ON
#define ON		1
#endif
 * \def OFF
 * Used to incidate the \i off state.
#ifndef OFF
#define OFF		0
#endif
 * \def YES
 * Used to incidate a \i yes response.
#ifndef YES
#define YES		1
#endif
 * \def NO
 * Used to incidate a \i no response.
#ifndef NO
#define NO		0
#endif
 * \def NULL
 * Defines the value of empty pointers.
#ifdef NULL
#undef NULL		/* Always override the definition of NULL */
#endif
#define NULL		0
 * \def EOF
 * The end-of-file value.
#ifndef EOF
#define EOF		(-1)
#endif
#ifdef DEBUG			/* Debug defines to see if conflicts exist */
#define TRUE	1
#define FALSE	0
#define OK	0
#define ON	1
#define OFF	0
#define YES	1
#define NO	0
#define NULL	0
#define EOF	(-1)
#define ERR	-999
#endif
#if !defined(__STDC__) && !defined(__cplusplus)
 * \typedef size_t
 * The typedef for \a size_t arguments.
#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif
#else 
#if !defined(__cplusplus) || defined(NON_ANSI)
#include <stddef.h>
#else
#include <cstddef>
#endif
#endif
 * \typedef VOID
 * The void type is a \a char in standard C.
#ifndef VOID
typedef char VOID;
#endif
 * \def _(args)
 * Used to provide a consistent definition for non-ansi C and ansi C.
#if defined(__STDC__) || defined(__cplusplus)
#define _(args) args
#else
#define _(args) ()
#endif
 * \enum EnumDataOwned
 * Ownership categories for objects with reference counts.
#ifndef _ENUMDATAOWNED_
#define _ENUMDATAOWNED_
enum EnumDataOwned
  DataNotOwned=0,	/**< Data owned by some other object */
  AcquireOwnership=1,	/**< Data originally copied from another object */
  AssumeOwnership=2	/**< Data pointer points to another object's data */
#endif
 * \typedef size_type
 * Used to provide a consistent definition of the size_t type.
typedef size_t size_type;
#endif
// memdebug.h
// Macros that can be used to debug memory allocation
#ifndef __memdebug_h
#define __memdebug_h 1
#ifdef  USING_MEMDEBUG
#ifdef NON_ANSI
#include <iostream.h>
#else
#include <iostream>
#endif
#define MEMDEBUG_START_NEW(this)					\
	{								\
	int i=0;							\
	for (; i<memdebug::num; i++)					\
          if (memdebug::name[i] == this) {				\
	     memdebug::last_total[i] = memdebug::nbytes;		\
	     break;							\
	     }								\
	if (i == memdebug::num) {					\
	   memdebug::num++;						\
	   if (memdebug::name.len() == memdebug::num) {			\
	      memdebug::name.resize(memdebug::num+10);			\
	      memdebug::num_new.resize(memdebug::num+10);		\
	      memdebug::num_del.resize(memdebug::num+10);		\
	      memdebug::memory_allocated.resize(memdebug::num+10);	\
	      memdebug::memory_deleted.resize(memdebug::num+10);	\
	      memdebug::last_total.resize(memdebug::num+10);		\
	      }								\
	   }								\
	memdebug::name[i] = this;					\
	memdebug::last_total[i] = memdebug::nbytes;			\
#define MEMDEBUG_END_NEW(this)						\
	{								\
	for (int i=0; i<memdebug::num; i++)				\
          if (memdebug::name[i] == this) {				\
	     memdebug::memory_allocated[i] += 				\
			memdebug::nbytes - memdebug::last_total[i];	\
	     memdebug::num_new[i]++;					\
	     break;							\
	     }								\
#define MEMDEBUG_START_RESIZE(this)					\
	{								\
	int i=0;							\
	for (; i<memdebug::num; i++)					\
          if (memdebug::name[i] == this)				\
	     memdebug::last_total[i] = memdebug::nbytes;		\
#define MEMDEBUG_END_RESIZE(this)					\
	{								\
	for (int i=0; i<memdebug::num; i++)				\
          if (memdebug::name[i] == this) {				\
	     memdebug::memory_allocated[i] += 				\
			memdebug::nbytes - memdebug::last_total[i];	\
	     }								\
#define MEMDEBUG_START_DEL(this)					\
	{								\
#define MEMDEBUG_END_DEL(this)						\
	{								\
	for (int i=0; i<memdebug::num; i++)				\
          if (memdebug::name[i] == this) {				\
	     memdebug::num_del[i]++;					\
	     }								\
#define MEMDEBUG_DUMP(os)		memdebug::print_summary(os);
class memdebug
public:
  static int nbytes;
  static int num;
  static int n_news;
  static int n_dels;
  static BasicArray_CharString name;
  static IntVector 	       num_new;
  static IntVector 	       memory_allocated;
  static IntVector 	       num_del;
  static IntVector 	       memory_deleted;
  static IntVector 	       last_total;
  static void print_summary(ostream& os);
#else
#define MEMDEBUG_START_NEW(this)
#define MEMDEBUG_END_NEW(this)	
#define MEMDEBUG_START_RESIZE(this)	
#define MEMDEBUG_END_RESIZE(this)
#define MEMDEBUG_START_DEL(this)
#define MEMDEBUG_END_DEL(this)
#define MEMDEBUG_DUMP(os)
#endif
#endif
 * \file real.h
 * Define the type of floating point representation that is commonly used.
#ifndef __real_h
#define __real_h
#ifdef REAL
#undef REAL
#endif
 * \def REALType
 * Flag that is used to conditionally compile codes that work with REAL
 * data types based upon the underlying data type.
#define REALType DoubleType
 * \typedef REAL
 * Defines the datatype commonly used for floating point representations.
 * In principle, this type could be set to double, float, etc.  However,
 * in practice, this has only been used with the type 'double', and there
 * are known mathematical routines for which these types are not 
 * interchangable.
typedef double REAL;
#endif
 * \file	seconds.h
 * Portable wrappers for system-dependent timing routines.  Both CPU time
 * and wall clock (elapsed) time are provided.  These routines were 
 * derived from similar routines developed by Scott Kohn for LPARX.
#ifndef ___seconds_h
#define ___seconds_h
#ifdef __cplusplus
#endif
/// The `absolute' number of CPU seconds (User+System CPU seconds).
UTILIB_API double CPUSeconds();
/// The number of CPU seconds elapsed since the code was started or since the last call to \c InitializdTiming.
UTILIB_API double ElapsedCPUSeconds();
/// The `absolute' number of wall-clock seconds.
UTILIB_API double WallClockSeconds();
/// The number of elapsed wall-clock seconds since the code was started or since the last call to \c InitializeTiming.
UTILIB_API double ElapsedWallClockSeconds();
/// Resets the timing state for \c ElapsedCPUSeconds and \c ElapsedWallClockSeconds.
UTILIB_API int    InitializeTiming();
/// The current time.
UTILIB_API double CurrentTime();
#ifdef __cplusplus
#endif
#endif
 * \file signalError.h
 * Simple header file for the signalError function.  Note: this code needs
 * to be resolved with the code in \c errmsg.h.
 * \author Jonathan Eckstein
#ifndef __signalerror_h
#define __signalerror_h
#ifdef __cplusplus
#endif
  /* Write an error signal, using the format specified by \a string. */
  void signalError(const char* string, ...);
#ifdef __cplusplus
#endif
#endif
 * \file	stdlibmpi.h
 * This header file provide dummy declarations of MPI data types for
 * when MPI is not defined.
 * \typedef MPI_Request
 * A dummy typedef for when MPI is not used.
 * \typedef MPI_Status
 * A dummy typedef for when MPI is not used.
#ifndef USING_MPI
#ifndef __stdlibmpi_h
#define __stdlibmpi_h
typedef void* MPI_Request;
typedef void* MPI_Status;
#endif
#else
#endif
 * \file	utilib_dll.h
 * This information is used by MVC++ to create a DLL.
 * \def UTILIB_API
 * Macro that specifies the import or export information used for
 * making a compiled symbol externally visible within a DLL.
#ifndef __utilib_dll_h
#define __utilib_dll_h
#ifdef _MSC_VER
#ifdef UTILIB_EXPORTS                                                    
#define UTILIB_API __declspec(dllexport)                                        
#else                                                                           
#define UTILIB_API __declspec(dllimport)                                        
#endif
#else
#define UTILIB_API
#endif
#endif
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
#if !defined(AFX_STDAFX_H__B8E9B1B6_2345_11D3_B247_0004AC902FBE__INCLUDED_)
#define AFX_STDAFX_H__B8E9B1B6_2345_11D3_B247_0004AC902FBE__INCLUDED_
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
// TODO: reference additional headers your program requires here
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
#endif // !defined(AFX_STDAFX_H__B8E9B1B6_2345_11D3_B247_0004AC902FBE__INCLUDED_)
