\
\
\
Testing BasicArray<double> simpleST
\
\
\
Sending the splay tree to 'os'
101
5 : 41.4214 141.421 141.421 141.421 141.421 
5 : 42.4214 141.421 141.421 141.421 141.421 
5 : 43.4214 141.421 141.421 141.421 141.421 
5 : 44.4214 141.421 141.421 141.421 141.421 
5 : 45.4214 141.421 141.421 141.421 141.421 
5 : 46.4214 141.421 141.421 141.421 141.421 
5 : 47.4214 141.421 141.421 141.421 141.421 
5 : 48.4214 141.421 141.421 141.421 141.421 
5 : 49.4214 141.421 141.421 141.421 141.421 
5 : 50.4214 141.421 141.421 141.421 141.421 
5 : 51.4214 141.421 141.421 141.421 141.421 
5 : 52.4214 141.421 141.421 141.421 141.421 
5 : 53.4214 141.421 141.421 141.421 141.421 
5 : 54.4214 141.421 141.421 141.421 141.421 
5 : 55.4214 141.421 141.421 141.421 141.421 
5 : 56.4214 141.421 141.421 141.421 141.421 
5 : 57.4214 141.421 141.421 141.421 141.421 
5 : 58.4214 141.421 141.421 141.421 141.421 
5 : 59.4214 141.421 141.421 141.421 141.421 
5 : 60.4214 141.421 141.421 141.421 141.421 
5 : 61.4214 141.421 141.421 141.421 141.421 
5 : 62.4214 141.421 141.421 141.421 141.421 
5 : 63.4214 141.421 141.421 141.421 141.421 
5 : 64.4214 141.421 141.421 141.421 141.421 
5 : 65.4214 141.421 141.421 141.421 141.421 
5 : 66.4214 141.421 141.421 141.421 141.421 
5 : 67.4214 141.421 141.421 141.421 141.421 
5 : 68.4214 141.421 141.421 141.421 141.421 
5 : 69.4214 141.421 141.421 141.421 141.421 
5 : 70.4214 141.421 141.421 141.421 141.421 
5 : 71.4214 141.421 141.421 141.421 141.421 
5 : 72.4214 141.421 141.421 141.421 141.421 
5 : 73.4214 141.421 141.421 141.421 141.421 
5 : 74.4214 141.421 141.421 141.421 141.421 
5 : 75.4214 141.421 141.421 141.421 141.421 
5 : 76.4214 141.421 141.421 141.421 141.421 
5 : 77.4214 141.421 141.421 141.421 141.421 
5 : 78.4214 141.421 141.421 141.421 141.421 
5 : 79.4214 141.421 141.421 141.421 141.421 
5 : 80.4214 141.421 141.421 141.421 141.421 
5 : 81.4214 141.421 141.421 141.421 141.421 
5 : 82.4214 141.421 141.421 141.421 141.421 
5 : 83.4214 141.421 141.421 141.421 141.421 
5 : 84.4214 141.421 141.421 141.421 141.421 
5 : 85.4214 141.421 141.421 141.421 141.421 
5 : 86.4214 141.421 141.421 141.421 141.421 
5 : 87.4214 141.421 141.421 141.421 141.421 
5 : 88.4214 141.421 141.421 141.421 141.421 
5 : 89.4214 141.421 141.421 141.421 141.421 
5 : 90.4214 141.421 141.421 141.421 141.421 
5 : 91.4214 141.421 141.421 141.421 141.421 
5 : 92.4214 141.421 141.421 141.421 141.421 
5 : 93.4214 141.421 141.421 141.421 141.421 
5 : 94.4214 141.421 141.421 141.421 141.421 
5 : 95.4214 141.421 141.421 141.421 141.421 
5 : 96.4214 141.421 141.421 141.421 141.421 
5 : 97.4214 141.421 141.421 141.421 141.421 
5 : 98.4214 141.421 141.421 141.421 141.421 
5 : 99.4214 141.421 141.421 141.421 141.421 
5 : 100.421 141.421 141.421 141.421 141.421 
5 : 101.421 141.421 141.421 141.421 141.421 
5 : 102.421 141.421 141.421 141.421 141.421 
5 : 103.421 141.421 141.421 141.421 141.421 
5 : 104.421 141.421 141.421 141.421 141.421 
5 : 105.421 141.421 141.421 141.421 141.421 
5 : 106.421 141.421 141.421 141.421 141.421 
5 : 107.421 141.421 141.421 141.421 141.421 
5 : 108.421 141.421 141.421 141.421 141.421 
5 : 109.421 141.421 141.421 141.421 141.421 
5 : 110.421 141.421 141.421 141.421 141.421 
5 : 111.421 141.421 141.421 141.421 141.421 
5 : 112.421 141.421 141.421 141.421 141.421 
5 : 113.421 141.421 141.421 141.421 141.421 
5 : 114.421 141.421 141.421 141.421 141.421 
5 : 115.421 141.421 141.421 141.421 141.421 
5 : 116.421 141.421 141.421 141.421 141.421 
5 : 117.421 141.421 141.421 141.421 141.421 
5 : 118.421 141.421 141.421 141.421 141.421 
5 : 119.421 141.421 141.421 141.421 141.421 
5 : 120.421 141.421 141.421 141.421 141.421 
5 : 121.421 141.421 141.421 141.421 141.421 
5 : 122.421 141.421 141.421 141.421 141.421 
5 : 123.421 141.421 141.421 141.421 141.421 
5 : 124.421 141.421 141.421 141.421 141.421 
5 : 125.421 141.421 141.421 141.421 141.421 
5 : 126.421 141.421 141.421 141.421 141.421 
5 : 127.421 141.421 141.421 141.421 141.421 
5 : 128.421 141.421 141.421 141.421 141.421 
5 : 129.421 141.421 141.421 141.421 141.421 
5 : 130.421 141.421 141.421 141.421 141.421 
5 : 131.421 141.421 141.421 141.421 141.421 
5 : 132.421 141.421 141.421 141.421 141.421 
5 : 133.421 141.421 141.421 141.421 141.421 
5 : 134.421 141.421 141.421 141.421 141.421 
5 : 135.421 141.421 141.421 141.421 141.421 
5 : 136.421 141.421 141.421 141.421 141.421 
5 : 137.421 141.421 141.421 141.421 141.421 
5 : 138.421 141.421 141.421 141.421 141.421 
5 : 139.421 141.421 141.421 141.421 141.421 
5 : 140.421 141.421 141.421 141.421 141.421 
5 : 141.421 141.421 141.421 141.421 141.421 

\
\
\
Testing BasicArray<int> simpleST
\
\
\
Sending the splay tree to 'os'
101
5 : 41 141 141 141 141 
5 : 42 141 141 141 141 
5 : 43 141 141 141 141 
5 : 44 141 141 141 141 
5 : 45 141 141 141 141 
5 : 46 141 141 141 141 
5 : 47 141 141 141 141 
5 : 48 141 141 141 141 
5 : 49 141 141 141 141 
5 : 50 141 141 141 141 
5 : 51 141 141 141 141 
5 : 52 141 141 141 141 
5 : 53 141 141 141 141 
5 : 54 141 141 141 141 
5 : 55 141 141 141 141 
5 : 56 141 141 141 141 
5 : 57 141 141 141 141 
5 : 58 141 141 141 141 
5 : 59 141 141 141 141 
5 : 60 141 141 141 141 
5 : 61 141 141 141 141 
5 : 62 141 141 141 141 
5 : 63 141 141 141 141 
5 : 64 141 141 141 141 
5 : 65 141 141 141 141 
5 : 66 141 141 141 141 
5 : 67 141 141 141 141 
5 : 68 141 141 141 141 
5 : 69 141 141 141 141 
5 : 70 141 141 141 141 
5 : 71 141 141 141 141 
5 : 72 141 141 141 141 
5 : 73 141 141 141 141 
5 : 74 141 141 141 141 
5 : 75 141 141 141 141 
5 : 76 141 141 141 141 
5 : 77 141 141 141 141 
5 : 78 141 141 141 141 
5 : 79 141 141 141 141 
5 : 80 141 141 141 141 
5 : 81 141 141 141 141 
5 : 82 141 141 141 141 
5 : 83 141 141 141 141 
5 : 84 141 141 141 141 
5 : 85 141 141 141 141 
5 : 86 141 141 141 141 
5 : 87 141 141 141 141 
5 : 88 141 141 141 141 
5 : 89 141 141 141 141 
5 : 90 141 141 141 141 
5 : 91 141 141 141 141 
5 : 92 141 141 141 141 
5 : 93 141 141 141 141 
5 : 94 141 141 141 141 
5 : 95 141 141 141 141 
5 : 96 141 141 141 141 
5 : 97 141 141 141 141 
5 : 98 141 141 141 141 
5 : 99 141 141 141 141 
5 : 100 141 141 141 141 
5 : 101 141 141 141 141 
5 : 102 141 141 141 141 
5 : 103 141 141 141 141 
5 : 104 141 141 141 141 
5 : 105 141 141 141 141 
5 : 106 141 141 141 141 
5 : 107 141 141 141 141 
5 : 108 141 141 141 141 
5 : 109 141 141 141 141 
5 : 110 141 141 141 141 
5 : 111 141 141 141 141 
5 : 112 141 141 141 141 
5 : 113 141 141 141 141 
5 : 114 141 141 141 141 
5 : 115 141 141 141 141 
5 : 116 141 141 141 141 
5 : 117 141 141 141 141 
5 : 118 141 141 141 141 
5 : 119 141 141 141 141 
5 : 120 141 141 141 141 
5 : 121 141 141 141 141 
5 : 122 141 141 141 141 
5 : 123 141 141 141 141 
5 : 124 141 141 141 141 
5 : 125 141 141 141 141 
5 : 126 141 141 141 141 
5 : 127 141 141 141 141 
5 : 128 141 141 141 141 
5 : 129 141 141 141 141 
5 : 130 141 141 141 141 
5 : 131 141 141 141 141 
5 : 132 141 141 141 141 
5 : 133 141 141 141 141 
5 : 134 141 141 141 141 
5 : 135 141 141 141 141 
5 : 136 141 141 141 141 
5 : 137 141 141 141 141 
5 : 138 141 141 141 141 
5 : 139 141 141 141 141 
5 : 140 141 141 141 141 
5 : 141 141 141 141 141 

\
\
\
Testing double simpleST
\
\
\
Sending the splay tree to 'os'
101
-3.957864e-001
-3.228864e-001
-2.638374e-001
-1.729610e-001
-1.133370e-001
-7.421770e-002
-6.070918e-002
-3.991957e-002
-3.194293e-002
-2.612796e-002
-1.717871e-002
-1.374503e-002
-1.124187e-002
-7.389515e-003
-4.861984e-003
-3.892210e-003
-2.548977e-003
-2.085137e-003
-1.371288e-003
-1.097395e-003
-8.977269e-004
-5.904382e-004
-4.725363e-004
-3.865859e-004
-2.543082e-004
-2.035553e-004
-1.332575e-004
-1.089825e-004
-7.162338e-005
-4.711205e-005
-3.770744e-005
-3.085148e-005
-2.030015e-005
-1.625178e-005
-1.064437e-005
-8.708045e-006
-5.728039e-006
-4.584658e-006
-3.000961e-006
-2.454085e-006
-1.612444e-006
-1.060243e-006
-8.483717e-007
-6.939178e-007
-4.562134e-007
-3.650099e-007
-2.985226e-007
-1.961987e-007
-1.290639e-007
-1.033054e-007
1.285216e-007
1.571422e-007
2.400246e-007
2.998632e-007
4.558211e-007
5.571582e-007
6.961667e-007
1.058466e-006
1.293878e-006
1.975608e-006
2.467796e-006
3.750590e-006
5.705772e-006
6.976196e-006
8.718889e-006
1.326089e-005
2.018361e-005
2.468181e-005
3.085217e-005
4.693406e-005
5.738363e-005
8.764453e-005
1.094920e-004
1.664332e-004
2.532206e-004
3.096127e-004
3.869681e-004
5.885803e-004
7.195823e-004
8.992834e-004
1.367640e-003
1.671965e-003
2.089421e-003
3.177440e-003
4.835753e-003
5.913280e-003
9.033688e-003
1.128653e-002
1.715813e-002
2.097333e-002
2.620681e-002
3.984687e-002
4.870981e-002
6.086747e-002
9.255412e-002
1.408496e-001
2.144595e-001
2.676036e-001
3.332136e-001
4.142136e-001
1.414214e+000

\
\
\
Testing int simpleST
\
\
\
Sending the splay tree to 'os'
100
0
1
8
27
64
125
216
343
512
729
1000
1331
1728
2197
2744
3375
4096
4913
5832
6859
8000
9261
10648
12167
13824
15625
17576
19683
21952
24389
27000
29791
32768
35937
39304
42875
46656
50653
54872
59319
64000
68921
74088
79507
85184
91125
97336
103823
110592
117649
125000
132651
140608
148877
157464
166375
175616
185193
195112
205379
216000
226981
238328
250047
262144
274625
287496
300763
314432
328509
343000
357911
373248
389017
405224
421875
438976
456533
474552
493039
512000
531441
551368
571787
592704
614125
636056
658503
681472
704969
729000
753571
778688
804357
830584
857375
884736
912673
941192
970299

\
\
\
Testing char* HT with default function
\
\
\
Sending the splay tree to 'os'
9667
!(*(++c)))
!(ignore_duplicates_flag
!(s->eof());
!=
!=0
!=OPEN)
!defined(AFX_STDAFX_H__B8E9B1B6_2345_11D3_B247_0004AC902FBE__INCLUDED_)
!defined(ArraySanityChecking)
!defined(Basic3DArrayT)
!defined(BasicArrayT)
!defined(BasicArray_DEFN)
!defined(BitArraySanityChecking)
!defined(EnumBitArraySanityChecking)
!defined(QueueListT)
!defined(Simple2DArrayT)
!defined(StackArrayT)
!defined(StackListT)
!defined(TwoBitArraySanityChecking)
!defined(TwoDArraySanityChecking)
!defined(__STDC__)
!defined(__cplusplus)
!flag)
!is_member(set.Data[i]))
#
##
#define
#elif
#else
#endif
#if
#ifdef
#ifndef
#include
#pragma
#undef
%
&
&&
&(array.Data[start]),
&(data[ndx]);
&(mat.matind[mat.matbeg[i]]);
&(mat.matval[mat.matbeg[i]]);
&);
&,
&=
&CommonIO::StrCerr))
&CommonIO::StrCerr;
&CommonIO::StrCout)
&CommonIO::StrCout;
&CommonIO::common_cerr;
&CommonIO::common_cin;
&CommonIO::common_cout;
&CommonIO::pStrCerr;
&CommonIO::pStrCout;
&Key;}
&N;
&_result_ref;
&argv);
&array)
&cerr;
&cin)
&cin;
&cout;
&default_rng;
&index,
&info);
&largest_free,
&n,
&pStrCout)
&result);
&size);
&total_free,
&total_used);
&usage);
'
'#'))
'#'.
'%';
')
');
'*')
'-')
'-';
'-h'
'0')
'1')
'2')
'3')
':';
';
'='
'='))
'A';
'CommonIO::flush()'
'ErrAbort()',
'F';
'Flush'
'Flush',
'I')
'N')
'Static'
'T')
'T';
'Temporary'
'\0')
'\0';
'\000'
'\000')
'\000'))
'\000');
'\000',
'\000';
'\\')
'\\n'.
'\\t'
'\n')
'\n'))
'\n')))
'\t')
'assume'
'bufexp'
'constant'
'core'
'd')
'data'
'double'
'double',
'end'
'exp'
'exp'.
'f')
'find',
'flush'
'free
'freeze()'
'holes'
'ii'
'index'
'item'.
'long
'next'
'pass-through'
'r'
'real'
'removes'
'small
'unfreeze'
'wraps'
'ws',
'zero'
(
(!
(!(StrCerr.good()))
(!(StrCout.good()))
(!(x
(!(y
(!add_unique
(!array.shared)
(!counter)
(!empty())
(!item)
(!last)
(!name)
(!newitem)
(!num.Finite
(!num.Finite);
(!param)
(!rng)
(!running())
(!s->good())
(!shared)
(!t)
(!test(request,&trashStatus))
(!uMPI::iDoIO)
(!uMPI::running())
(!unused)
(!ws)
(!yFinite)
(#
(#char)[0])
(&outstr
((&outstr
(((SimpleHeapItem<T>*)member(i))->Key
(((X)
(((double)data.size())/((double)table.size())))
(((double)data.size())/((double)table.size()*max_bucket_size)))
(((double)memory_allocated[i])/num_new[i])
(((double)memory_deleted[i])/num_del[i])
(((next
(((size_type)0xF0)
(((void*)(x.data()))
(((x)==NULL)
((*c)
((*this)[i]
((Data
((GenericSplayTreeItem*)item)->write(os);
((GenericSplayTreeItem<T>*)item)->write(os);
((IO_Rank
((Len
((ListItem<T>*)p)->next
((OrderedListItem<T,V>*)p)->next
((Rank
((Sense*compare(key,
((Sense*compare(key,t->right->Key()))
((Sense*compare(key1,key2))
((Sense*compare(node->Key(),
((Sense*compare(tree[child+1]->key(),tree[child]->key()))<0))
((Sense*compare(tree[element]->key(),tree[child]->key()))<0)
((Sense*compare(tree[element]->key(),tree[next]->key()))
((SimpleHashTableItem<T>*)item)->write(os);
((SimpleHeapItem<T>*)item)->Key;}
((SimpleSplayTreeItem*)item)->write(os);
((SimpleSplayTreeItem<T>*)item)->write(os);
((T*)0);
((T*)NULL);
((X)
((__ACTION__
((a->Data)
((a1.nrows()
((a1.size()
((array.a->Nrows
((begin_end_counter
((c
((child
((colmajor.matcnt[j]
((curr
((d
((double
((double)
((double)(data.size()))/total_slots;
((double)t)/CLOCKS_PER_SEC;
((element
((flag
((flag==TRUE)
((header_flag
((i)
((idx
((index+newsize)
((int
((ioProc
((io_mapping
((mat[i][j]
((minValue
((mpMaxNodes()
((mpMyID()
((ncols
((ne
((np-nm)
((nref
((nrows()
((ptr
((ptrlen
((r
((res.nrows()
((result
((row
((rowmajor.matcnt[j]
((sampleflag
((size_type)idx
((sizeof(size_type)
((str_flag
((tmp
((tval
((val
((void*)(y.data())))
((x)->size))
((x)<(y)?
((x)>(y)?
((x.val
((x[med]+x[med+1])*0.5);
((xm_ndx
((xp_ndx
((xval
()
();
(*(((GenericHeapItem<T>*)member(i))->Key)
(*)
(*)(PyObject
(**CommonIO::MapCerr)
(**CommonIO::MapCin)
(**CommonIO::MapCout)
(*A<T>::hash_fn)(const
(*CommonIO::std_cerr)
(*CommonIO::std_cin)
(*CommonIO::std_cout)
(*bbums_cerr).flush();
(*buffer
(*c
(*c)
(*common_cin);}
(*compare_fn_type)(COMP_VOID*,COMP_VOID*);
(*curr_hashfn)(KEY&,size_type);
(*curr_hashfn)(key,table_size);
(*flag)
(*func)(T
(*func)(vec[i]);
(*hash_fn)(const
(*hash_fn)(val,table_size);
(*initfunc)())
(*initfunc)());
(*item->key())
(*key1
(*mpiIOP
(*null_fn_type)(void);
(*request
(*rv)();
(*rv)(lower,upper);
(*self)
(*this)
(*this)(i));
(*this)(i);
(*this)(idx)
(*this)[i]
(*this)[tmp]
(*tmp
(*tmp)
(*tmp).fill('
(*tmp).fill('0');
(*tmp).flush();
(*tmp).setf(ios::right,ios::adjustfield);
(*tmp).unsetf(ios::adjustfield);
(*tmp).width(numDigits);
(*val);
(+1
(--a->ref
(-1)
(0
(0...size-1)
(1
(1)
(1+ne))
(1.0e-3)
(1.0e-6)
(2)
(2);
(256
(2d
(3
(;
(;;)
(A
(A[i][k]
(AbstractHeapItem*[allocated]))
(AbstractHeapItem*[initSize]))
(AbstractSplayTreeItem*)0;
(ArraySanityChecking==1)
(BYTESIZE
(BasicArray<T>*)0)
(BasicArray_double
(BasicArray_int
(BitArray
(BitArraySanityChecking==1)
(BitArray_at(_arg0,_arg1,_arg2,_arg3));
(CRandVar
(CharString
(CommonIO
(CommonIO_end)
(Data
(Data)
(Data.len()
(Data.size()
(DataNotOwned);
(Data[i]
(DoubleMatrix&
(EnumBitArraySanityChecking==1)
(Finite)
(GenericHeapItem<T>*)
(GenericSplayTreeItem<T>*)
(GenericSplayTreeItem<T>*)AbstractSplayTree::top();}
(GenericSplayTreeItem<T>*)top();
(IO_Rank
(It
(Key
(Len
(Len+1))
(Len>0)
(Len_
(ListItem<T*>*)NULL;
(ListItem<T>*)0);
(ListItem<T>*)p;
(MapCout
(Normal
(NumArray_double
(NumArray_int
(OrderedListItem<T,V>*)p;
(PM_LCG
(PackBuffer&
(Patch
(PyErr_Occurred())
(RNG
(Rutgers).
(SORT_VOID*
(SORT_VOID*)(v.data()),
(SWIG)
(Shuffling)
(Shuffling),
(SimpleArray_double
(SimpleArray_int
(SimpleHashTableItem<T>*)
(SimpleHashTableItem<T>*)(data.head()->data());
(SimpleHeapItem<T>*)
(SimpleSplayTreeItem<T>*)
(SimpleSplayTreeItem<T>*)AbstractSplayTree::top();}
(SimpleSplayTreeItem<T>*)top();
(T)
(T*)
(T*)&(vector[0]);
(Triangular
(Tuple1<T1>::operator==(tuple)
(Tuple2<T1,T2>::operator==(tuple)
(Tuple3<T1,T2,T3>::operator==(tuple)
(Tuple4<T1,T2,T3,T4>::operator==(tuple)
(Tuple5<T1,T2,T3,T4,T5>::operator==(tuple)
(Tuple6<T1,T2,T3,T4,T5,T6>::operator==(tuple)
(TwoBitArraySanityChecking==1)
(TwoDArraySanityChecking==1)
(Type)
(UnPackBuffer&
(Uniform
(Used
(User+System
(Well,
(X
(X<
(_OPTION_[0]
(__ACTION__
(__i__
(__stl_prime_list[i]
(_argc0)
(_argc1)
(_argc2)
(_argc3)
(_swigobj->asDouble())
(_swigobj->asFloat())
(_swigobj->asLong())
(_swigobj->at(_swigarg0,_swigarg1,_swigarg2))
(_swigobj->calc_nbits())
(_swigobj->close())
(_swigobj->compare(_swigarg0))
(_swigobj->data())
(_swigobj->debug
(_swigobj->divide(_swigarg0,_swigarg1))
(_swigobj->flip(_swigarg0))
(_swigobj->flush())
(_swigobj->generator())
(_swigobj->getSeed())
(_swigobj->high())
(_swigobj->len())
(_swigobj->low())
(_swigobj->mean
(_swigobj->minus(_swigarg0,_swigarg1))
(_swigobj->nbits())
(_swigobj->nrefs())
(_swigobj->open(_swigarg0))
(_swigobj->plus(_swigarg0,_swigarg1))
(_swigobj->put(_swigarg0,_swigarg1))
(_swigobj->read(_swigarg0))
(_swigobj->reseed(_swigarg0))
(_swigobj->reset())
(_swigobj->reset(_swigarg0))
(_swigobj->resize(_swigarg0))
(_swigobj->set(_swigarg0))
(_swigobj->setDebug(_swigarg0))
(_swigobj->set_data(_swigarg0,_swigarg1,_swigarg2))
(_swigobj->set_subvec(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
(_swigobj->stddev
(_swigobj->times(_swigarg0,_swigarg1))
(_swigobj->truncation(_swigarg0))
(_swigobj->verbosity(_swigarg0))
(_swigobj->write(_swigarg0))
(a
(a)
(a->Data
(a->Data)
(a->Data[i][j]
(a->Ncols
(a->Ndeep
(a->Nrows
(a->Nrows>0))
(a->gintVars)[ndx
(a->own_data
(a->own_ptrs)
(a1.a
(a1.ncols()
(a1.size()
(a<<10);
(a<<16);
(a<<8);
(a<b
(a[i]-b[i])*(a[i]-b[i]);
(aa
(add_unique
(and
(argCount
(array
(array)
(array.Data
(array.Data)
(array.a
(array.a->Ncols
(array.a->Nrows
(array.size()
(array.size())
(array[0]
(array[i]
(arraylen
(as
(b>>13);
(b>>15);
(b>>5);
(begin_end_counter
(bitval
(bool)
(bucket_size[i]
(bucket_size[index]
(bucket_size[j]
(buffer
(buffer)
(by
(c
(c)
(c>>12);
(c>>13);
(c>>3);
(cerr_)
(char
(char)((int)'a'
(char)(1
(char)(3
(char*
(char*)
(char*)name);
(char*)str,
(charptr
(check_duplicates_flag
(check_duplicates_flag)
(cin
(cin_)
(cndx
(col
(colmajor.matcnt[j]
(colmajor.matind[colmajor.matbeg[j]+colndx[j]]
(comment_lines(ins,tmp));
(comp
(compare(&key,curritem->key())
(compare(&key,treeitem->Key())==0)
(compare(&key,treeitem->key())==0)
(compare(array)
(compare(key,t->Key())
(compare(key,t->key())==0)
(compare(key,tree->key_ptr)==0)
(concat(*_arg0,*_arg1));
(cond)
(const
(const_ref
(count
(counter
(cout_)
(ctr
(curr
(curr)
(curr->data()->compare(&key)
(curr->next)
(curr_hashfn)
(curritem
(d
(data
(data)
(data.len()
(data.size()
(data[i])
(debug
(debug())
(defined(CRAYC90)
(defined(PVM))
(delete
(delete_flag)
(denominator
(deprecated)
(diff
(double
(double)
(double)(arry[i]*100)
(double)(mat.nrows()-1);
(double)buckets;
(doubleptr
(e.g.
(e.g.,
(elapsed)
(element
(empty())
(errorCode
(errorCode)
(event.alog
(fabs(value)
(fabs(vec)+1.0)*A,
(fabs(vec[i])+1.0)*A,
(fileName
(find(item)
(first
(first)
(flag
(flag)
(float
(flush_flag)
(foo());
(for
(h
(hash_data)
(header_flag
(i
(i<bucket_size[index]);
(i<j)
(i<n))
(i=0,
(i=0;
(i=1;
(i=k;
(idx
(if
(ifstream
(including
(index
(index(val)
(info
(ins
(ins)
(int
(int)
(int)(~((int)0)
(int)0;
(int)size();}
(int)sizeof(T),
(int)val;
(intptr
(intval
(ioProc
(io_buffering
(io_mapping
(is)
(isalpha(c))
(isdigit(c))
(istream
(istream&
(item)
(item->Key
(item->compare(curr->data()->key())
(item->next)
(item->prev)
(j<element_size())
(j=0;
(k
(k=0;
(k[0]
(k[12]+(k[13]<<8)+(k[14]<<16)+(k[15]<<24));
(k[16]+(k[17]<<8)+(k[18]<<16)+(k[19]<<24));
(k[20]+(k[21]<<8)+(k[22]<<16)+(k[23]<<24));
(k[24]+(k[25]<<8)+(k[26]<<16)+(k[27]<<24));
(k[28]+(k[29]<<8)+(k[30]<<16)+(k[31]<<24));
(k[4]
(k[8]
(key
(key1_
(last)
(len
(len+BYTESIZE-1)/(BYTESIZE/element_size())
(like
(logEvent::eventLog()
(lookup(name,hashValue))
(m.ncols()
(m.nrows()
(m1.ncols()
(mat.nrows()
(mat.nrows());
(mat[i][j]
(matcnt[cndx]
(matcnt[i]
(matcnt[i])
(matcnt[rndx]
(matind[matbeg[colndx]+k]
(matind[matbeg[j]+k]
(matind[matbeg[rowndx]+k]
(matind[pt+i]
(matrix.nrows()
(max_load
(max_ratio
(mean
(memdebug::name.len()
(memdebug::name[i]
(messageLog())
(mod
(mode
(mode==queueLL)
(mpATest(PRINT_MARKER_REQUEST)
(mpLastProcessor()
(mpMyID()
(mpiActive)
(mylen
(n
(n%2
(nbytes==0
(ncols
(ncols()
(ndata-1))
(ndeep
(ndx
(ne
(neg_flag)
(new
(newLocation
(newValue
(newbytes
(newl
(newroot
(newsize
(next)
(next->prev)
(next[0]
(next[curr]
(nm-np
(nnzeros
(node)
(not
(np
(nrows
(nrows()*ncols())
(nrows()*ncols()),len));
(num.Finite)
(num.Finite);
(numDigits
(numParameters++
(num_elements
(numerator
(o
(ofstream
(oldTree
(ostream
(ostream&
(outcount
(own)
(p
(p=0;
(param)
(pc
(possibly)
(prev)
(prev_rndx
(print_marker_status
(prunable(tree[n]))
(ptr->verbosity(dlevel))
(ptr[0]
(quantum
(r
(rank
(rank()
(rcond
(ref
(ref)
(ref-1))
(ref_ptrs)
(res.ncols()
(res.size()
(resize_OK
(resize_flag
(result
(result==MPI_IDENT
(row
(row,col)-th
(rowPosition[i]
(rowlen
(rowmajor.matcnt[j]
(rowmajor.matind[rowmajor.matbeg[j]+rowndx[j]]
(running
(s
(s->eof())
(see
(semicolon-separated)
(set.len()
(shared
(shared)
(size()
(size_type
(size_type)
(sizeof(int)*8-1)))
(sizeof(size_type)
(states
(stats_flag
(status
(status)
(std::istream&
(std::ostream&
(str)
(str1.Data[i]
(str1.Len
(strcmp(Data,array)
(stream.good())
(swig_inittab[i].name)
(sync_print_flag
(sync_print_flag==TRUE)
(t
(t)
(t->left
(t->right
(t==NULL)
(table_size
(tagging
(tb.time
(the
(this
(timestamp[check_index]
(tm_str
(tmp
(tmp)
(tmp[i]
(tree
(treeitem
(tuple.val1
(tuple.val2
(tuple.val3
(tuple.val4
(tuple.val5
(tuple.val6
(tuple.val7
(tval)
(type
(type*)
(uMPI::iDoIO)
(uMPI::rank
(ub1
(ul_reason_for_call)
(unsigned
(usage.tms_utime+usage.tms_stime))/((double)
(used
(user
(using_prime_ht)
(utilib_prime_list[i]
(v.
(val
(value
(var)
(vars.binaryVars().size()+BYTESIZE-1)/BYTESIZE,
(vec.Data
(vec.array_len
(vec.len()
(vec[ans]
(vector.size()
(vector[i]
(verbosity(dlevel))
(void
(void)
(void*)
(void*)(&c),
(void*)(&key_val);}
(void*)0;}
(void*)Key;}
(void*)data,
(void*)key_ptr;}
(which
(x
(x)
(x.Finite)
(x.size()
(x.val
(x<y)
(x>y)
(xFinite)
(x[ws[++i]]
(xval
(xval*yval
(xx
(y
(y));}
(y.Finite)
(y.val
(yFinite)
(yval
(zero-based)
)
)&key);}
))
);
)BasicArray_double___getitem__(_arg0,_arg1);
)BasicArray_double_data(_arg0);
)BasicArray_double_len(_arg0);
)BasicArray_double_nrefs(_arg0);
)BasicArray_double_resize(_arg0,_arg1);
)BasicArray_int___getitem__(_arg0,_arg1);
)BasicArray_int_data(_arg0);
)BasicArray_int_len(_arg0);
)BasicArray_int_nrefs(_arg0);
)BasicArray_int_resize(_arg0,_arg1);
)BitArray___call__(_arg0,_arg1);
)BitArray_compare(_arg0,*_arg1);
)BitArray_len(_arg0);
)BitArray_nbits(_arg0);
)BitArray_nrefs(_arg0);
)BitArray_read(_arg0,*_arg1);
)BitArray_resize(_arg0,_arg1);
)BitArray_write(_arg0,*_arg1);
)CPUSeconds();
)CRandVar___call__(_arg0);
)CharString___getitem__(_arg0,_arg1);
)CharString_data(_arg0);
)CharString_len(_arg0);
)CharString_nrefs(_arg0);
)CharString_read(_arg0,*_arg1);
)CharString_resize(_arg0,_arg1);
)CharString_write(_arg0,*_arg1);
)CommonIO::io_rank();
)CommonIO::numProcs();
)CommonIO::rank();
)CommonIO_debug_get(_arg0);
)CommonIO_debug_set(_arg0,_arg1);
)CommonIO_verbosity(_arg0,_arg1);
)Discretize(_arg0,_arg1,_arg2);
)ElapsedCPUSeconds();
)ElapsedWallClockSeconds();
)InitializeTiming();
)Normal_mean_get(_arg0);
)Normal_mean_set(_arg0,_arg1);
)Normal_stddev_get(_arg0);
)Normal_stddev_set(_arg0,_arg1);
)PM_LCG_asDouble(_arg0);
)PM_LCG_asLong(_arg0);
)PM_LCG_getSeed(_arg0);
)PM_LCG_read(_arg0,*_arg1);
)PM_LCG_write(_arg0,*_arg1);
)PyInt_AsLong(val);
)RNG_asDouble(_arg0);
)RNG_asFloat(_arg0);
)RNG_asLong(_arg0);
)SimpleArray_double_compare(_arg0,*_arg1);
)SimpleArray_double_read(_arg0,*_arg1);
)SimpleArray_double_write(_arg0,*_arg1);
)SimpleArray_int_compare(_arg0,*_arg1);
)SimpleArray_int_read(_arg0,*_arg1);
)SimpleArray_int_write(_arg0,*_arg1);
)Uniform_high(_arg0);
)Uniform_low(_arg0);
)WallClockSeconds();
)argmax(*_arg0);
)argmedian(_arg0,_arg1,_arg2,_arg3);
)argmin(*_arg0);
)bitwise_or(*_arg0,*_arg1,*_arg2);
)bitwise_xor(*_arg0,*_arg1,*_arg2);
)calc_filesize(_arg0);
)covariance(_arg0,_arg1,_arg2,_arg3);
)dist(*_arg0,*_arg1);
)length(*_arg0);
)mad(*_arg0,*_arg1);
)max(*_arg0);
)mean(*_arg0);
)median(_arg0,_arg1,_arg2,_arg3);
)min(*_arg0);
)round(_arg0);
)sum(*_arg0);
)trimmed_mean(*_arg0,_arg1);
)var(*_arg0,_arg1);
){
*
*(*)(void
*(*)(void),
*(c++);
*(item->Key);
*(item->key());
*(item->key_ptr);
*(n++)
*(name_++)
*(ptr1++);
*(ptr2++)
*(top()->key_ptr);}
*)
*));
*);
*)BitArray_data(_arg0);
*)CRandVar_generator(_arg0);
*)Triangular_generator(_arg0);
*)new_BasicArray_double();
*)new_BasicArray_int();
*)new_BitArray();
*)new_CharString();
*)new_CommonIO();
*)new_IntVector();
*)new_Normal(_arg0,_arg1,_arg2);
*)new_PM_LCG(_arg0);
*)new_RealVector();
*)new_SimpleArray_double();
*)new_SimpleArray_int();
*)new_Triangular(_arg0,_arg1,_arg2);
*)new_Uniform(_arg0,_arg1,_arg2);
*)new_ifstream(_arg0);
*)new_ofstream(_arg0);
**
**)
**);
**)k,
**)m,nrl,nrh,
***)
***generic_make_array();
***generic_make_array(int
**,
**/
**MapCerr;
**MapCout;
**argv)
**argv);
**d,
**d=NULL;
**generic_make_matrix();
**generic_make_matrix(int
**generic_transpose_matrix();
**generic_transpose_matrix(VOID
**matrix,
*,
*/
*=
*ListItem<T>::unused
*OrderedListItem<T,V>::unused
*PyImport_Inittab;
*SWIG_GetPtr(char
*SWIG_globals;
*SWIG_newvarlink(void);
*SwigNumArray_doubleToBasicArray_double(void
*SwigNumArray_doubleToSimpleArray_double(void
*SwigNumArray_intToBasicArray_int(void
*SwigNumArray_intToSimpleArray_int(void
*SwigPM_LCGToRNG(void
*SwigSimpleArray_doubleToBasicArray_double(void
*SwigSimpleArray_intToBasicArray_int(void
*SwigTriangularToCRandVar(void
*SwigUniformToCRandVar(void
*SwigifstreamToistream(void
*SwigofstreamToostream(void
*_OPTION_
*_wrap_BasicArray_double___getitem__(PyObject
*_wrap_BasicArray_double___setitem__(PyObject
*_wrap_BasicArray_double_data(PyObject
*_wrap_BasicArray_double_len(PyObject
*_wrap_BasicArray_double_nrefs(PyObject
*_wrap_BasicArray_double_resize(PyObject
*_wrap_BasicArray_double_set_data(PyObject
*_wrap_BasicArray_double_set_subvec(PyObject
*_wrap_BasicArray_int___getitem__(PyObject
*_wrap_BasicArray_int___setitem__(PyObject
*_wrap_BasicArray_int_data(PyObject
*_wrap_BasicArray_int_len(PyObject
*_wrap_BasicArray_int_nrefs(PyObject
*_wrap_BasicArray_int_resize(PyObject
*_wrap_BasicArray_int_set_data(PyObject
*_wrap_BasicArray_int_set_subvec(PyObject
*_wrap_BitArray___call__(PyObject
*_wrap_BitArray_at(PyObject
*_wrap_BitArray_calc_nbits(PyObject
*_wrap_BitArray_compare(PyObject
*_wrap_BitArray_data(PyObject
*_wrap_BitArray_flip(PyObject
*_wrap_BitArray_len(PyObject
*_wrap_BitArray_nbits(PyObject
*_wrap_BitArray_nrefs(PyObject
*_wrap_BitArray_put(PyObject
*_wrap_BitArray_read(PyObject
*_wrap_BitArray_reset(PyObject
*_wrap_BitArray_resize(PyObject
*_wrap_BitArray_set(PyObject
*_wrap_BitArray_write(PyObject
*_wrap_CPUSeconds(PyObject
*_wrap_CRandVar___call__(PyObject
*_wrap_CRandVar_generator(PyObject
*_wrap_CRandVar_set_generator(PyObject
*_wrap_CharString___getitem__(PyObject
*_wrap_CharString___setitem__(PyObject
*_wrap_CharString_data(PyObject
*_wrap_CharString_len(PyObject
*_wrap_CharString_nrefs(PyObject
*_wrap_CharString_read(PyObject
*_wrap_CharString_resize(PyObject
*_wrap_CharString_set_subvec(PyObject
*_wrap_CharString_write(PyObject
*_wrap_CommonIO__numDigits_get()
*_wrap_CommonIO__std_cerr_get()
*_wrap_CommonIO__std_cin_get()
*_wrap_CommonIO__std_cout_get()
*_wrap_CommonIO_begin_tagging(PyObject
*_wrap_CommonIO_debug_get(PyObject
*_wrap_CommonIO_debug_set(PyObject
*_wrap_CommonIO_end_tagging(PyObject
*_wrap_CommonIO_errs(PyObject
*_wrap_CommonIO_flush(PyObject
*_wrap_CommonIO_ins(PyObject
*_wrap_CommonIO_io_rank(PyObject
*_wrap_CommonIO_numProcs(PyObject
*_wrap_CommonIO_outs(PyObject
*_wrap_CommonIO_rank(PyObject
*_wrap_CommonIO_reset(PyObject
*_wrap_CommonIO_setDebug(PyObject
*_wrap_CommonIO_setIOFlush(PyObject
*_wrap_CommonIO_setIORank(PyObject
*_wrap_CommonIO_set_cerr(PyObject
*_wrap_CommonIO_set_cin(PyObject
*_wrap_CommonIO_set_cout(PyObject
*_wrap_CommonIO_set_ofile(PyObject
*_wrap_CommonIO_set_streams(PyObject
*_wrap_CommonIO_sync_stdio(PyObject
*_wrap_CommonIO_verbosity(PyObject
*_wrap_Discretize(PyObject
*_wrap_ElapsedCPUSeconds(PyObject
*_wrap_ElapsedWallClockSeconds(PyObject
*_wrap_InitializeTiming(PyObject
*_wrap_IntVector_divide(PyObject
*_wrap_IntVector_minus(PyObject
*_wrap_IntVector_plus(PyObject
*_wrap_IntVector_times(PyObject
*_wrap_Normal_mean_get(PyObject
*_wrap_Normal_mean_set(PyObject
*_wrap_Normal_stddev_get(PyObject
*_wrap_Normal_stddev_set(PyObject
*_wrap_PM_LCG_asDouble(PyObject
*_wrap_PM_LCG_asLong(PyObject
*_wrap_PM_LCG_getSeed(PyObject
*_wrap_PM_LCG_read(PyObject
*_wrap_PM_LCG_reseed(PyObject
*_wrap_PM_LCG_reset(PyObject
*_wrap_PM_LCG_write(PyObject
*_wrap_RNG_asDouble(PyObject
*_wrap_RNG_asFloat(PyObject
*_wrap_RNG_asLong(PyObject
*_wrap_RNG_reset(PyObject
*_wrap_RealVector_divide(PyObject
*_wrap_RealVector_minus(PyObject
*_wrap_RealVector_plus(PyObject
*_wrap_RealVector_times(PyObject
*_wrap_SimpleArray_double_compare(PyObject
*_wrap_SimpleArray_double_read(PyObject
*_wrap_SimpleArray_double_write(PyObject
*_wrap_SimpleArray_int_compare(PyObject
*_wrap_SimpleArray_int_read(PyObject
*_wrap_SimpleArray_int_write(PyObject
*_wrap_Triangular_generator(PyObject
*_wrap_Triangular_truncation(PyObject
*_wrap_Uniform_high(PyObject
*_wrap_Uniform_low(PyObject
*_wrap_WallClockSeconds(PyObject
*_wrap_argmax(PyObject
*_wrap_argmedian(PyObject
*_wrap_argmin(PyObject
*_wrap_bitwise_or(PyObject
*_wrap_bitwise_xor(PyObject
*_wrap_calc_filesize(PyObject
*_wrap_cerr_print(PyObject
*_wrap_concat(PyObject
*_wrap_cout_print(PyObject
*_wrap_covariance(PyObject
*_wrap_delete_BasicArray_double(PyObject
*_wrap_delete_BasicArray_int(PyObject
*_wrap_delete_BitArray(PyObject
*_wrap_delete_CharString(PyObject
*_wrap_delete_CommonIO(PyObject
*_wrap_delete_ofstream(PyObject
*_wrap_dist(PyObject
*_wrap_foo(PyObject
*_wrap_ifstream_close(PyObject
*_wrap_ifstream_open(PyObject
*_wrap_length(PyObject
*_wrap_mad(PyObject
*_wrap_max(PyObject
*_wrap_mean(PyObject
*_wrap_median(PyObject
*_wrap_min(PyObject
*_wrap_new_BasicArray_double(PyObject
*_wrap_new_BasicArray_int(PyObject
*_wrap_new_BitArray(PyObject
*_wrap_new_CharString(PyObject
*_wrap_new_CommonIO(PyObject
*_wrap_new_IntVector(PyObject
*_wrap_new_Normal(PyObject
*_wrap_new_PM_LCG(PyObject
*_wrap_new_RealVector(PyObject
*_wrap_new_SimpleArray_double(PyObject
*_wrap_new_SimpleArray_int(PyObject
*_wrap_new_Triangular(PyObject
*_wrap_new_Uniform(PyObject
*_wrap_new_ifstream(PyObject
*_wrap_new_ofstream(PyObject
*_wrap_ofstream_close(PyObject
*_wrap_ofstream_open(PyObject
*_wrap_ostream_flush(PyObject
*_wrap_ostream_write(PyObject
*_wrap_round(PyObject
*_wrap_rowscale(PyObject
*_wrap_shuffle(PyObject
*_wrap_subshuffle(PyObject
*_wrap_sum(PyObject
*_wrap_trimmed_mean(PyObject
*_wrap_var(PyObject
*args)
*begin
*curr
*d,
*d;
*d=((T*)0),
*data,
*dest;
*end
*fileName)
*first;
*fragments,
*generic_make_vector();
*generic_make_vector(int
*key2)
*key2);
*l,
*largest_free);
*largest_free,
*last;
*left;
*link,
*m,
*mpiIOP;
*n
*name,
*ndx,
*newdata;
*next;
*operator
*p,
*prev;
*ptr
*ptr)
*ptr1
*ptr1,
*ptr2;
*ptr;
*r,
*request
*right;
*s
*self)
*self,
*self,RNG
*self,char
*self,int
*src;
*start
*start;
*tb;
*this
*this;
*this;\
*this;}
*tmp;
*total_free,
*total_used);
*val)
*y;
+
+((ub4)k[10]<<16)+((ub4)k[11]<<24));
+((ub4)k[1]<<8)
+((ub4)k[2]<<16)
+((ub4)k[3]<<24));
+((ub4)k[5]<<8)
+((ub4)k[6]<<16)
+((ub4)k[7]<<24));
+((ub4)k[9]<<8)
+(k[10]<<16)+(k[11]<<24));
+(k[1]<<8)
+(k[2]<<16)
+(k[3]<<24));
+(k[5]<<8)
+(k[6]<<16)
+(k[7]<<24));
+(k[9]<<8)
++i)
++nm;
++np;
+/-
+=
+infinity.
,
-
-(ap=BIG);
--
--------------------------------------------------------------------
---//
-1
-1)
-1))
-1);}
-1.
-1.0)
-1.0))
-1.0;
-1;
-1e16;
-20;
-6;
-999
-999.0;
-<paramName>=<value>
-=
-AF).
-MAXINT
-O
-Sense;
-infinity
-param=<file>.
-s
-s.
-sdata
-sdata1
-val;
.
...
...);
...,
/
/*
/**
/**<
/*-------------------------------------
/*----------------------------------------
/*--------------------------------------------
/*data*/,
/*is*/)
/*item*/)
/*nameBuff*/)
/*nameBuff*/):
/*num*/)
/*start*/,
/*stop*/)
//
//#define
//---
//---------------------------------------------------------------------
//---------------------------------------------------------------------------
///
////
///Adds
///The
//<<
//=============================================================
//=========================================================================
//Algorithm
//BasicArray<A>
//BasicArray<char>
//CharString
//D.E.
//ISBN
//Knuth
//Note:
//SWIG
//SimpleArray<char>
//Volume
//a.setIOFlush(1);
//delete
//double*
//first
//if
//return
//sort(tmp3,compare_A);
//unsigned
//where
//{
//{{AFX_INSERT_LOCATION}}
/=
/BYTESIZE]
0
0)
0))
0)))
0);
0);}
0,
0,int
0-201-03822-6
0.
0..n-1
0.0
0.0)
0.0);
0.0;
0.1;
0.4;
0.5,
0/1
0:
0;
0;\
0;}
0x9e3779b9;
1
1)
1))
1))))
1))));
1)));
1));
1)/
1);
1+
1+ne)
1,
1,1);
1-based,
1-bit
1-byte
1-tuple
1.
1.0
1.0)
1.0))
1.0;
1.0e30
1.1
1.4
1.5
1.5.
1/3
1/4
1/x;
10
10),(size_type)10));
10),10));
10,
100*numerator/denominator;
1000
100663319,
102
103
107,
107},
10:
10;
11
112+6.875len
11:
12)
12289,
12582917,
12:
12;
12},
131*result
139
139.
13:
140.
14:
1543,
1572869,
15:
16)
1610612741,
16:
174,
17:
18
18:
193,
196613,
1990
1995-1998
1996.
19:
1;
1;}
1e16;
2
2)
2))
2*idx;
2*m
2,
2-bit
2.
2.0)
2.0))
2.0);
2.0*boundary)
2.0;
2.6397813781
2/3
200,
2000
200},
201326611,
20:
20;
21:
22/100
22:
23:
24*(tm_str->tm_yday
24593,
24:
25,
25165843,
255)
256
256-bit
25:
26:
27:
28:
28;
29:
2;
2;}
2D
2DArrays
2^32
2^^68
2^k
2^x.
2^{-11}.
3
3)
3.14159265358979323846
3079,
30:
31
31*hashValue;
3145739,
31:
32
32)
32,
32-bit
3221225473ul,
32;
330}};
36
365*(tm_str->tm_year
389,
39,
393241,
3;
3D
3DArrays
3Darray
4
4)
4,
4-bit
4-byte
402653189,
4294967291ul
46,
46},
49)
49157,
4;
5
5)
5*i*i
50331653,
53,
5;
6
6)
6))
6,
6.0
60*(tm_str->tm_hour
60*(tm_str->tm_min
6151,
6291469,
669
6;
6len+35
7
7)
74512.261@compuserve.com.
769,
77,
78/100
786433,
7;
8
8,
805306457,
9
9.11
90))));
92,
97,
98317,
:
::compare(*key1,
::compare(Key,*key);}
::compare(val,tmp->val);
::new
;
<
<<
<=
<>
<Python.h>
<algorithm>
<assert.h>
<bit-1><bit-2>...<bit-n>
<bool.h>
<cassert>
<cctype>
<cfloat>
<class
<climits>
<cmalloc>
<cmath>
<config.c>
<cstddef>
<cstdio>
<cstdlib>
<cstring>
<ctime>
<elt-1,1>
<elt-1,2>
<elt-1,m>
<elt-1>
<elt-n,m>
<elt-n>
<errmsg.h>
<float.h>
<fstream.h>
<fstream>
<iostream.h>
<iostream>
<len>
<limits.h>
<malloc.h>
<math.h>
<memory.h>
<mpi.h>
<ncols>
<new.h>
<new>
<nrows>
<nx.h>
<stddef.h>
<stdio.h>
<stdlib.h>
<stream.h>
<stream>
<stream>.flush()
<string.h>
<strings.h>
<strstrea.h>
<strstream.h>
<sunmath.h>
<sys/m_param.h>
<sys/resource.h>
<sys/time.h>
<sys/timeb.h>
<sys/times.h>
<sys/types.h>
<time.h>
<time.h>.
<unistd.h>
<values.h>
<vector>
<windows.h>
=
==
>
>&
>();
>*
>::num_refs_limit
>;
>=
>>
?
??
A
A&
A()
A,
A.
A2
A2;
A;
A<CharString>*
A<CharString>::hash_fn
A<CharString>;
A<T>&
A<T>*
A<T>::compare(const
A<int>*
A<int>::hash_fn
A<int>;
AA
AA;
ACTION
ADT.
AFAC
AFX_STDAFX_H__B8E9B1B6_2345_11D3_B247_0004AC902FBE__INCLUDED_
AMP
AND
ANSI
ANY_OPTION
ANY_OPTION(desc,stmt)
APIENTRY
ARRAY
ARRAYS
A[0]
A[i][j]
A[i][j];
A[i][p]
A[k][k]
A[k][k];
A[k][p]
A[k][p];
A[lda,
About
Abstract
AbstractHashTable
AbstractHashTable,
AbstractHashTable.h
AbstractHashTable::add(newitem);
AbstractHashTable::find(&key);
AbstractHashTable<GenericHashTableItem<T>,T>
AbstractHashTable<GenericHashTableItem<T>,T>(init_size,
AbstractHashTable<GenericHashTableItem<T>,T>(nameBuff)
AbstractHashTable<GenericHashTableItem<T>,T>;
AbstractHashTable<SimpleHashTableItem<T>,T
AbstractHashTable<SimpleHashTableItem<T>,T>(init_size,
AbstractHashTable<SimpleHashTableItem<T>,T>(nameBuff)
AbstractHashTable<T,KEY>&
AbstractHashTable<T,KEY>::AbstractHashTable(const
AbstractHashTable<T,KEY>::AbstractHashTable(size_type
AbstractHashTable<T,KEY>::__stl_num_primes
AbstractHashTable<T,KEY>::__stl_prime_list[]
AbstractHashTable<T,KEY>::clear()
AbstractHashTable<T,KEY>::extract(T*
AbstractHashTable<T,KEY>::find(KEY&
AbstractHashTable<T,KEY>::insert(KEY*
AbstractHashTable<T,KEY>::insert(T*
AbstractHashTable<T,KEY>::next(T*
AbstractHashTable<T,KEY>::read(istream&
AbstractHashTable<T,KEY>::resize(const
AbstractHashTable<T,KEY>::statistics(ostream&
AbstractHashTable<T,KEY>::write(ostream&
AbstractHashTableItem*
AbstractHashTableItem*&
AbstractHashtable,
AbstractHeap
AbstractHeap&
AbstractHeap(nameBuff,initSize,quantumChoice)
AbstractHeap,
AbstractHeap.cpp
AbstractHeap.h
AbstractHeap::AbstractHeap(const
AbstractHeap::add(AbstractHeapItem*
AbstractHeap::add(item);
AbstractHeap::floatUp(int
AbstractHeap::prune()
AbstractHeap::read(istream&
AbstractHeap::refloatElement(int
AbstractHeap::remove(AbstractHeapItem*
AbstractHeap::remove(item,status);
AbstractHeap::remove(tmp,status);
AbstractHeap::sinkDown(int
AbstractHeap::swap(int
AbstractHeap::top();}
AbstractHeap::write(ostream&
AbstractHeap::~AbstractHeap()
AbstractHeap;
AbstractHeapItem
AbstractHeapItem's.
AbstractHeapItem()
AbstractHeapItem*
AbstractHeapItem*&
AbstractHeapItem**
AbstractSplayTree
AbstractSplayTree&
AbstractSplayTree(nameBuff),
AbstractSplayTree,
AbstractSplayTree.
AbstractSplayTree.cpp
AbstractSplayTree.h
AbstractSplayTree::AbstractSplayTree(const
AbstractSplayTree::add(AbstractSplayTreeItem*
AbstractSplayTree::add(newroot);
AbstractSplayTree::clear()
AbstractSplayTree::find(&key);}
AbstractSplayTree::find_rank(int
AbstractSplayTree::find_rank(r);}
AbstractSplayTree::print_tree(ostream&
AbstractSplayTree::rank();}
AbstractSplayTree::read(istream&
AbstractSplayTree::remove(AbstractSplayTreeItem*
AbstractSplayTree::remove(item,status);
AbstractSplayTree::splay(const
AbstractSplayTree::write(ostream&
AbstractSplayTree;
AbstractSplayTreeItem
AbstractSplayTreeItem()
AbstractSplayTreeItem*
AbstractSplayTreeItem*&
Accesses
Accesss
AcquireOwnership
AcquireOwnership)
AcquireOwnership))
AcquireOwnership);
AcquireOwnership);}
AcquireOwnership;
AcquireOwnership=1,
Adaptation
Adapted
Add
Added
Additionally,
Adds
After
Aho,
Algorithm
Algorithms
All
Allocates
Also
Always
An
Anonymous
Appends
Apply
Array
ArrayRef
ArrayRef()
ArrayRef<T,BasicArray<T>
ArrayRef<T,V>::copy_data(V*
ArrayRef<T,V>::reset_data(V*
ArrayRef<T,V>::set_data(T*
ArrayRef<char,BitArrayBase>
ArrayRef<char,BitArrayBase>()
ArrayRef<char,BitArrayBase>::copy_data(array);
ArrayRef<char,BitArrayBase>::set_data(Data_,Len_,
ArrayRef<char,BitArrayBase>;
ArraySanityChecking
ArraySanityChecking=0
ArraySanityChecking=1
Arrays
Arrays,
Art
As
Assign
AssumeOwnership
AssumeOwnership=2
Assumes
B
B()
B,
B;
BE
BIG
BINARYOP
BINARYOP(
BINARYOP(operator*=,*=,times,
BINARYOP(operator+=,+=,plus,
BINARYOP(operator-=,-=,minus,
BINARYOP(operator/=,/=,divide,
BINARYOP(opname,op1,pseudonym,
BINARYOP(opname,pseudonym)\
BIT(
BIT(X,i)
BOOL
BUFFERED_EXP
BUF_SIZE
BUG!
BUG:
BUG??
BUGGY!!!
BYTESIZE
Bartell,
Basic2DArray
Basic2DArray&
Basic2DArray's
Basic2DArray()
Basic2DArray(const
Basic2DArray.cpp
Basic2DArray.h
Basic2DArray;
Basic2DArray<T>
Basic2DArray<T>&
Basic2DArray<T>()
Basic2DArray<T>(array)
Basic2DArray<T>(array,nrows,own)
Basic2DArray<T>(nrows,ncols,array,own)
Basic2DArray<T>(nrows,ncols,d,own)
Basic2DArray<T>::construct(const
Basic2DArray<T>::free()
Basic2DArray<T>::operator&=(const
Basic2DArray<T>::operator()(const
Basic2DArray<T>::operator<<(const
Basic2DArray<T>::operator=(const
Basic2DArray<T>::operator[](const
Basic2DArray<T>::resize(const
Basic2DArray<T>::set_data(const
Basic2DArray<T>;
Basic2DArrayRep
Basic2DArrayRep()
Basic2DArrayRep<T>*
Basic2DArrayRep<T>;
Basic2DArray_double
Basic3DArray
Basic3DArray&
Basic3DArray's
Basic3DArray()
Basic3DArray(const
Basic3DArray.cpp
Basic3DArray.h
Basic3DArray;
Basic3DArray<##T##>
Basic3DArray<T>
Basic3DArray<T>&
Basic3DArray<T>::construct(const
Basic3DArray<T>::free()
Basic3DArray<T>::operator&=(const
Basic3DArray<T>::operator()(const
Basic3DArray<T>::operator<<(const
Basic3DArray<T>::operator=(const
Basic3DArray<T>::operator[](const
Basic3DArray<T>::resize(const
Basic3DArray<T>::set_data(const
Basic3DArray<T>;
Basic3DArrayRep
Basic3DArrayRep()
Basic3DArrayRep<T>*
Basic3DArrayRep<T>;
Basic3DArrayT(T)
Basic3DArray_##T
BasicArray
BasicArray's
BasicArray()
BasicArray(const
BasicArray,
BasicArray.
BasicArray.h
BasicArray;
BasicArray<IntVector>
BasicArray<ListItem<T*>*>
BasicArray<T>
BasicArray<T>&
BasicArray<T>()
BasicArray<T>();
BasicArray<T>(array)
BasicArray<T>(len,d,o)
BasicArray<T>*
BasicArray<T>::at(const
BasicArray<T>::construct(const
BasicArray<T>::free()
BasicArray<T>::operator&=(BasicArray<T>&
BasicArray<T>::operator&=(const
BasicArray<T>::operator=(const
BasicArray<T>::operator[](const
BasicArray<T>::resize(const
BasicArray<T>::set_data(const
BasicArray<T>::set_shared_data(T*
BasicArray<T>::set_subvec(const
BasicArray<Tuple1<T1>
BasicArray<Tuple2<T1,T2>
BasicArray<Tuple3<T1,T2,T3>
BasicArray<Tuple4<T1,T2,T3,T4>
BasicArray<Tuple5<T1,T2,T3,T4,T5>
BasicArray<Tuple6<T1,T2,T3,T4,T5,T6>
BasicArray<Tuple7<T1,T2,T3,T4,T5,T6,T7>
BasicArray<V>&
BasicArray<char>
BasicArray<double>
BasicArray<double>&
BasicArray<float>&
BasicArray<int>
BasicArray<int>&
BasicArray<int>::set_ref_limit(100);
BasicArray<size_t>
BasicArray_CharString
BasicArray_DEFN
BasicArray_double
BasicArray_double())
BasicArray_double___getitem__(BasicArray_double
BasicArray_double___setitem__(BasicArray_double
BasicArray_double___setitem__(_arg0,_arg1,_arg2);
BasicArray_double_data(_swigobj)
BasicArray_double_len(_swigobj)
BasicArray_double_nrefs(_swigobj)
BasicArray_double_resize(_swigobj,_swigarg0)
BasicArray_double_set_data(_arg0,_arg1,_arg2,_arg3);
BasicArray_double_set_data(_swigobj,_swigarg0,_swigarg1,_swigarg2)
BasicArray_double_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
BasicArray_double_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)
BasicArray_int
BasicArray_int())
BasicArray_int___getitem__(BasicArray_int
BasicArray_int___setitem__(BasicArray_int
BasicArray_int___setitem__(_arg0,_arg1,_arg2);
BasicArray_int_data(_swigobj)
BasicArray_int_len(_swigobj)
BasicArray_int_nrefs(_swigobj)
BasicArray_int_resize(_swigobj,_swigarg0)
BasicArray_int_set_data(_arg0,_arg1,_arg2,_arg3);
BasicArray_int_set_data(_swigobj,_swigarg0,_swigarg1,_swigarg2)
BasicArray_int_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
BasicArray_int_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)
Because
Begin
Bias
Bit-operations
BitArray
BitArray&
BitArray()
BitArray())
BitArray(const
BitArray.cpp
BitArray.h
BitArray::flip()
BitArray::flip(const
BitArray::nbits()
BitArray::operator()(const
BitArray::operator[](const
BitArray::put(const
BitArray::read(istream&
BitArray::reset()
BitArray::reset(const
BitArray::set()
BitArray::set(const
BitArray::shared_one(BitArray&
BitArray;
BitArrayBase
BitArrayBase&
BitArrayBase&)
BitArrayBase()
BitArrayBase(array)
BitArrayBase(const
BitArrayBase.
BitArrayBase.cpp
BitArrayBase.h
BitArrayBase::compare(const
BitArrayBase::construct(const
BitArrayBase::free()
BitArrayBase::initialize(const
BitArrayBase::operator!=
BitArrayBase::operator&=(BitArrayBase&
BitArrayBase::operator&=(const
BitArrayBase::operator<<(const
BitArrayBase::operator=((int)val);
BitArrayBase::operator=(const
BitArrayBase::operator==
BitArrayBase::operator>
BitArrayBase::operator>=
BitArrayBase::read(UnPackBuffer&
BitArrayBase::resize(const
BitArrayBase::set_shared_data(char*
BitArrayBase::write(PackBuffer&
BitArrayBase::write(ostream&
BitArrayBase;
BitArrayRef
BitArrayRef()
BitArrayRef();
BitArrayRef*
BitArrayRef::copy_data(BitArrayBase*
BitArrayRef::reset_data(BitArrayBase*
BitArrayRef;
BitArrayRep
BitArrayRep<T>::num_refs_limit
BitArraySanityChecking
BitArraySanityChecking=0
BitArraySanityChecking=1
BitArray___call__(BitArray
BitArray_at(_swigobj,_swigarg0,_swigarg1,_swigarg2)
BitArray_calc_nbits(_arg0);
BitArray_calc_nbits(_swigobj)
BitArray_compare(_swigobj,_swigarg0)
BitArray_data(_swigobj)
BitArray_flip(_arg0,_arg1);
BitArray_flip(_swigobj,_swigarg0)
BitArray_len(_swigobj)
BitArray_nbits(_swigobj)
BitArray_nrefs(_swigobj)
BitArray_put(_arg0,_arg1,_arg2);
BitArray_put(_swigobj,_swigarg0,_swigarg1)
BitArray_read(_swigobj,_swigarg0)
BitArray_reset(_arg0,_arg1);
BitArray_reset(_swigobj,_swigarg0)
BitArray_resize(_swigobj,_swigarg0)
BitArray_set(_arg0,_arg1);
BitArray_set(_swigobj,_swigarg0)
BitArray_write(_swigobj,_swigarg0)
BitArrays
Bob
Boolean.h
Both
Brian
Bump
By
C
C++
C++,
C++-compiled
C++.
C,
C-based
C.
C/C++
CFLAGS
CFLAG_OPTN
CFLAG_OPTN(char,
CFLAG_OPTN(char,stmt)
CFLAG_OPTN(s,stmt)
CHAR_BIT))
CHECKSTATE
CLASS
CLASS_PARAMETER(eventLog);
CLASS_PARAMETER(messageLog);
CLASS_PARAMETER(name)
CLASS_PARAMETER(param1);
CLASS_PARAMETER(param2);
CLASS_PARAMETER_DEF(c1,param1,0,50,100);
CLASS_PARAMETER_DEF(c1,param2,0,60,100);
CLASS_PARAMETER_DEF(class,name,min,default,max)
CLASS_PARAMETER_DEF(logEvent,eventLog,0,0,MAXINT);
CLASS_PARAMETER_DEF(uMPI,messageLog,0,0,1);
CLKTICK
CLK_TCK
CLK_TCK));
CLOCKS_PER_SEC
CM
CM5
CMMD_node_timer_busy(CM5_MP_TIMER_NUMBER);
CMMD_node_timer_clear(CM5_MP_TIMER_NUMBER);
CMMD_node_timer_elapsed(CM5_MP_TIMER_NUMBER);
CMMD_node_timer_start(CM5_MP_TIMER_NUMBER);
CMMD_node_timer_stop(CM5_MP_TIMER_NUMBER);
CMSparseMatrix
CMSparseMatrix(
CMSparseMatrix;
CMSparseMatrix<Ereal<T>
CMSparseMatrix<T>&
CMSparseMatrix<T>::CMSparseMatrix(
CMSparseMatrix<T>::adjoinColumn(int
CMSparseMatrix<T>::convert(const
CMSparseMatrix<T>::delete_col(const
CMSparseMatrix<T>::delete_element(const
CMSparseMatrix<T>::delete_row(const
CMSparseMatrix<T>::operator()(const
CMSparseMatrix<T>::read(istream&
CMSparseMatrix<T>::write(ostream&
CMSparseMatrix<T>;
CMatrix
CODE
COMMAND_LINE_ERROR
COMMAND_LINE_ERROR.
COMP_VOID
COMP_VOID*));
CONSTANTS
COUGAR
CPLANT
CPLEX's
CPU
CPUParentChildSeconds
CPUParentSeconds.
CPUSeconds
CPUSeconds()
CPUSeconds();
CPU_start_time
CPU_start_time);
CPU_start_time=0.0;
CRandVar
CRandVar___call__(CRandVar
CRandVar_generator(_swigobj)
CRandVar_set_generator(CRandVar
CRandVar_set_generator(_arg0,_arg1);
California.
Call
Calls
Can
Cancel
Categories
Changes
Chapter
CharString
CharString&
CharString())
CharString();
CharString(char*
CharString(const
CharString.cpp
CharString.h
CharString::CharString()
CharString::CharString(char*
CharString::CharString(const
CharString::construct(const
CharString::operator!=
CharString::operator+=(const
CharString::operator<(const
CharString::operator==
CharString::operator>(const
CharString::read(UnPackBuffer&
CharString::read(istream&
CharString::resize(const
CharString::set_subvec(const
CharString::write(ostream&
CharString___getitem__(CharString
CharString___setitem__(CharString
CharString___setitem__(_arg0,_arg1,_arg2);
CharString_data(_swigobj)
CharString_len(_swigobj)
CharString_nrefs(_swigobj)
CharString_read(_swigobj,_swigarg0)
CharString_resize(_swigobj,_swigarg0)
CharString_set_subvec(_arg0,_arg1,_arg2,*_arg3,_arg4);
CharString_set_subvec(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)
CharString_write(_swigobj,_swigarg0)
Check
Checks
Cholesky
Class
ClassRef
ClassRef()
ClassRef.h
ClassRef<BasicArray<T>
ClassRef<V>
ClassRef<V>::acquire(V*
ClassRef<V>::const_ref
ClassRef<V>::num_refs_limit
ClassRef<V>::num_refs_limit=32;
ClassRef<V>::release(V*
ClassRef<V>::resize_ref_ptrs(const
Classes
Cleans
Code
Coersion
Common()::end()
CommonIO
CommonIO())
CommonIO();
CommonIO,
CommonIO-based
CommonIO.cpp
CommonIO.h
CommonIO::CommonIO()
CommonIO::IO_Rank
CommonIO::IOflush()
CommonIO::MapCerr
CommonIO::MapCin
CommonIO::MapCout
CommonIO::Rank
CommonIO::Size
CommonIO::StrCerr;
CommonIO::StrCout;
CommonIO::begin()
CommonIO::begin(),
CommonIO::begin().
CommonIO::begin();
CommonIO::begin_buffered()
CommonIO::begin_buffered();
CommonIO::begin_end_counter
CommonIO::begin_tagging();
CommonIO::begin_tagging(5);
CommonIO::begin_tagging(_arg0);
CommonIO::common_cerr
CommonIO::common_cin
CommonIO::common_cout
CommonIO::common_ofstr;
CommonIO::end()
CommonIO::end();
CommonIO::end_all()
CommonIO::end_all();
CommonIO::end_tagging();
CommonIO::errs();
CommonIO::flush();
CommonIO::flush();}
CommonIO::flush_flag
CommonIO::flush_stream(strstream&
CommonIO::header_flag
CommonIO::ins();
CommonIO::io_buffering
CommonIO::io_mapping
CommonIO::map_off()
CommonIO::map_on()
CommonIO::nref
CommonIO::numDigits
CommonIO::numDigits);
CommonIO::o_stream(const
CommonIO::off()
CommonIO::outs();
CommonIO::pStrCerr
CommonIO::pStrCout
CommonIO::reset()
CommonIO::reset();
CommonIO::reset_map()
CommonIO::seqNum
CommonIO::setIOFlush(_arg0);
CommonIO::setIORank(_arg0);
CommonIO::set_cerr(_arg0);
CommonIO::set_cin(_arg0);
CommonIO::set_cout(_arg0);
CommonIO::set_ofile(_arg0);
CommonIO::set_ofile(const
CommonIO::set_streams(&ofstr,&ofstr,&stdcin);
CommonIO::set_streams(_arg0,_arg1,_arg2);
CommonIO::std_cerr
CommonIO::std_cerr;
CommonIO::std_cin
CommonIO::std_cin;
CommonIO::std_cout
CommonIO::std_cout;
CommonIO::stream_flag
CommonIO::sync_stdio();
CommonIO::tagging
CommonIO::~CommonIO()
CommonIO;
CommonIO_debug_get(_swigobj)
CommonIO_debug_set(_swigobj,_swigval)
CommonIO_setDebug(_arg0,_arg1);
CommonIO_setDebug(_swigobj,_swigarg0)
CommonIO_verbosity(_swigobj,_swigarg0)
Compare
Compares
Compilers
Compute
Computer
Computes
Concatenate
Consequently,
Construct
Constructor
Constructor,
Constructor.
Contains
Convert
Copies
Copy
Copyright
Corman,
Correct?
Create
Creates
CurrentTime
CurrentTime();
Currently,
D.
DAKOTA
DATA
DATA&
DATA>
DATA_OPTN
DATA_OPTN(s,desc,stmt)
DATA_OPTN(string,desc,stmt)
DATA_OPTN2
DATA_OPTN2(s,desc,stmt1,stmt2)
DATA_OPTN2(string,desc,stmt1,stmt2)
DBL_MAX
DDJ.
DEBUG
DEBUGGING
DEBUGPR
DEBUGPR(dlevel,cmd)
DEBUGPR,
DEBUGPRP(dlevel,cmd)
DEBUGPRX(dlevel,ptr,stuff)
DEBUGPRX(ptr,dlevel,stuff)
DEBUGPRX,
DEBUGPRXP(dlevel,ptr,stuff)
DEBUGPRXP(ptr,dlevel,stuff)
DEBUG_COMMONIO
DEC.
DECLARATIONS
DEFINE
DEFINITIONS
DESCRIPTION:
DLL
DLL.
DLL_PROCESS_ATTACH:
DLL_PROCESS_DETACH:
DLL_THREAD_ATTACH:
DLL_THREAD_DETACH:
DO_STANDARD_COMMAND_LINE(stmts)
DUniform
DUniform&
DWORD
Data
Data(1)
Data(Data_)
Data(Data_),
Data)
Data))
Data,
Data.
Data.resize(10);
Data.resize(Len
Data.resize(curr
Data.resize(max((Data.size()
Data.resize(max(1,(Len+1)));
Data.resize(max(1,Len));
Data;
Data;\
Data;}
Data=0;
Data=0;}
Data=NULL;
DataNotOwned
DataNotOwned);
DataNotOwned;
DataNotOwned=0,
Data[(2*idx)/BYTESIZE]
Data[(2*idx)/BYTESIZE];
Data[--Len];
Data[0];
Data[First];
Data[Len++]
Data[Len-1];
Data[Len]
Data[Len];
Data[curr+next]
Data[curr]
Data[curr];
Data[i
Data[i/BYTESIZE]
Data[i]
Data[i])
Data[i];
Data[i];}
Data[idx
Data[idx/BYTESIZE]
Data[idx];
Data[index++];
Data[len+start]
Data[len]
Data[mylen]
Data_)
Data_,
Data_;
Debug
December
Declares
Decomposition
Default
Define
Defines
Definition
Definitions
Delete
Deletes
Depending
Desctructor.
Destructor
Destructor.
Developed
Diego.
Discretize(urnd(),
Divides
DllMain(
Do
DoErrAbort(__FILE__,__LINE__,str);
DoErrAbort(const
DoErrExit(__FILE__,__LINE__,str);
DoErrExit(const
DoWarning(__FILE__,__LINE__,str);
DoWarning(const
Does
Double
DoubleMatrix
DoubleMatrix&
DoubleMatrix.h
DoubleMatrix;
DoubleType
DoubleVector
DoubleVector.h
DoubleVector;
Dummy
Dummy,
E.
EOF
EOF);
ERR
ERR.
ERR;
ERR;}
ERRORS!
EVENT_LOGGING_PRESENT
EXTERNS
Eckstein
Elapsed
ElapsedCPUSeconds
ElapsedCPUSeconds();
ElapsedWallClockSeconds
ElapsedWallClockSeconds();
ElapsedWallClockSeconds.
Eldred
Element-wise
Empties
Empty
End
Ends
EnumBitArray
EnumBitArray&
EnumBitArray()
EnumBitArray(const
EnumBitArray.h
EnumBitArray<T>&
EnumBitArray<T>::operator()(const
EnumBitArray<T>::operator=(const
EnumBitArray<T>::operator[](const
EnumBitArray<T>::put(const
EnumBitArray<T>::read(istream&
EnumBitArray<T>::write(ostream&
EnumBitArraySanityChecking
EnumDataOwned
Equivalent
Ereal
Ereal(const
Ereal.cpp
Ereal.h
Ereal;
Ereal<Type>
Ereal<Type>&
Ereal<Type>&)
Ereal<Type>&);
Ereal<Type>&,
Ereal<Type>(-1.0,
Ereal<Type>(-num.val,
Ereal<Type>(1.0,
Ereal<Type>(val,Finite);
Ereal<Type>::Ereal(const
Ereal<Type>::check_if_infinite(Type&
Ereal<Type>::check_if_infinite(xval,xFinite);
Ereal<Type>::check_if_infinite(yval,yFinite);
Ereal<Type>::div(const
Ereal<Type>::div(x.val,
Ereal<Type>::div(xval,
Ereal<Type>::minus(const
Ereal<Type>::minus(x.val,
Ereal<Type>::minus(xval,
Ereal<Type>::mult(const
Ereal<Type>::mult(x.val,
Ereal<Type>::mult(xval,
Ereal<Type>::negative_infinity(-1.0,false);
Ereal<Type>::negative_infinity_val
Ereal<Type>::operator
Ereal<Type>::plus(const
Ereal<Type>::plus(x.val,
Ereal<Type>::plus(xval,
Ereal<Type>::positive_infinity(1.0,false);
Ereal<Type>::positive_infinity_val
Ereal<Type>::read(UnPackBuffer&
Ereal<Type>::read(std::istream&
Ereal<Type>::write(PackBuffer&
Ereal<Type>::write(std::ostream&
Ereal<double>
Ereal<double>::negative_infinity;
Ereal<double>::negative_infinity_val
Ereal<double>::positive_infinity;
Ereal<double>::positive_infinity_val
Ereal<float>::negative_infinity_val
Ereal<float>::positive_infinity_val
ErrAbort(str)
ErrExit(str)
ErrReturn(str)
Every
Exclude
Executes
Exit
Exp(x)
Extends
Externs
FALSE
FALSE)
FALSE,
FALSE.
FALSE;
FALSE;\
FILE
FILE*
FLAG_OPTN
FLAG_OPTN(s,stmt)
FLAG_OPTN(string,
FLAG_OPTN(string,stmt)
FREE_ARGS
FREE_ARGS()
FREE_ARGS_CONT
FREE_ARGS_CONT()
Fills
Finally,
Find
Finite
Finite(f_flag)
Finite)
Finite);
Finite;
First
First(1),
First.resize(MAXTYPES);
First;
First[i]
First[type_id]
First[type_id];
Flag
Flip
Float
FloatMatrix
FloatVector
Flush
Flush(ostream&
Flush;
For
ForAllElements(index,set,elt_type)\
Forward
Free
Freeze
Function
Functional
Further,
G
G)
G*G'.
G,
G.
GLOBAL_PARAMETER(name)
GLOBAL_PARAMETER_DEF(debug,0,0,MAXDOUBLE);
GLOBAL_PARAMETER_DEF(name,min,default,max)
GLOBAL_PARAMETER_DEF(param3,0,1,1);
G[i][j]
G[i][k]
G[k][k]
GeneratingLaTeX
Generator
Generic
GenericHashTable
GenericHashTable.H
GenericHashTable;
GenericHashTable<A<CharString>
GenericHashTable<A<CharString>>
GenericHashTable<A<T>
GenericHashTable<A<int>
GenericHashTable<A<int>>
GenericHashTableItem
GenericHashTableItem(T*
GenericHashTableItem<A<T>
GenericHeap
GenericHeap.cpp
GenericHeap.h
GenericHeap;
GenericHeap<T>&
GenericHeap<T>::compare(const
GenericHeap<T>::deleteElement(const
GenericHeap<T>::find(
GenericHeap<T>::read_item(istream&
GenericHeap<T>::~GenericHeap<T>()
GenericHeap<T>;
GenericHeapItem
GenericHeapItem(const
GenericHeapItem<T>(key);
GenericHeapItem<T>*
GenericHeapItem<T>*&
GenericKey
GenericKey.h
GenericKey<KEY,DATA>&
GenericSplayTree
GenericSplayTree.cpp
GenericSplayTree.h
GenericSplayTree;
GenericSplayTree<T>&
GenericSplayTree<T>::compare(const
GenericSplayTree<T>::insert(T*
GenericSplayTree<T>::insert(const
GenericSplayTree<T>::read_item(istream&
GenericSplayTree<T>::write_item(ostream&
GenericSplayTree<T>::~GenericSplayTree()
GenericSplayTree<T>::~GenericSplayTree<T>()
GenericSplayTree<T>;
GenericSplayTreeItem
GenericSplayTreeItem(
GenericSplayTreeItem(key);
GenericSplayTreeItem*
GenericSplayTreeItem<T>(key);
GenericSplayTreeItem<T>*
GenericSplayTreeItem<T>*&
Get
Gets
Grab
HANDLE
HASH_1
HASH_1)
HASH_2
HASH_2;
HASH_3
HASH_3)
HOST_NODE
HOST_NODE)
HOST_NODE))
HOST_NODE;
HPUX
HUH???
Handle
Hart
Hash
HashBJ.C
Header
Headers
Heap
Helper
Here,
Hopefully
Hopefully,
Housekeeping
However,
I
I'm
I've
I/O
I/O,
I/O.
ID
IF_LOGGING_COMPILED(arbitraryCode)
IF_LOGGING_EVENTS(level,action)
IF_LOGGING_EVENTS(level,if
IF_LOGGING_EVENTS(level,logEvent::log_##how(state);)
INCLUDES
INDEX
INFO
INLINED
INT_MAX
IO
IO,
IO.
IO;
IO_Rank
IO_Rank;
IOflush();
If
Ignore
Implementation
Implements
In
Including
Ind
Ind.
Indeces
Indeterminate
Indeterminate:
Index
Indicate
Indicates
Initialie
InitializdTiming.
Initialize
InitializeTiming();
InitializeTiming.
Initializes
Insert
Insertion
Inserts
IntMatrix
IntMatrix.h
IntMatrix;
IntVector
IntVector&
IntVector.h
IntVector;
IntVector_divide(_arg0,*_arg1,*_arg2);
IntVector_divide(_swigobj,_swigarg0,_swigarg1)
IntVector_minus(_arg0,*_arg1,*_arg2);
IntVector_minus(_swigobj,_swigarg0,_swigarg1)
IntVector_plus(_arg0,*_arg1,*_arg2);
IntVector_plus(_swigobj,_swigarg0,_swigarg1)
IntVector_times(_arg0,*_arg1,*_arg2);
IntVector_times(_swigobj,_swigarg0,_swigarg1)
Integer
Interface
Irecv.
Isend
Issend.
It
Jan
Jeff
Jenkins
Jenkins,
Jonathan
K
K>0
KEY
KEY&
KEY,
KEY>
Kalyan
Kernighan
Key
Key()
Key(*Key_)
Key(Key_)
Key;
Key;}
Key_)
Keyptr(Key_)
Keyptr->compare(key);}
Keyptr;
Keyptr;}
Knuth,
Knuth~\cite{Knu}.
Kohn
LCG(100));
LCG(100);
LCG*
LEN
LHS
LINUX
LOG_EVENT(level,how,state)
LOG_EVENT_CONDITIONAL(level,cond,how,state)
LOG_RECV(s)
LOG_RECV(status);
LOG_RECV(status_array+i);
LOG_SEND(a,b,c,d)
LOG_SEND(dest,tag,count,datatype);
LOOKUPA
LPARX.
LPVOID
L_2
Last
Last(1)
Last.resize(MAXTYPES);
Last;
Last[i]
Last[type_id]
Last[type_id]=Prev[candidate];
Last[type_id]=current;
Leading
Left()
Len
Len(0)
Len(0),
Len)
Len))
Len));
Len);
Len++;
Len,
Len--;
Len-1;
Len;
Len;}
Len=0;
Len_,
Len_;
Length
Let's
Lieseron
Like
LinPack
Linderoth.
LinkedList
LinkedList()
LinkedList.
LinkedList.cpp
LinkedList.h
LinkedList;
LinkedList<T*>
LinkedList<T>
LinkedList<T>&
LinkedList<T>()
LinkedList<T>::counter=0;
LinkedList<T>::empty()
LinkedList<T>::extract(ListItem<T>*
LinkedList<T>::find(
LinkedList<T>::insert(
LinkedList<T>::~LinkedList()
LinkedList<T>;
List
ListItem
ListItem's
ListItem's,
ListItem(
ListItem*
ListItem,
ListItem<T*>*
ListItem<T*>::delete_unused();
ListItem<T>
ListItem<T>&
ListItem<T>(data);
ListItem<T>*
ListItem<T>*&
ListItem<T>::delete_unused()
ListItem<T>::delete_unused();
ListItem<T>::operator
Log
Look
Lower
M1Ncols
M1Nrows
M2Ncols
MAD
MATHEMATICAL
MATRICES
MAXDOUBLE
MAXDOUBLE;
MAXFLOAT;
MAXINT
MAXTABLESIZE
MAXTABLESIZE;
MAXTYPES
MAXTYPES;
MEMDEBUG_DUMP(os)
MEMDEBUG_END_DEL(this)
MEMDEBUG_END_NEW(this)
MEMDEBUG_END_RESIZE(this)
MEMDEBUG_START_DEL(this)
MEMDEBUG_START_NEW(this)
MEMDEBUG_START_RESIZE(this)
METHOD
METHODS
MICROSECONDS
MICROSECONDS*usec;
MILLISECONDS
MILLISECONDS*(tb.millitm
MILLISECONDS*tb.millitm);
MILLISECONDS*tb.millitm;
MIMD
MIN
MIN(a,b)
MINDOUBLE;
MINFLOAT;
MISCELLANEOUS
MLL.h
MPE
MPE.
MPE_Describe_state(startEvent,endEvent,(char*)
MPE_Init_log();
MPE_Log_receive(status->MPI_SOURCE,
MPE_Log_send(dest,tag,count*typeSize);
MPE_Start_log();
MPI
MPI,
MPI.
MPI_Abort
MPI_Abort(MPI_COMM_WORLD,1);
MPI_Aint
MPI_Attr_get(MPI_COMM_WORLD,MPI_IO,&mpiIOP,&flag);
MPI_Barrier(comm);
MPI_Bcast(buffer,count,datatype,root,comm);
MPI_CHAR,
MPI_COMM_WORLD
MPI_COMM_WORLD);
MPI_COMM_WORLD,
MPI_COMM_WORLD;
MPI_Cancel(request);
MPI_Comm
MPI_Comm_compare(comm,
MPI_Comm_rank(MPI_COMM_WORLD,&Rank);
MPI_Comm_rank(MPI_COMM_WORLD,&rank);
MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);
MPI_Comm_rank(comm,&rank);
MPI_Comm_rank(uMPI::comm,&rank);
MPI_Comm_size(MPI_COMM_WORLD,&Size);
MPI_Comm_size(comm,&size);
MPI_Datatype
MPI_Finalize();
MPI_Get_count(status,datatype,&count);
MPI_IO
MPI_IO==rank
MPI_Init(argcP,argvP);
MPI_Initialized(&mpiActive);
MPI_Initialized(&running);
MPI_Irecv(buffer,count,datatype,source,tag,comm,
MPI_Isend(buffer,count,datatype,dest,tag,comm,
MPI_Issend(buffer,count,datatype,dest,tag,comm,
MPI_Pack((void*)(&c),
MPI_Pack((void*)data,
MPI_Pack_size(num,
MPI_REQUEST_NULL)
MPI_REQUEST_NULL;
MPI_Recv(buffer,count,datatype,source,tag,comm,
MPI_Reduce(&value,&result,1,MPI_DOUBLE,MPI_MAX,root,
MPI_Reduce(&value,&result,1,MPI_DOUBLE,MPI_SUM,root,
MPI_Reduce(&value,&result,1,MPI_INT,MPI_MAX,root,
MPI_Reduce(&value,&result,1,MPI_INT,MPI_SUM,root,
MPI_Reduce(sendbuf,recvbuf,count,datatype,op,root,
MPI_Request
MPI_Request*
MPI_Request;
MPI_Request_free(request);
MPI_SUCCESS)
MPI_Send(buffer,count,datatype,dest,tag,comm);
MPI_Status
MPI_Status*
MPI_Status;
MPI_Test(request,flag,status);
MPI_Testsome(incount,request_array,&outcount,
MPI_Type_extent(t,&extent);
MPI_Type_size(t,&typeSize);
MPI_Unpack(buffer,
MPI_Wait(request,status);
MSE:
MVC++
M_E
M_PI
Macro
Macros
Make
Map#
MapCerr;
MapCin;
MapCout;
Max
Maybe
Measures
Merge
Method
Method:
Michael
Microsoft
Misc
Miscellaneous
MixedIntVars
MixedIntVars&
MixedIntVars(const
MixedIntVars.cpp
MixedIntVars.h
MixedIntVars::MixedIntVars(const
MixedIntVars::compare(const
MixedIntVars::construct(const
MixedIntVars::free()
MixedIntVars::get(const
MixedIntVars::getBit(const
MixedIntVars::getDouble(const
MixedIntVars::getGeneralInt(const
MixedIntVars::getInt(const
MixedIntVars::operator&=(const
MixedIntVars::operator<<(const
MixedIntVars::operator=(const
MixedIntVars::operator==(const
MixedIntVars::read(UnPackBuffer&
MixedIntVars::read(istream&
MixedIntVars::resize(const
MixedIntVars::set(const
MixedIntVars::setBit(const
MixedIntVars::setDouble(const
MixedIntVars::setGeneralInt(const
MixedIntVars::setInt(const
MixedIntVars::write(PackBuffer&
MixedIntVars::write(ostream&
MixedIntVars;
MixedIntVarsRep
MixedIntVarsRep(int
MixedIntVarsRep(nbits,
MixedIntVarsRep*
MixedIntVarsRep.
Move
MultiLL
MultiLL();
MultiLL.cpp
MultiLL::MultiLL()
MultiLL::clean_up(int
MultiLL::find_value(int
MultiLL::insert(int
MultiLL::next_free()
MultiLL::remove_index(int
MultiLL::remove_value(int
MultiLL::resize()
MultiLL::set_up(int
MultiLL::show_list(int
MultiLL::sublist_empty(int
MultiLL::~MultiLL()
Multiplies
My
N,
N.left
N.left;
N.right
N.right;
NCols
NEW
NEXT
NO
NON_ANSI
NON_SWITCH
NON_SWITCH(desc,stmt)
NON_SWITCH.
NOT
NOTE:
NRows
NT.
NULL
NULL)
NULL))
NULL);}
NULL,
NULL.
NULL;
NaN
Ncols;
Ncols=0;
Need
Next
Next.resize(MAXTABLESIZE);
Next;
Next[Prev[candidate]]
Next[Prev[candidate]]=OPEN;
Next[candidate]
Next[candidate];
Next[current]=OPEN;
Next[current]=next_free();
Next[i]
No
No,
Normal
Normal(_swigarg0,_swigarg1,_swigarg2))
Normal_mean_get(_swigobj)
Normal_mean_set(_swigobj,_swigval)
Normal_stddev_get(_swigobj)
Normal_stddev_set(_swigobj,_swigval)
Not
Note
Note,
Note:
Nothing
Now
Nrows;
Nrows=0;
Null
Num2DArray
Num2DArray&
Num2DArray()
Num2DArray(const
Num2DArray.cpp
Num2DArray.h
Num2DArray:
Num2DArray;
Num2DArray<T>
Num2DArray<T>&
Num2DArray<T>&);
Num2DArray<T>&,
Num2DArray<T>::operator-
Num2DArray<T>::opname(const
Num2DArray<T>::pseudonym(const
Num2DArray<T>;
Num2DArray<double>
Num2DArray<int>
Num3DArray;
Num3DArray<T>;
NumArray
NumArray&
NumArray()
NumArray(const
NumArray.h
NumArray:
NumArray;
NumArray<T>
NumArray<T>&
NumArray<T>&);
NumArray<T>&,
NumArray<T>::initialize(T*
NumArray<T>::operator%(const
NumArray<T>::operator-
NumArray<T>::opname(const
NumArray<T>::pseudonym(const
NumArray<double>
NumArray<int>
NumArray_double
NumArray_double())
NumArray_int
NumArray_int())
NumBinaryVars(nBinVars),
NumBinaryVars;
NumIntegerVars(nIntVars),
NumIntegerVars;
NumVars(nBinVars+nIntVars+nDblVars),
NumVars;
Number
Numerical
OFF
OFF))
OFF;
OK
OK.
OK;
OK;}
OLD
OLD_MEDIAN
ON
ON)
ON.
ON/OFF
ON;
OPEN
OPEN)
OPEN)&&(table[found_index]
OPEN){
OPEN)||(Reserved[i]==1))
OPEN;
OPERATIONS
OPT_ARG
OPT_ARG(desc,stmt)
OR
ORDERSENSE
OSF
Of
Only
Open
Opens
Order
OrderSense
OrderedList
OrderedList()
OrderedList(const
OrderedList.
OrderedList.cpp
OrderedList.h
OrderedList;
OrderedList<T,V>&
OrderedList<T,V>::counter=0;
OrderedList<T,V>::empty()
OrderedList<T,V>::extract(OrderedListItem<T,V>*
OrderedList<T,V>::extract_all()
OrderedList<T,V>::find(
OrderedList<T,V>::insert(
OrderedList<T,V>::operator=(const
OrderedList<T,V>::update(OrderedListItem<T,V>*
OrderedList<T,V>::~OrderedList()
OrderedList<T,V>;
OrderedList<void*,double>();
OrderedList<void*,double>*
OrderedListItem
OrderedListItem(
OrderedListItem*
OrderedListItem,
OrderedListItem.
OrderedListItem<T,V>
OrderedListItem<T,V>&
OrderedListItem<T,V>(data,key);
OrderedListItem<T,V>*
OrderedListItem<T,V>*&
OrderedListItem<T,V>::delete_unused()
OrderedListItem<T,V>::delete_unused();
OrderedListItem<T,V>::operator
OrderedListItem<T>*
OrderedListItem<void*,double>*
OrderedListItems
OrderedListItems,
OrderedSet
OrderedSet();
OrderedSet.cpp
OrderedSet.h
OrderedSet<T>
OrderedSet<T>&
OrderedSet<T>&,
OrderedSet<T>::OrderedSet()
OrderedSet<T>::add(
OrderedSet<T>::first(
OrderedSet<T>::index(const
OrderedSet<T>::is_disjoint(const
OrderedSet<T>::next(
OrderedSet<T>::read(UnPackBuffer&
OrderedSet<T>::read(istream&
OrderedSet<T>::remove(
OrderedSet<T>::write(PackBuffer&
OrderedSet<T>::write(ostream&
OrderedSetIndex
OrderedSetIndex&
OrderedSetIndex;
Otherwise,
Output
Ownership
P
PACKBUF(char,MPI_CHAR)
PACKBUF(double,MPI_DOUBLE)
PACKBUF(float,MPI_FLOAT)
PACKBUF(int,MPI_INT)
PACKBUF(long,MPI_LONG)
PACKBUF(short,MPI_SHORT)
PACKBUF(type,mpitype)
PACKBUF(unsigned_char,MPI_UNSIGNED_CHAR)
PACKBUF(unsigned_int,MPI_UNSIGNED)
PACKBUF(unsigned_long,MPI_UNSIGNED_LONG)
PACKBUF(unsigned_short,MPI_UNSIGNED_SHORT)
PACKSIZE(char,MPI_CHAR)
PACKSIZE(double,MPI_DOUBLE)
PACKSIZE(float,MPI_FLOAT)
PACKSIZE(int,MPI_INT)
PACKSIZE(long,MPI_LONG)
PACKSIZE(short,MPI_SHORT)
PACKSIZE(type,mpitype)
PACKSIZE(unsigned_char,MPI_UNSIGNED_CHAR)
PACKSIZE(unsigned_int,MPI_UNSIGNED)
PACKSIZE(unsigned_long,MPI_UNSIGNED_LONG)
PACKSIZE(unsigned_short,MPI_UNSIGNED_SHORT)
PARAGON
PAUSE
PAUSE()
PI
PM_LCG
PM_LCG(_swigarg0))
PM_LCG_asDouble(_swigobj)
PM_LCG_asLong(_swigobj)
PM_LCG_getSeed(_swigobj)
PM_LCG_read(_swigobj,_swigarg0)
PM_LCG_reseed(_arg0,_arg1);
PM_LCG_reseed(_swigobj,_swigarg0)
PM_LCG_reset(_arg0);
PM_LCG_reset(_swigobj)
PM_LCG_write(_swigobj,_swigarg0)
PPRINT_DO_COMMAND
PRELIMINARY
PRINT_MARKER_REQUEST
PRINT_MARKER_RETURN
PYTHON
Pack
PackBuf.cpp
PackBuf.h
PackBuffer
PackBuffer&
PackBuffer(int
PackBuffer::pack(const
PackBuffer::resize(const
PackSize
PackSize(const
Pentium
Perform
Permission
Perumalla
Pointer
Portable
Portions
Possible
Potential
Presently,
Prev.resize(MAXTABLESIZE);
Prev;
Prev[Next[candidate]]
Prev[Next[candidate]]=OPEN;
Prev[Next[current]]=current;
Prev[candidate]
Prev[candidate];
Prev[current]
Prev[i]
Previously
Print
Process
Processes
Programming
Provide
Purpose:
Put
PyImport_Inittab
PyInt_FromLong((long)
PyMethodDef
PyModule_GetDict(m);
PyObject
PyString_AsString(val);
PyString_FromString(ptemp);
Py_INCREF(Py_None);
Py_Main(argc,argv);
Py_Main(int,
Py_None;
Python
Python's
Python-1.5.
Python1.3
Q'y
QR
QueueArray
QueueArray();
QueueArray.cpp
QueueArray.h
QueueArray<T>
QueueArray<T>&
QueueArray<T>::QueueArray()
QueueArray<T>::add(
QueueArray<T>::clear()
QueueArray<T>::read(UnPackBuffer&
QueueArray<T>::read(istream&
QueueArray<T>::remove(
QueueArray<T>::write(PackBuffer&
QueueArray<T>::write(ostream&
QueueList
QueueList()
QueueList.h
QueueList<##T##>
QueueList<T>
QueueListT(T)
QueueList_##T
Qy
R
R.
REAL
REAL.
REAL;
REALType
REALType,
REFER_DEBUG(pointer)
REQ_ARG
REQ_ARG(desc,stmt)
REQ_ARG,
RESET_BIT(
RESET_BIT(X,i)
RM
RMSparseMatrix
RMSparseMatrix(
RMSparseMatrix;
RMSparseMatrix<T>&
RMSparseMatrix<T>::adjoinRow(int
RMSparseMatrix<T>::convert(const
RMSparseMatrix<T>::delete_col(const
RMSparseMatrix<T>::delete_element(const
RMSparseMatrix<T>::delete_row(const
RMSparseMatrix<T>::operator()(const
RMSparseMatrix<T>::read(istream&
RMSparseMatrix<T>::resize(const
RMSparseMatrix<T>::write(ostream&
RMSparseMatrix<T>;
RMatrix
RNG
RNG*
RNG_asDouble(_swigobj)
RNG_asFloat(_swigobj)
RNG_asLong(_swigobj)
RNG_reset(_arg0);
RNG_reset(_swigobj)
RNGs
RS6K
RWTimer's
Rank
Rank))
Rank;
Rank_)
Rank_;
Read
RealMatrix
RealMatrix.h
RealVector
RealVector*
RealVector.h
RealVector;
RealVector_divide(_arg0,*_arg1,*_arg2);
RealVector_divide(_swigobj,_swigarg0,_swigarg1)
RealVector_minus(_arg0,*_arg1,*_arg2);
RealVector_minus(_swigobj,_swigarg0,_swigarg1)
RealVector_plus(_arg0,*_arg1,*_arg2);
RealVector_plus(_swigobj,_swigarg0,_swigarg1)
RealVector_times(_arg0,*_arg1,*_arg2);
RealVector_times(_swigobj,_swigarg0,_swigarg1)
Recipies
Recv.
Redirect
Regents
Related
Remove
Removes
Repeating
Reserved.resize(MAXTABLESIZE);
Reserved;
Reserved[Next[current]]=1;
Reserved[candidate]
Reserved[i]
Reset
Resets
Resize
Resizes
Return
Returns
Richie.
Right()
Rivest
Routine
Routines
Row-wise
S.
SET_BIT(
SET_BIT(X,i)
SGI
SGOPT)
SHOULD
SIMPLE
SIMPLE_CFLAG_OPTN
SIMPLE_CFLAG_OPTN(char,var)
SIMPLE_CFLAG_OPTN(s,var)
SIMPLE_FLAG_OPTN
SIMPLE_FLAG_OPTN(s,var)
SIMPLE_FLAG_OPTN(string,var)
SOLARIS
SORT_ARGS
SORT_FORM
SORT_FORM));
SORT_RETURN
SORT_RETVAL
SORT_VOID
SORT_VOID*
STANDARD
STDAFX.H
STDIO
STDLIB_MPI
STR
STR(10);
SWIG
SWIGCODE
SWIGEXPORT(a,b)
SWIGEXPORT(void,initutilibc)()
SWIGPYTHON
SWIG_MakePtr(char
SWIG_RegisterMapping(char
SWIG_addvarlink(PyObject
SWIG_globals
SWIG_init
SWIG_init();
SWIG_newvarlink();
Same
San
Sanity
Scale
Scott
Search
Section~\ref{compare}
See
Seminumerical
Send
Send.
Sense
Sense(increasing),
Sense*compare(key,
Sense.
Sense;
Sense;}
Set
Sethi
Sets
Setup
Shell
Shuffle
Similar
Simple
Simple2DArray
Simple2DArray()
Simple2DArray(const
Simple2DArray.cpp
Simple2DArray.h
Simple2DArray;
Simple2DArray<##T##>
Simple2DArray<T>
Simple2DArray<T>&
Simple2DArray<T>()
Simple2DArray<T>(array)
Simple2DArray<T>(array,nrows,own)
Simple2DArray<T>(nrows,ncols,array,own)
Simple2DArray<T>(nrows,ncols,d,own)
Simple2DArray<T>::compare(const
Simple2DArray<T>::operator!=(const
Simple2DArray<T>::operator==(const
Simple2DArray<T>::read(UnPackBuffer&
Simple2DArray<T>::read(istream&
Simple2DArray<T>::write(PackBuffer&
Simple2DArray<T>::write(ostream&
Simple2DArray<T>;
Simple2DArrayT(T)
Simple2DArray_##T
Simple3DArray
Simple3DArray's
Simple3DArray;
Simple3DArray<T>;
SimpleArray
SimpleArray()
SimpleArray(const
SimpleArray.h
SimpleArray<T>
SimpleArray<T>&
SimpleArray<T>()
SimpleArray<T>(array)
SimpleArray<T>(len,d,o)
SimpleArray<T>::compare(const
SimpleArray<T>::operator!=(const
SimpleArray<T>::operator==(const
SimpleArray<T>::read(UnPackBuffer&
SimpleArray<T>::read(istream&
SimpleArray<T>::write(PackBuffer&
SimpleArray<T>::write(ostream&
SimpleArray<char>
SimpleArray<char>()
SimpleArray<char>(mylen+1,d,o)
SimpleArray<char>::write(output);}
SimpleArray<double>
SimpleArray<int>
SimpleArray_double
SimpleArray_double())
SimpleArray_double_compare(_swigobj,_swigarg0)
SimpleArray_double_read(_swigobj,_swigarg0)
SimpleArray_double_write(_swigobj,_swigarg0)
SimpleArray_int
SimpleArray_int())
SimpleArray_int_compare(_swigobj,_swigarg0)
SimpleArray_int_read(_swigobj,_swigarg0)
SimpleArray_int_write(_swigobj,_swigarg0)
SimpleHashTable
SimpleHashTable.cpp
SimpleHashTable.h
SimpleHashTable;
SimpleHashTable<T>&
SimpleHashTable<T>::compare(const
SimpleHashTable<T>::insert(const
SimpleHashTable<T>::read_item(istream&
SimpleHashTable<T>::write_item(ostream&
SimpleHashTable<T>::~SimpleHashTable<T>()
SimpleHashTable<int>
SimpleHashTableItem
SimpleHashTableItem(T*
SimpleHashTableItem(key);
SimpleHashTableItem*
SimpleHashTableItem<T>(key);
SimpleHashTableItem<T>*
SimpleHeap
SimpleHeap.cpp
SimpleHeap.h
SimpleHeap;
SimpleHeap<##T##>
SimpleHeap<T>&
SimpleHeap<T>::compare(const
SimpleHeap<T>::deleteElement(const
SimpleHeap<T>::find(
SimpleHeap<T>::read_item(istream&
SimpleHeap<T>::~SimpleHeap<T>()
SimpleHeap<T>;
SimpleHeapItem
SimpleHeapItem(const
SimpleHeapItem<##T##>
SimpleHeapItem<T>(key);
SimpleHeapItem<T>*
SimpleHeapItem<T>*&
SimpleHeapItemT(T)
SimpleHeapItem_##T
SimpleHeapT(T)
SimpleHeap_##T
SimpleSplayTree
SimpleSplayTree.cpp
SimpleSplayTree.h
SimpleSplayTree;
SimpleSplayTree<T>::compare(const
SimpleSplayTree<T>::insert(T&
SimpleSplayTree<T>::insert(const
SimpleSplayTree<T>::read_item(istream&
SimpleSplayTree<T>::write_item(ostream&
SimpleSplayTree<T>::~SimpleSplayTree<T>()
SimpleSplayTree<T>;
SimpleSplayTreeItem
SimpleSplayTreeItem(
SimpleSplayTreeItem(key);
SimpleSplayTreeItem*
SimpleSplayTreeItem<T>(key);
SimpleSplayTreeItem<T>*
SimpleSplayTreeItem<T>*&
Simplified
Size
Size()
Size;
Size=size();
Sleator
Sleator's
Sleator,
Solaris
Sort
Source
Sparc).
SparseMatrix
SparseMatrix(
SparseMatrix.h
SparseMatrix<T
SparseMatrix<T>
SparseMatrix<T>&
SparseMatrix<T>::pretty_print(ostream&
SparseMatrix<T>::read(UnPackBuffer&
SparseMatrix<T>::setup(int
SparseMatrix<T>::write(PackBuffer&
Specifically,
Specifies
Specify
Splay
StackArray
StackArray();
StackArray(BasicArray<T>&
StackArray.cpp
StackArray.h
StackArray<##T##>
StackArray<T>
StackArray<T>&
StackArray<T>::StackArray()
StackArray<T>::StackArray(BasicArray<T>&
StackArray<T>::add(
StackArray<T>::remove(
StackArrayT(T)
StackArray_##T
StackList
StackList()
StackList.h
StackList<##T##>
StackList<T>
StackListT(T)
StackList_##T
Standard
StrCerr.clear();
StrCerr;
StrCout
StrCout.clear();
StrCout;
Stream
Stuff
Subtracts
Sum
Swap
Synchronized
T
T&
T&,
T(const
T(key);
T*
T*&
T**
T,
T,class
T.
T1
T1,
T1>
T2
T2,
T2>
T3
T3,
T3>
T4
T4,
T4>
T5
T5,
T5>
T6
T6,
T6>
T7
T7>
T>
T>\
TEMPLATE_HACK
THESE
TODO
TODO.
TODO:
TOMS_REORDER
TRIE
TRUE
TRUE)
TRUE))
TRUE)){
TRUE);}
TRUE,
TRUE;
TYPES
Tagging
Takes
Tarjan~\cite{SleTar85}.
Template
Test
Testsome.
The
Then
There
These
This
Thus
Thus,
TimeStamp;
Timing
Tkinter).
To
Triang
Triang_bal
Triang_bal(new
Triang_trunc
Triang_trunc(new
Triangular
Triangular(_swigarg0,_swigarg1,_swigarg2))
Triangular(new
Triangular_generator(_swigobj)
Triangular_truncation(_arg0,_arg1);
Triangular_truncation(_swigobj,_swigarg0)
Tuple.h
Tuple1
Tuple1()
Tuple1(T1
Tuple1;
Tuple1<T1>
Tuple1<T1>&
Tuple1<T1>(_val1),
Tuple1<T1>::read(is);}
Tuple1<T1>::write(os);
Tuple1<int>
Tuple2
Tuple2()
Tuple2(T1
Tuple2;
Tuple2<T1,T2>
Tuple2<T1,T2>&
Tuple2<T1,T2>(_val1,_val2),
Tuple2<T1,T2>::read(is);}
Tuple2<T1,T2>::write(os);
Tuple3
Tuple3()
Tuple3(T1
Tuple3;
Tuple3<T1,T2,T3>
Tuple3<T1,T2,T3>&
Tuple3<T1,T2,T3>(_val1,_val2,_val3),
Tuple3<T1,T2,T3>::read(is);}
Tuple3<T1,T2,T3>::write(os);
Tuple4
Tuple4()
Tuple4(T1
Tuple4;
Tuple4<T1,T2,T3,T4>
Tuple4<T1,T2,T3,T4>&
Tuple4<T1,T2,T3,T4>(_val1,_val2,_val3,_val4),
Tuple4<T1,T2,T3,T4>::read(is);}
Tuple4<T1,T2,T3,T4>::write(os);
Tuple5
Tuple5()
Tuple5(T1
Tuple5;
Tuple5<T1,T2,T3,T4,T5>
Tuple5<T1,T2,T3,T4,T5>&
Tuple5<T1,T2,T3,T4,T5>(_val1,_val2,_val3,_val4,_val5),
Tuple5<T1,T2,T3,T4,T5>::read(is);}
Tuple5<T1,T2,T3,T4,T5>::write(os);
Tuple6
Tuple6()
Tuple6(T1
Tuple6;
Tuple6<T1,T2,T3,T4,T5,T6>
Tuple6<T1,T2,T3,T4,T5,T6>&
Tuple6<T1,T2,T3,T4,T5,T6>(_val1,_val2,_val3,_val4,_val5,_val6),
Tuple6<T1,T2,T3,T4,T5,T6>::read(is);}
Tuple6<T1,T2,T3,T4,T5,T6>::write(os);
Tuple7
Tuple7()
Tuple7(T1
Tuple7;
Tuple7<T1,T2,T3,T4,T5,T6,T7>&
Turn
TwoBitArray
TwoBitArray&
TwoBitArray()
TwoBitArray(const
TwoBitArray.C
TwoBitArray.h
TwoBitArray::operator()(const
TwoBitArray::operator[](const
TwoBitArray::put(const
TwoBitArray::read(istream&
TwoBitArraySanityChecking
TwoDArraySanityChecking
TwoDArraySanityChecking=0
TwoDArraySanityChecking=1
TwoDArraySanityChecking==1
Type
Type&
Type);
Type>
UC
UNPACKBUF(char,MPI_CHAR)
UNPACKBUF(double,MPI_DOUBLE)
UNPACKBUF(float,MPI_FLOAT)
UNPACKBUF(int,MPI_INT)
UNPACKBUF(long,MPI_LONG)
UNPACKBUF(short,MPI_SHORT)
UNPACKBUF(type,mpitype)
UNPACKBUF(unsigned_char,MPI_UNSIGNED_CHAR)
UNPACKBUF(unsigned_int,MPI_UNSIGNED)
UNPACKBUF(unsigned_long,MPI_UNSIGNED_LONG)
UNPACKBUF(unsigned_short,MPI_UNSIGNED_SHORT)
UPDATED...
USE_LINPACK
USING_CHECKSUM
USING_MEMDEBUG
USING_MPI
USING_OLD_CODE
USING_STL
USING_TEMPLATES
UTILIB_API
UTILIB_EXPORTS
UWIN
Ullman,
UnPackBuffer
UnPackBuffer&
UnPackBuffer()
UnPackBuffer(char*
UnPackBuffer(int
UnPackBuffer::resize(const
UnPackBuffer::setup(char*
UnPackBuffer::unpack(bool*
UnPackBuffer::unpack(type*
Unfortunately,
Uniform
Uniform(_swigarg0,_swigarg1,_swigarg2))
Uniform_high(_swigobj)
Uniform_low(_swigobj)
University
Unpack
Update
Use
Used
Useful
Using
Utah
Utility
V
V&
V*
V**
V>
VALUES
VOID
VOID;
Value
Value_Table;
Various
Version
Virtual
Visual
WEH
WEH:
WIN32_LEAN_AND_MEAN
Wait
WallClockSeconds
WallClockSeconds();
WallClock_init
WallClock_init.millitm);
WallClock_init.time)
WallClock_init;
WallClock_start_time
WallClock_start_time);
WallClock_start_time=0.0;
Warning(str)
We
When
Where
Whitespace
William
Windows
Windows/Unix
Within
Wrapper
Wraps
Write
Writes
X
X);
X;
XOR
X_kb
X_kb|
Xb
YES
You
Z(n);
Z,
Z.data(),
Z[n]
[Len]
[\p
[]
[mylen]
[n+1];
[n];
[ncols]
[ncols];
[ndeep]
[newl+1];
[newl];
[newlen];
[nrows]
[nrows];
[r]-000ii
[size];
[size_],size_,1);}
[size_];}
\
\a
\author
\b
\c
\class
\def
\endif
\endverbatim
\enum
\file
\i
\if
\p
\par
\sa
\typedef
\verbatim
],
];
^
^=
_(
_((COMP_VOID*,
_((SORT_VOID*
_((double
_((double*
_((double**
_((int
_((int*
_(args)
_CRI
_DEBUG
_ENUMDATAOWNED_
_GENERIC_H
_GNUG_
_MSC_VER
_OPTION_
_OPTION_[0]
_OPTION_[1]
_PyImport_Inittab
_SIZE_T
_SwigImport_Inittab;
_SwigImport_Inittab[1000];
_SwigImport_Inittab[swig_num_modules].initfunc
_SwigImport_Inittab[swig_num_modules].name
__ACTION__
__ACTION__;
__AbstractHashTable_h
__AbstractHeap_h
__AbstractSplayTree_h
__Basic2DArray_h
__Basic3DArray_h
__BasicArray_h
__BitArrayBase_h
__BitArray_h
__Boolean_h
__CharString_h
__ClassRef_h
__CommonIO_h
__DoubleMatrix_h
__DoubleVector_h
__EnumBitArray
__Ereal_h
__GNUC__
__GNUG__
__GenericHashTable_h
__GenericHeap_h
__GenericKey_h
__GenericSplayTree_h
__IntMatrix_h
__IntVector_h
__LinkedList_h
__MixedIntVars_h
__MultiLL_h
__Num2DArray_h
__NumArray_h
__OrderedList_h
__OrderedSet_h
__PackBuf_h
__QueueArray_h
__QueueList_h
__RealMatrix_h
__RealVector_h
__Simple2DArray_h
__SimpleArray_h
__SimpleHashTable_h
__SimpleHeap_h
__SimpleSplayTree_h
__SparseMatrix_h
__StackArray_h
__StackList_h
__Tuple_h
__TwoBitArray
___math_h
___seconds_h
__comments_h
__compare_h
__const
__cplusplus
__declspec(dllexport)
__declspec(dllimport)
__errmsg_h
__first
__first=TRUE,
__general_h
__hash_fn_h
__i__
__i__++;
__i__-1;
__i__;
__logEvent_H
__math_h_NO_ARRAYS
__memdebug_h
__mpiUtil_H
__ndx,
__ndx;\
__nicePrint_h
__paramTable_H
__pyutilib_h
__real_h
__signalerror_h
__sort_h
__status
__status)
__status));\
__status=TRUE;\
__stdlibmpi_h
__stl_num_primes)
__stl_num_primes;
__stl_prime_list[__stl_num_primes];
__stl_prime_list[i];
__utilib_dll_h
_arg0
_arg0;
_arg1
_arg1;
_arg2
_arg2;
_arg3
_arg3;
_arg4
_argc0
_argc1
_argc2
_argc3
_before_
_export
_generic.h
_generic.h.
_inittab
_math.cpp
_math.h
_not_
_ptemp[128];
_really_
_result
_result;
_result_ref
_resultobj
_resultobj;
_swigobj)
_swigobj->debug)
_swigobj->mean)
_swigobj->stddev)
_swigval,_swigval)
_val1)
_val1,
_val2)
_val2,
_val3)
_val3,
_val4)
_val4,
_val5)
_val5,
_val6)
_val6,
_val7)
_wrap_CommonIO__numDigits_set(PyObject
_wrap_CommonIO__std_cerr_set(PyObject
_wrap_CommonIO__std_cin_set(PyObject
_wrap_CommonIO__std_cout_set(PyObject
`VOID'
``first''
`absolute'
`mode'
a
a(0)
a(10);
a(3);
a(50);
a)
a+=((ub4)k[1]<<8);
a+=((ub4)k[2]<<16);
a+=((ub4)k[3]<<24);
a+=(k[1]<<8);
a+=(k[2]<<16);
a+=(k[3]<<24);
a+=b;
a+=f;
a+=k[0];
a,
a,b,c
a,b,c,d,e,f,g,h,length;
a,b,c,len;
a,int
a->Data
a->Data;
a->Data;}
a->Data=d;
a->Data[i]
a->Data[i];
a->Data[i][j]
a->Data[i][j];
a->Data[idx];
a->Data[ii][jj]
a->Data[ii][jj][kk]
a->Data[j]
a->Data[j];
a->Data[j][i];
a->Data[row][col];
a->Ncols
a->Ncols)
a->Ncols))
a->Ncols;
a->Ncols;}
a->Ndeep
a->Ndeep))
a->Nrows
a->Nrows)
a->Nrows))
a->Nrows;}
a->NumBinaryVars
a->NumBinaryVars)
a->NumBinaryVars]
a->NumIntegerVars
a->NumIntegerVars)
a->NumIntegerVars]
a->NumVars
a->bitVars
a->bitVars(ndx);
a->bitVars.compare(array.a->bitVars);
a->bitVars.put(ndx,(int)val);
a->bitVars.put(ndx,val);
a->bitVars.resize(numBits);
a->doubleVars
a->doubleVars.compare(array.a->doubleVars);
a->doubleVars.resize(numDoubles);
a->doubleVars;
a->doubleVars[ndx
a->doubleVars[ndx-a->NumIntegerVars];
a->doubleVars[ndx]
a->gintVars
a->gintVars.compare(array.a->gintVars);
a->gintVars.resize(numGenInts);
a->gintVars[ndx-a->NumBinaryVars]
a->gintVars[ndx-a->NumBinaryVars];
a->gintVars[ndx]
a->own_data
a->own_ptrs
a->ref
a->ref++;
a->ref;}
a.
a.append(a);
a.debug
a.foo();
a.operator-();
a.resize(15);
a.resize(5);
a.resize(8);
a1(LEN);
a1)\
a1,
a1.a->Data;
a1.a->Data[i][j];\
a1.data()[j];\
a1.ncols()))\
a1.nrows())
a1.size())\
a1.size(),
a1[i]
a1[i][j]
a2(LEN);
a2(i));
a2)
a2)\
a2,
a2.a)
a2.a->Data;
a2.ncols()))\
a2.nrows())
a2.size())
a2.size())\
a2.size(),
a2[i];\
a2[i][j];\
a3(LEN);
a4(LEN);
a;
a=aa;
a=state[0];
a[0]
a[0].freeze_memory();
a[0].resize(10);
a[0];
a[1]
a[1].resize(1);
a[i]
a[i]*a[i];
a[i];
a[i][j]
a[i][j];
a^=b<<11;
aa
aa=0.5*(a+am);
aa=0.5*(a+ap);
able
abnormally
abort
abort()
abort();
abort.
aborting.
aborts.
about
above!)
above.
absolute
abstract
accelerate
acceptable.
access
accessible
accessing
accompanies
accomplished
according
account
acheive
achieves
acquire(V*
across
action
actual
actually
adapted
add
add(
add(AbstractHeapItem*
add(AbstractSplayTreeItem*
add(Data[Len]);
add(KEY&
add(const
add(item);
add(set.Data[i]);
add(tdata,tkey);
add/remove
addEffect(AbstractHeapItem*
addEffect(item);
add_unique
added
adding
additional
adds
adjoinColumn(int
adjoinRow(int
affects
after
again.
agreement
agreement)
algorithm
alignment.
all
alloc.h
allocate
allocated
allocated(initSize),
allocated)
allocated.
allocated;
allocation
allocation,
allocation.
allocation/deallocation
allowed
allows
almost
already
also
alternate
always
am
am)
am;
am=a;
an
and
and/or
another
ans
ans(a.size()
ans(mat.ncols());
ans)
ans,tmp;
ans;
ans=0.0;
ans=0;
ans=tmp;
ans[i]
ans[j]
ansi
answer
any
anything
ap)
ap,
ap=a;
appear
append
append(BasicArray<T>&
append(T&
appending
application.
approach
approximation
aquired
arbitrary
arbitraryCode
architecture-dependent
are
area
arg++)
arg<argc;
arg=1;
argCount
argCount++;
argc
argc)
argc))
argc,
argc,char**
argcP,char***
argmax(const
argmedd
argmedd(double*
argmedian(
argmedian(const
argmedian(double*
argmedian(vec,vec.len(),ws);
argmedian(vec.data(),
argmin(const
args
arguement
argument
argument.
arguments
arguments.
argv
argv)
argv);
argv++;
argv,
argv,int
argvP,
argv[0]
argv[0];\
argv[1..argc-1]
argv[1]
argv[])
argv[__i__];
argv[arg];
around
array
array's
array(nrl,nrh,ncl,nch,nzl,nzh)
array)
array);
array);//
array)\
array,
array->Data
array->Len
array->array_len
array-based
array.
array.Data
array.Data,
array.Data;
array.Data;\
array.Data[i])
array.Data[offset+i-start];
array.Len)
array.Len,
array.a->Data[i][j])
array.a->Data[i][j];
array.a->bitVars;
array.a->doubleVars;
array.a->gintVars;
array.a;
array.array_len,
array.data(),
array.ise
array.numDoubles());
array.numGeneralIntVars(),
array.read(input);
array.set_shared_data(array.Data,
array.shared;
array.size()
array.size())\
array.size()*sizeof(double),
array.size()*sizeof(int),
array.size(),
array.size();
array.write(output);
array;
array[i];
array[j];\
array_len
array_len)
array_len;
array_len;}
array_len_,
array_len_;
array_mean
array_mean)
array_mean);
array_mean,
array_mean;
array_mean[j])
array_mean[j]));
array_of_indeces,
array_of_indeces,status_array);
arraylen
arrays
arrays,
arrays.
arraytmp
arraytmp[i])
arraytmp[i];
arry
arry(max_bucket_size);
arry[bucket_size[i]]++;
arv,int
as
as-needed
asdouble(const
aslong(const
assemble
assert(Data[Len-1]
assert(a
assert(a->Data
assert(a->Data[i]
assert(a->Data[i][j]
assert(d
assign
associated
assume
assumed
assumes
assuming
at
at(const
at(start,
attribute
augment
augment_pyutilib_modules();
automatic
automatically
auxillary
available
avalanche.
avoid
avoids
b
b(1)
b(10);
b(2);
b)
b));
b);
b+=((ub4)k[5]<<8);
b+=((ub4)k[6]<<16);
b+=((ub4)k[7]<<24);
b+=(k[5]<<8);
b+=(k[6]<<16);
b+=(k[7]<<24);
b+=c;
b+=g;
b+=k[4];
b,
b,c,d,or
b.debug
b.foo();
b.foob();
b.reset(0);
b.resize(15);
b.resize(5);
b.set(i);}
b.size());
b;
b=state[1];
b[j-a.size()];
b[p]
b^=c>>2;
back
backward,
bad
bar
bar1(10);
bar1.set_subvec(3,4,bar2,2);
bar1=1;
bar2(10);
bar2=2;
bar2[2]=0;
bar=0;
barrier
barrier()
base
base,
based
based)
baseline
basic
basis.
be
because
becomes
been
before
begin
begin()
begin();
begin++,
begin-end
begin/end
begin_buffered();
begin_end_counter
begin_end_counter++;
begin_end_counter--;
begin_end_counter;
begin_end_counter=0;
begin_tagging()
begin_tagging(const
beginning
beginning;
begins
behaves
behavior,
below
below,
best
better
between
beyond
big
billion
binary
binary,
bit
bit-pair.
bit.
bitVars(nBinVars),
bitVars;
bitmask.
bits
bits)
bits,
bits.
bitval
bitval;
bitwise
bitwise_and(BitArray&
bitwise_or(BitArray&
bitwise_xor(BitArray&
block
block,
block.
blocks
body
bookkeeping
bool
bool&
bool's
bool()
bool*
boolean
booleans
both
bottom
boundary
bounds
break;
broadcast
broadcast(&ioProc,1,MPI_INT,0);
broadcast(recvbuf,count,datatype,0);
broadcast(void*
broadcast.
brute-force
bucket
bucket_size
bucket_size(__stl_prime_list[0]),
bucket_size(initial_size),
bucket_size(utilib_prime_list[0]),
bucket_size.resize(tmp);
bucket_size;
bucket_size=0;
bucket_size[i];
bucket_size[index]))
bucket_size[index]++;
bucket_size[index]--;
buckets
buckets;
buf()
buf[256];
buf[ndx++]
buf[ndx]
buf_,
bufexp
bufexp(x)
bufexp.
buff,
buff;
buff;}
buffer
buffer(0),
buffer,
buffer,int
buffer.
buffer;
buffer;}
buffer=buf_;
buffer[4096];
buffer[i]
buffer[i];
buffered
buffered.
buffers
buffers.
bug:
build
building
built-in
built.*/
busy
but
by
byte
byte-array
bytes
bytes)
bytes.
bzero(char*
c
c+=((ub4)k[10]<<24);
c+=((ub4)k[8]<<8);
c+=((ub4)k[9]<<16);
c+=(k[10]<<16);
c+=(k[11]<<24);
c+=(k[9]<<8);
c+=d;
c+=h;
c+=k[8];
c,
c1
c1::snortate()
c;
c='\0';
c='\000';
c=state[2];
cString;
cString[256];
c^=d<<8;
calc_filesize(char*
calculation
call
call.
called
called,
called.
calling
calls
calls.
can
cancel(MPI_Request*
cancel(request);
candidate;
candidate=First[type_id];
candidate=Next[candidate];
candidate=find_value(type_id,value);
candidate=remove_index;
cannot
capability
capability.
case
case,
cases
categories
category
category.
cause
cerr
cerr.
cerr_)
cerr_,
cerr_;
cerr_print(_arg0);
cerr_print(const
certainly
chain
chain.
chaining
chaining.
chains
chains.
change
changeCounter
changeCounter(0)
changeCounter++;
changeCounter;
changeValue(double
changed
changes
changing.
char
char&
char's
char*
char*)array);}
char**
char*,
char[
char[size];
character
characteristics
characters
charptr
check
check_duplicates()
check_duplicates_flag(0)
check_duplicates_flag.
check_duplicates_flag;
check_duplicates_flag;}
check_if_infinite(Type&
check_if_infinite(rval,rFinite);
check_if_infinite(val,Finite);
check_index;
check_index=First[i];
check_index=Next[check_index];
checking
checking.
checks
checksum(
checksum()
checksum(ub1*
checksum.
child
child++;
child;
cholesky
cholesky(A,A,5,&rcond);
cholesky(DoubleMatrix&
choose
cin
cin.get(str[i++]);
cin_)
cin_;
class
class'
class).
class,
class.
class::name(#name,min,default,max)
classes
classes.
classref.cpp
clean_up(int
clear
clear();
clear_print_marker_queue()
clear_print_marker_queue();
clears
clock
clock()
clock();
clock_t
close();
closes
closest
cmd
cmd;
cndx
cndx)
cndx;
cndx=-1;
cndx=ncols;
code
code,
code.
codes
coercion
col
col)
col);
col++)
col-th
colPosition,
colPosition[i];
collision
collisions.
colmajor)
colmajor);
colmajor.matind[colmajor.matbeg[j]+colndx[j]];
colmajor.matval[colmajor.matbeg[cndx]+colndx[cndx]];
colmajor.ncols;
colmajor.nnzeros;
colmajor.nrows;
colndx(ncols);
colndx)
colndx=0;
colndx[cndx]++;
colndx[j]))
color
color)
color);
color;
column
column-major
column.
column/row
columns
columns.
come
coment
comm
comm);
comm.
comm;
comm==MPI_COMM_WORLD
comm=MPI_COMM_WORLD;
comm=comm_;
comm_)
comm_=MPI_COMM_WORLD);
command
command-line
command.
comment
comment_lines(istream&
comments.cpp
comments.h
commercial,
commercial.
common
common_#
common_cerr
common_cerr->flush();}
common_cerr;
common_cin
common_cin;
common_cout
common_cout,
common_cout->flush();
common_cout;
common_ofstr.open(fname);
common_ofstr;
commonly
communication.
communicator
comp
comp,
compact
compar,
compare
compare(
compare(GenericKey<KEY,DATA>*
compare(KEY*
compare(T&
compare(T*
compare(array);}
compare(bar,bar);
compare(bar,foo);
compare(bar,infhi);
compare(bar,inflo);
compare(bar,tmp);
compare(bar,tmp2);
compare(const
compare(foo,bar);
compare(foo,foo);
compare(foo,infhi);
compare(foo,inflo);
compare(foo,tmp);
compare(foo,tmp2);
compare(infhi,bar);
compare(infhi,foo);
compare(infhi,infhi);
compare(infhi,inflo);
compare(infhi,tmp);
compare(infhi,tmp2);
compare(inflo,bar);
compare(inflo,foo);
compare(inflo,infhi);
compare(inflo,inflo);
compare(inflo,tmp);
compare(inflo,tmp2);
compare(tmp,bar);
compare(tmp,foo);
compare(tmp,infhi);
compare(tmp,inflo);
compare(tmp2,bar);
compare(tmp2,foo);
compare(tmp2,infhi);
compare(tmp2,inflo);
compare);
compare.h
compare_A(A&
compare_double
compare_double);
compare_float
compare_float);
compare_fn)
compare_fn);
compare_fn,qsort);
compare_fn_type
compare_int
compare_int);
comparing
comparison
comparison.
comparisons
compatable
compatible
compile
compileable
compiled
compilers
compilers.
compiles
compiling.
complete
completely
compose
compounded
compute
computed
computed.
computing
concat(const
concatenated
cond
condition.
conditionally
conditions
conditions:
conflicts
confused
conservative
consistent
const
const.
const;
const_ref;
const_ref=FALSE;
const_ref=FALSE;}
const_ref=TRUE;
constant
constant.
constants
construct
construct(array.nrows(),array.ncols(),array.data(),AcquireOwnership);
construct(array.numIntegerVars(),
construct(array.size(),array.Data,AcquireOwnership);
construct(array.size(),array.Len,array.Data,AcquireOwnership);
construct(array.size(),array.data(),AcquireOwnership);
construct(const
construct(numBits,
construct(str.size(),str.data(),AcquireOwnership);
construct(strlen(str),
construct,
constructed
constructed.
constructing
construction
constructor
constructor,
constructor.
constructors
constructs
contain
container
containing
contains
contexts
contiguous
contiguously.
continue
continue;
continue;}
control
convenient
conversion
conversion.
convert
convert(const
copied
copy
copy_data(BitArrayBase*
copy_data(V*
copy_data(array);
copy_data(ref_ptrs[i]);
copying
core
correct
corrupted
could
count
count,
count,MPI_Datatype
count,const
count;
counter
counter()
counter++;
counter,
counter--;
counter.
counter;
counter=0;
counting
counting.
counts.
course,
cout
cout.
cout_)
cout_,
cout_;
cout_print(_arg0);
cout_print(const
cppMessage.cpp
cppMessage_abort()
cppMessage_abort();
create
created
cryptographic
cryptography.
ctmp
ctmp,
ctr
ctr(0)
ctr++;
ctr;
ctr;}
ctr=0;
cum
cum;
cumbersome.
cumbersum
curr
curr()
curr)
curr->Key))
curr->data())
curr->data()->write(os);
curr->data();
curr->key())
curr->key();
curr->next
curr->next->prev
curr->next;
curr->prev;
curr;
curr_array_len,
curr_hashfn(0)
current
current(
current-array
current;
current=Last[type_id];
current=Next[current];
current_iteration)
current_iteration);
curritem
curritem->ctr++;
curritem;
cursor
cycles
d
d+=(k[13]<<8);
d+=(k[14]<<16);
d+=(k[15]<<24);
d+=a;
d+=e;
d+=k[12];
d+Len,
d,
d,o);
d.
d;
d=(char*)0,
d=NULL;
d=state[3];
d[i]
d[ii][jj];
d[min(newl,Len-1)]
d[ndx++];
d^=e>>16;
dangerous,
darray(nrl,
darray(nrl,nrh,ncl,nch,nzl,nzh)
data
data's
data()
data)
data);
data,
data.
data.find(item))
data.head()->data();
data.head();
data.insert(item,
data.len();}
data.next(curr);
data.next(table[index]);
data.remove(curr);
data.remove(data.head());
data.remove(tmp_item);
data.size()
data.size();
data1
data2
data2,
data;
data[i]
datatype
datatype)
datatype,MPI_Op
datatype,int
datatype.
datavec
datavec,
datavec.
days...
deal
deallocation
debug
debug;
debugging
debugging)
debugging,
decl
declarations
decomposition
decreasing.
decreasing=-1,
decremented
default
default),
default).
default,
default.
defaultQuantum
defaultQuantum)
defaultQuantum);
defaultSize
defaultSize,
define
defineState(const
defined
defined(CM5)
defined(COUGAR)
defined(DEBUGGING)
defined(KSR)
defined(MPE)
defined(MULTITASK))
defined(NON_ANSI)
defined(OSF)
defined(PARAGON)
defined(PVM)
defined(RS6K)
defined(SGI)
defined(SOLARIS)
defined(SPX)
defined(SUNOS)
defined(USING_MEMDEBUG)
defined(USING_MPI)
defined(_MSC_VER)
defined(__BORLANDC__)
defined(__BasicArray_h)
defined(__GNUC__)
defined(__STDC__)
defined(__WIN32__)
defined(__cplus_plus)
defined(__cplusplus)
defined(iPSC860)
defined(nCUBE2)
defined,
defined.
defined:
defined?
defines
defining
definite
definite.
definition
definitions
definitions.
degrades
delete
delete(void
delete(void*
delete(void*,
deleteElement(const
deleteElement(element);
deleteElement(i);
deleteElement(n);
delete[]
delete_BasicArray_double(_arg0);
delete_BasicArray_double(_swigobj)
delete_BasicArray_int(_arg0);
delete_BasicArray_int(_swigobj)
delete_BitArray(_arg0);
delete_BitArray(_swigobj)
delete_CharString(_arg0);
delete_CharString(_swigobj)
delete_CommonIO(_arg0);
delete_CommonIO(_swigobj)
delete_col(const
delete_data()
delete_data();
delete_element(const
delete_element(i,j);
delete_element(i,matind[matbeg[i]]);
delete_element(j,i);
delete_element(matind[matbeg[i]],i);
delete_flag=FALSE;
delete_flag=TRUE;
delete_item(AbstractSplayTreeItem*
delete_item(t);
delete_ofstream(_arg0);
delete_ofstream(ofstream
delete_row(const
delete_unused();
deleted
deleted,
deletes
deleting
delimiter
delta
delta=0.2;
deltas
deltas.)
denominator
denominator)
dense
depending
depends
deprecated.
depth,
derivation
derived
desc
described
descrip
description,cString);
description,const
descriptive
design
designed
designed,
desirable.
desplay
dest
dest,
dest,int
dest;
destructed.
destruction
destructor
destructor.
detect
detected
detected,
determined
determines
develop
developed
deviation)
diagonal
diff
diff;
differenced
differencing
different
differentiation
difficult
digits
digits).
digits.
digitsNeededFor(double
directed
directly.
directory.
disabled
discussion
disjoint
dist(const
dist[i]=0.0;
dist[i]=dist[i]/(double)maxdist;
dist[rvar]=dist[rvar]+1.0;
distance
distribute
distributed,
distributions
div(const
div(val,Finite,num.val,num.Finite,val,Finite);
divide
divide(const
dmatrix(0,4,0,4);
dmatrix(nrl,
dmatrix(nrl,nrh,ncl,nch)
do
do.
do_stest(const
do_test(const
documented,
documents,
does
doesn't
doing
don't
done
done();
done.
dotest(double
double
double&
double's
double*
double**
double,
doubleVars(nDblVars)
doubleVars;
double[numParameters];
doubleptr
doubles
doubles.
doubly
doubly-linked
doulb)
down
down.
dowrite(t,os);
dpoco_
dpoco_(&(G[0][0]),
dpofa_
dpofa_(&(G[0][0]),
dqrdc
dqrdc_
dqrsl_
dqrst
drnd();
drnd(rng);
drnd)
drnd);
drnd.high(n);
drnd.low(p);
drop
due
dum=1.0/(eps+fabs(xx-a));
dummy
dummy;
duplicate()
duplicate_flag
duplicate_flag(0),
duplicate_flag.
duplicate_flag;
duplicate_flag;}
duplicate_flag=1;
duplicates
dvector(nl,
dvector(nl,nh)
dynamic
dynamically
e
e+=(k[17]<<8);
e+=(k[18]<<16);
e+=(k[19]<<24);
e+=b;
e+=f;
e+=k[16];
e.
e=state[4];
e^=f<<10;
each
earlier
earliest
early
easier.
ed.)
educational,
effective
effective,
efficeintly
efficient
efficient.
either
elapsed
elected;
element
element(0)
element)
element);
element,
element-wise
element.
element;
element_size()
elements
elements,
elements.
elementw
elementwise
eliminates
eliminating
else
else.
else{
elt
elt_type&
embed13.i.
embed14.i
embed15.i
embedding
empty
empty()
empty,
empty.
enable
enabled
enabling
enclosing
encountering
end
end();
end)
end,
end-of-file
end-of-line
end;
endEvent
end_all();
end_tagging()
ended
endif
ending
endl;
enforced
enough
enough'
enough,
entire
entries
entry
enum
enum_count;
enum_count;}
enum_labels[(int)(operator()(i))];
enum_labels[];
enum_labels[j])
enum_vals[];
enumerated
enumeration
eps
eps=AFAC*fabs(aa-a);
equal
equal,
equals
errmsg(const
errmsg.h
errmsg.h.
errmsg_abort
errmsg_abort(const
errmsg_exit_fn
errmsg_exit_fn(null_fn_type
error
errorCode
errorCode;
errorKey)
errorKey);
errorKey,buffer);
errors
errors,
errs()
errs.
especially
estimate
estimates
etc.
even
event
event(int
event(stateNumber*2
event(stateNumber*2);
event.
event.clog
eventNumber)
eventNumber.
eventually
every
everything
everywhere.
exactly
example
example,
example:
exceeded,
exceeds
except
exception
executable
executable.
executed
executes
exist
exists
exists.
exit
exit(-1);
exit(0);
exit(1);
exit(__ACTION__);
exit.
exits
exp(1.0)
exp(x)
exp2(double
expands
expect
expiration
expiration)
expiration);
expired
expires
explained
explicit
explicitly
exponential
export
exporting
extend
extends
extension
extensions
extensions.
extent;
extern
externally
extract(ListItem<T>*
extract(OrderedListItem<T,V>*
extract(T*
extract(first);
extract(first,data);
extract(item);
extract(item);}
extract(item,status);
extract(last,data);
extract(tmp,status);
extract_all();
extracting
f
f+=(k[21]<<8);
f+=(k[22]<<16);
f+=(k[23]<<24);
f+=c;
f+=g;
f+=k[20];
f=state[5];
f^=g>>4;
f_flag)
fabs(a);
fabs(array[i]
facilitate
facilitates
facilitating
facilites
facilities.
facility
facility.
fact
factored
factorization
fall
false
false)
false.
false;
far
farray(nrl,
fashion,
fast
faster
fclose(foo);
feature,
feel
fflush(stdout);
fidelity
field
fields
figures,
file
file,
file--changes
file.
fileName)
fileName);
fileName,getcwd(0,256));
filename);
filename.
files
files,
fill
fill_table(GenericHashTable<A<CharString>
fill_table(GenericHashTable<A<int>
fill_table(SimpleHashTable<int>&
fill_table(table);
filled
find
find(
find(*(item->key()));}
find(KEY&
find(T*
find(const
find(key);
find_rank(0);
find_rank(i++);
find_rank(int
find_value
find_value(int
finds
finishes
finite(const
finite<>
first
first(
first()
first->data();
first->prev
first.
first;
first;}
fix
fixed
flag
flag)
flag);
flag,
flag,MPI_Status*
flag.
flag:
flag;
flag=0)
flag=0);
flag=TRUE;
flag=true;
flags
flags.
flip();
flip(const
float
float&
float's
float*
float,
float.
floatUp(element);
floatUp(int
floatUp(used);
floating
floats
floor(
floor(array.size()
floor(log10(fabs(value)))
flush
flush()
flush();
flush_)
flush_;
flush_flag
flush_flag)
flush_flag;
flush_flag=1;
flush_stream(StrCerr,common_cerr);
flush_stream(StrCout,common_cout);
flush_stream(strstream&
flushed
flushes
flushing
fmatrix(nrl,
fmod(
fn);
fname
fname;
followed
following
foo
foo()
foo();
foo.asLong()
foo.clear();
foo.reseed(0);
foo.reset();
foo1
foo1.resize(3);
foo1;
foo2;
foo;
foo=01;
foo_int.clear();
foo_int;
for
for(char
for(i=0;
for(int
for(list=0;
for(parameter*
for(ptr
for(size_type
forces
form
format
format.
formating
formatting
fortran
forward
forward,
found
found,
found.
found_index;
found_index=First[type_id];
found_index=Next[found_index];
four
fp);
fputs(#char,
fputs(DO_COMMAND_EOLN,
fputs(DO_COMMAND_TAB,
fputs(DO_COMMAND_TAB,stderr);
fractional
fragments,
free
free();
free(ptr);
free_array(v,nrl,nrh,ncl,nch,nzl,nzh)
free_darray(v,
free_darray(v,nrl,nrh,ncl,nch,nzl,nzh)
free_dmatrix(v,
free_dmatrix(v,nrl,nrh,ncl,nch)
free_dvector(v,
free_dvector(v,nl,nh)
free_farray(v,
free_fmatrix(v,
free_fvector(v,
free_iarray(v,
free_imatrix(v,
free_index;
free_index=i;
free_ivector(v,
free_matrix(v,nrl,nrh,ncl,nch)
free_vector(v,nl,nh)
frees
freeze()
freeze_memory()
frequently,
friend
from
from.
frozen
ftime(&WallClock_init);
ftime(&tb);
function
function,
function.
functionality
functions
functions!
functions.
funnels
funnels.
future
fvector(nl,
g
g+=(k[25]<<8);
g+=(k[26]<<16);
g+=(k[27]<<24);
g+=d;
g+=h;
g+=k[24];
g=state[6];
g^=h<<8;
general
general-purpose
general.h
generally
generate
generated
generates
generator.
generic
generic_free_array((VOID
generic_free_array();
generic_free_array(char***
generic_free_matrix((VOID
generic_free_matrix();
generic_free_matrix(char**
generic_free_vector((VOID
generic_free_vector();
generic_free_vector(char*
generic_make_array(nrl,nrh,ncl,nch,nzl,nzh,
generic_make_matrix(nrl,nrh,ncl,nch,sizeof(double))
generic_make_matrix(nrl,nrh,ncl,nch,sizeof(float))
generic_make_matrix(nrl,nrh,ncl,nch,sizeof(int))
generic_make_vector(nl,nh,sizeof(double))
generic_make_vector(nl,nh,sizeof(float))
generic_make_vector(nl,nh,sizeof(int))
generic_transpose_matrix((VOID
get
get()
get(const
getBit(const
getCount(MPI_Status*
getCount(status,MPI_PACKED));
getDouble(const
getGeneralInt(const
getInt(const
get_data()
get_key()
get_matbeg(
get_matcnt(
get_matind(
get_matval(
get_ncols(
get_nnzero(
get_nrows(
get_print_marker()
get_print_marker();
getrusage(RUSAGE_SELF,
gets
gintVars(nIntVars),
gintVars;
given
given,
gives
global
global_CommonIO;
globally
goes.
golden
good
grab
granted
greater
greater-than
greater-than-or-equal-to
greatest
greatly
group
groups
growing
guarantee
guaranteed
h
h);
h+=(k[28]<<8);
h+=(k[29]<<16);
h+=(k[30]<<24);
h+=a;
h+=e;
h=0;
h=state[7];
hModule,
h^=a>>9;
hack
handle
handled
handles
handling
handy.
happen.
has
hasBeenChanged()
hash
hash(*(item->key()),table.size());
hash(KEY&
hash(const
hash(key,
hash(name);
hash(size_type
hash.cpp
hashHeader[hash(name)]
hashHeader[hashValue]
hashHeader[hashValue];
hashHeader[hashValue_];
hashHeader[i]
hashHeader[tableSize];
hashValue
hashValue_)
hashValue_);
hash_bj(const
hash_bj(i)
hash_data
hash_element
hash_element;
hash_fn(const
hash_fn(key,table_size);
hash_fn.cpp
hash_fn.h
hash_fn1(const
hash_fn1(key,table_size);}
hash_fn1;
hash_fn2(const
hash_fn2(key,table_size);}
hash_fn2;
hash_fn3(const
hash_fn3;
hashes
hashing
hashmask(10));
hashsize(10)
have
haven't
having
head
head()
header
header_flag
header_flag;
headers
heap
heap)
heap.
heap.read(input);
heap.write(output);
heap_info(&fragments,
heap_info(int
heap_size();
heap_sort
here
here!!!!
here.
here...
high
highest
his
hit
holds
hook
hooks
housekeeping
how
howMany()
hsize
http://ourworld.compuserve.com/homepages/bob_jenkins/evahash.htm
http://ourworld.compuserve.com/homepages/bob_jenkins/lookupa.c
http://www-cgi.cs.cmu.edu/afs/cs/user/sleator/www/home.html
hyphens(ostream&
i
i)
i);
i);}
i*i*i;
i++)
i++)\
i++){
i++,
i++,start++)
i++;
i,
i,char
i,double
i,int
i,j,
i,j;
i,rvar,maxdist=0;
i--)
i-th
i.
i;
i<
i<(array.size()-boundary);
i<(curr+next);
i<(len+start);
i<(mylen+1);
i<(nnzeros+diff);
i<(nnzeros-1);
i<(ref-1);
i<1000000;
i<10000;
i<1000;
i<100;
i<10;
i<5;
i<8;
i<=
i<=100;
i<=Size;
i<=size();
i<=used;
i<Len;
i<M1Nrows;
i<MIN(a->Nrows,array.a->Nrows);
i<MIN(ncols,a->Ncols);
i<MIN(nrows,a->Nrows);
i<NCols;
i<NRows;
i<Size;
i<__i__;
i<a->Nrows;
i<a.nrows();
i<a.size();
i<a1.a->len;
i<array.size();
i<array_len;
i<bucket_size[index];
i<count;
i<counter;
i<end;
i<len;
i<mat.nrows();
i<matcnt[col];
i<matcnt[row];
i<matrix.ncols();
i<memdebug::num;
i<min(a->Nrows,array.a->Nrows);
i<min(ncols,a->Ncols);
i<min(newl,Len);
i<min(newl,Len-1);
i<min(nrows,a->Nrows);
i<min(ref,newlen);
i<min_length;
i<mylen;
i<n;
i<ncols;
i<ndata;
i<new_array_len;
i<newl+1;
i<nnzeros;
i<nrows();
i<nrows;
i<num;
i<outcount;
i<ref;
i<result.size();
i<set.Len;
i<size();
i<str.size();
i<str1.Len;
i<tableSize;
i<v1.size();
i<vec.len();
i<vec.size();
i<vector.size();
i<work.size();
i=0;
i=0;i<MAXTYPES;i++)
i=1;
i=Len-1;
i=boundary;
i=curr;
i=curr_array_len;
i=matbeg[colndx]+k;
i=matbeg[rowndx]+k;
i=matbeg[rowndx]+rowlen;
i=start;
i=tmp;
i>0;
iDoIO
iDoIO;
iPSC860SIMULATOR
iarray(nrl,
ibuffer
ibuffer;
ibuffer[i]
ibuffer[i];
ideas
identical
idx
idx)
idx,
if
if((check_index
if(First[type_id]==OPEN)
if(Next[candidate]!=OPEN)
if(candidate!=OPEN)
if(candidate==First[type_id])
if(candidate==Last[type_id]){
if(dist[rvar]>(double)maxdist)
if(found_index
if(i==table.size()){
if(operator()(i)
if:
ifstr
ifstr.close();
ifstream
ifstream(_swigarg0))
ifstream(fileName);
ifstream_close(_arg0);
ifstream_close(_swigobj)
ifstream_open(_arg0,_arg1);
ifstream_open(_swigobj,_swigarg0)
ignore_duplicate==false
ignore_duplicate==true
ignore_duplicates()
ignore_duplicates_flag(true),
ignore_duplicates_flag;
ignore_duplicates_flag;}
ignored,
ignoring
ii++)
ii<nrows;
ii=0;
imatrix(nrl,
immediately
impact
implementation
implicitly
implies
import
impose
improved
in
in.
incidate
include
included
includes
including
inclusion
incoming
incompatability
inconsistent
incount,
increased.
increasing
increasing;
increasing=1,
increment
increments
incurs
indeces
indeces.
index
index(const
index(val);
index,
index.
index;
index;}
index=0;
indexed
indexing
indexing,
indicate
indicates
inexpensive
infhi
infinite.
inflo
influenced
info
info();
info(1);
info(int
info));
info;
information
information,
information.
infrequently
infty
init()
init(int*
initSize
initSize,
init_heap_malloc();
init_malloc_sigheap();
initalize
initfunc;
initial
initial_size,
initialed
initialization
initialize(0,array_len);
initialize(Data,0,len);}
initialize(T*
initialize(array_len,newl);
initialize(const
initialize(d,Len,newl);
initialize(int
initialize(mat.get_nrows(),
initialize(ntmp,ctmp,ztmp);
initialized
initializes
initializing
initially
initiate
initiated
initiates
inittab[]
initutilibc
initutilibc();
inline
inner
inner_product(const
input
input)
input);
input,
ins
ins()
ins)
ins);
ins,
ins.
ins.get(c);
ins.putback(c);
ins;
ins_sort
insert
insert(
insert(&key);}
insert((const
insert(KEY*
insert(T&
insert(T*
insert(const
insert(data);
insert(data,key);}
insert(int
insert(item);
insert(item->Data,key);
insert(key);}
insert(tmp_item,false);
inserted
insertion
inserts
inspired
installed
instance
instance.
instances
instantiated
instantiation
instead
instructions,
instructions.
int
int&
int's
int()
int)
int);
int*
int[numParameters];
intact.
integer
integer,
integers
integers'
integers.
integral
interchangable.
interface
interface.
internal
internally.
interpolation.
interpreter
into
intptr
ints
intval
intval;
ioProc
ioProc)
ioProc);
ioProc;
ioProc=0
io_buffered>0
io_buffering
io_buffering++;
io_buffering--;
io_buffering;
io_mapping
io_mapping;
io_rank()
iotest.cpp
irecv(void*
is
is)
is);
is,
is.get(c);
is.putback(c);
is:
is;
is;}
is_disjoint(const
is_member(const
isend(buffer,count,datatype,dest,tag,&request);
isend(void*
isind(const
isind<>
isinf(const
isinf(double
isinf<>
isn't
isnan(const
isnan(double
isnan<>
issend(void*
istr
istr)
istr);
istream
istream&
istream*
istream**
it
it's
it).
it.
item
item's
item)
item);
item,
item->Data;
item->Key;
item->element;
item->element=used;
item->key()->val
item->next
item->next->prev
item->next;
item->next;}
item->prev
item->prev->next
item->prev;
item->read(is);
item.
item.Data);}
item.Key);}
item;
item=olist.head();
items
iterator
its
itself
ivector(nl,
j
j)
j++)
j++)\
j++){
j,i;
j;
j<(a.size()+b.size());
j<(ncols-1);
j<(nrows-1);
j<16;
j<5;
j<=i;
j<M2Ncols;
j<MIN(a->Ncols,array.a->Nrows);
j<NCols;
j<NRows;
j<a->Ncols;
j<a->Nrows;
j<a.ncols();
j<ans.size();
j<bucket_size.size();
j<element_size();
j<mat.ncols();
j<matcnt[i];
j<matrix.nrows();
j<min(a->Ncols,array.a->Nrows);
j<n;
j<ncols();
j<ncols;
j<nrows;
j<set.Len;
j<vec.len();
j=0;
j=1;
j=a.size();
j=colndx+1;
j=i;
j=r+1;
j=rowndx+1;
jj++)
jj<ncols;
jj=0;
job
job));
job,
job=0)
job=0,
jpvt,
jpvt[p]
just
k
k)
k));
k++)
k++){
k++,
k++;
k,
k<M1Ncols;
k<mat.matcnt[i];
k<matcnt[colndx];
k<matcnt[rowndx];
k<n;
k=0;
k=1;
k[i],
keep
kernel
key
key()
key)
key);
key,
key->read(is);
key.
key.Key);}
key.hash(table_size);}
key.read(input);
key.write(output);
key1
key1,
key1->compare(key2);
key1_,
key1_;
key2
key2)
key2);
key2_)
key2_;
key;
key=1.0;
key=2.0;
key=3.0;
key_ptr(key_ptr_),
key_ptr;
key_ptr;}
key_ptr_)
key_val(Key_),
key_val;
key_val;}
keys
keys.
keys/data.
killRecvRequest(MPI_Request*
killSendRequest(MPI_Request*
kk++)
kk<ndeep;
kk=0;
know
know,
known
knows
l
l->right
l_size
l_size,
l_size;
labels
language.
lapply(BasicArray<T>&
large
large,
largely
largest_free,
largest_free_block(unsigned
last
last->data();
last->next
last;
last;}
last_fragments=0,
last_fragments=fragments;
last_largest_free=0;
last_largest_free=largest_free;
last_profile=0;
last_profile=profile_total_bytes_used;
last_total;
last_total_free=0,
last_total_free=total_free;
last_total_used=0,
last_total_used=total_used;
later
later.
lda,
ldx,
least
left
left(0),
left;}
len
len()
len)
len,
len.
len;
len[i],
len_,
length
length(const
length);
length,
length.
length;
less
letters
level
level)
level);
level.
level;
lexicographically
libraries
library
lifted
like
limit
limited
limits
line
line,
line.
line_counter
line_counter)
line_counter);
line_counter++;
linear
lines
lines,
link
linked
linpack's
linpack.h
list
list'
list)
list);
list++)
list,
list.
list.head();
list.next(curr);
list;
list;}
list<tableSize;
lists
little
local
localtime(&t);
location
log
logEvent
logEvent.C
logEvent.H
logEvent::close()
logEvent::defineState(const
logEvent::log_##how(state);)
logEvent::numberOfStates
logEvent::open()
logRecv(MPI_Status*
logRecv(s)
logSend(a,b,c,d)
logSend(int
log_<how>
log_end(int
log_end(stateNumber).
log_end(stateNumber);
log_point(int
log_start(int
log_start(stateNumber)
log_start(stateNumber);
log_xxx
logarithmic
logged.
logging
logging/tracing
long
long&
long's
long*
longer,
look
look-and-feel
lookup(
lookup((ub1*)&val,sizeof(double),0);
lookup((ub1*)&val,sizeof(int),0);
lookup((ub1*)(array.data()),
lookup((ub1*)(array.data()),(array.size()+BYTESIZE-1)/BYTESIZE,
lookup()
lookup(buffer);
lookup(const
lookup(name);
lookup(name_,hash(name_));
lookup(vars.binaryVars(),
lookup(vars.doubleVars(),
lookup(vars.generalIntVars(),
lookup,
lookup2.c
lookupa.c,
loop
loops
lost!
low
lower
lower)
lower,
lpReserved
lpsolve3.0
lputs_links();
ls
lsfit1
lsfit2
lsfit2_nr
lsize
lsize)
lsize;
lucky.
m
m)
m,
m,nrl,nrh,
m.ncols())
m.ncols();
m.nrows())
m.nrows();
m1,
m1.ncols();
m1.nrows())
m1.nrows();
m1[i][0]
m1[i][k]
m2)
m2);
m2.ncols()))
m2.ncols());
m2.ncols();
m2.nrows())
m2[0][j];
m2[k][j];
m[0][i]
m[i][0]
m[i][j]
m[j][i]
machine
machines
macro
macro-based
macros
mad(BasicArray<T>&
mad(array,tmparray);
made
main
main()
main(int
maintain
maintains
major
make
makes
making
malloc((size_t)
man
manage
management
management.
manages
manipulates
manipulator
manner
many
map
map_off()
map_on()
mapped
mapping
mapping;
mappings.
maps
marker
masked
masking
masking,
masks
mat)
mat);
mat,
mat.get_matbeg();
mat.get_matcnt();
mat.get_matind();
mat.get_matval();
mat.get_ncols(),
mat.get_nnzero());
mat[0][0];
mat[i][j];
matbeg
matbeg.resize(ncol);
matbeg.resize(ncols);
matbeg.resize(ncols+32);
matbeg.resize(nrow);
matbeg.resize(nrows);
matbeg.resize(nrows+32);
matbeg;
matbeg[cndx]
matbeg[col];
matbeg[j+1];
matbeg[j]
matbeg[j]--;
matbeg[ncols]
matbeg[nrows]
matbeg[rndx]
matbeg[row];
matching
matcnt
matcnt.resize(ncol);
matcnt.resize(ncols);
matcnt.resize(ncols+32);
matcnt.resize(nrow);
matcnt.resize(nrows);
matcnt.resize(nrows+32);
matcnt.size())
matcnt;
matcnt=0;
matcnt[cndx]++;
matcnt[colndx])
matcnt[colndx]--;
matcnt[j+1];
matcnt[j]
matcnt[j])
matcnt[ncols++]
matcnt[nrows++]
matcnt[rndx]++;
matcnt[rowndx]
matcnt[rowndx])
matcnt[rowndx]--;
mathematical
matind
matind.resize(colmajor.nnzeros);
matind.resize(nnzero);
matind.resize(nnzeros+max(count,64));
matind.resize(rowmajor.nnzeros);
matind;
matind[i+1];
matind[i-diff];
matind[i]
matind[matbeg[j]+k]--;
matind[nnzeros]
matmult(Num2DArray<T>&
matmult(NumArray<T>&
matmult(temp_mat,
matmult(temp_vec,
matmult(temp_vec,v,m);
matmult<T>(Num2DArray<T>&
matmult<T>(NumArray<T>&
matrices
matrix
matrix(nrl,nrh,ncl,nch)
matrix,
matrix.
matrix.nrows());
matrix[j][i];
matval
matval.
matval.resize(colmajor.nnzeros);
matval.resize(nnzero);
matval.resize(nnzeros+max(count,64));
matval.resize(rowmajor.nnzeros);
matval.size())
matval;
matval[0];
matval[i+1];
matval[i+i];
matval[i-diff];
matval[i]
matval[nnzeros++]
matval[pt+i];
max
max((Data.size()
max((int)
max((next.size()
max(T
max(const
max(double
max(int
maxArgs
maxArgs)
maxArgs,plural(maxArgs));
maxValue(maxValue_),
maxValue)
maxValue))
maxValue;
maxValue_)
maxValue_);
max_bucket_size(16),
max_bucket_size)
max_bucket_size;
max_load
max_load(3.0),
max_load;
max_ratio
max_ratio(0.75),
max_ratio;
maxdist++;
maximal
maximal=-1
maximization
maximum
maxtype);
may
mdian2.
mean
mean(array);
mean(const
mean(mat);
means
meant
meanval
meanval);
measurements.
measures
mechanism
mechanisms
med
med;
median
median(const
median(double*
median(work);
median.C
median.cpp
mediand
mediand(double*
member
member(element);
member(i);
member(int
member)
memcpy(
memcpy(tmp,buffer,index);
memdebug
memdebug.cpp
memdebug.h
memdebug::last_total(10);
memdebug::last_total.resize(memdebug::num+10);
memdebug::last_total[i]
memdebug::last_total[i];
memdebug::memory_allocated(10);
memdebug::memory_allocated.resize(memdebug::num+10);
memdebug::memory_allocated[i]
memdebug::memory_deleted(10);
memdebug::memory_deleted.resize(memdebug::num+10);
memdebug::n_dels
memdebug::n_dels++;
memdebug::n_news
memdebug::n_news++;
memdebug::name(10);
memdebug::name.resize(memdebug::num+10);
memdebug::name[i]
memdebug::nbytes
memdebug::nbytes;
memdebug::num
memdebug::num)
memdebug::num++;
memdebug::num_del(10);
memdebug::num_del.resize(memdebug::num+10);
memdebug::num_del[i]++;
memdebug::num_new(10);
memdebug::num_new.resize(memdebug::num+10);
memdebug::num_new[i]++;
memdebug::print_summary(os);
memdebug::print_summary(ostream&
memory
memory,
memory.
memory_allocated;
memory_deleted;
memset(
merge_sort
message
message,
message.
messages
messages,
messages.
messy,
method
method,
method.
methods
methods).
methods.
middle
might
mimics
min
min(T
min(const
min(newbytes,Len));
minArgs
minArgs)
minArgs,
minArgs,int
minArgs,plural(minArgs));
minValue(minValue_),
minValue)
minValue;
minValue_,
minValue_,double
min_length
min_length)
minimal
minimal=1,
minimize
minimized.
minimum
minus
minus(const
minus(val,Finite,num.val,num.Finite,val,Finite);
mix
mix()
mix(a,b,c)
mix(a,b,c);
mixc
mixc(a,b,c,d,e,f,g,h)
mixc(a,b,c,d,e,f,g,h);
mixer
mod
mode
mode.
mode;
mode=queueLL;
model
modes
modifiable
modification
modifications
modified
modify
modifying
module
modules
mom=mom+dist[i]*((double)i/100.0-0.8);
more
most
move
moveEffect(AbstractHeapItem*
moveEffect(item);
moveEffect(t);
moveEffect(t1);
moveEffect(t2);
moved
mpASend(PRINT_MARKER_REQUEST,NULL,0,tmp);
mpASend(PRINT_MARKER_RETURN,NULL,0,HOST_NODE);
mpLastProcessor();
mpRecv(PRINT_MARKER_REQUEST,NULL,0);
mpRecv(PRINT_MARKER_RETURN,NULL,0);
mpSend(PRINT_MARKER_REQUEST,NULL,0,HOST_NODE);
mpiActive;
mpiIOP;
mpiUtil.C
mpiUtil.h
mpitype,
msg
msg,
much
much,
mult(const
mult(val,Finite,num.val,num.Finite,val,Finite);
multiline
multiple
multiply
must
my
my_new_handler()
mylen
mylen)
mylen+1;
mylen,
mylen;
n
n)
n));
n);
n,
n--;
n-bit
n/2;
nBinVars=0,
nDblVars=0)
nIntVars=0,
n]
n_dels;
n_news;
name
name(#name,min,default,max)
name(nameBuff)
name(name_),
name(strlen(c++));
name,minValue,value,maxValue);
name,newValue,maxValue);
name,newValue,minValue);
name.
name;
nameBuff)
nameBuff,
name_)
name_);
name_,
name_,double
name_,int
named
named.
names
namespace
nbits
nbits()
nbits,
nbits;
nbuckets++;
nbuckets=0;
nbytes),
nbytes,
nbytes.
nbytes;
nbytes=0,
nch)
nch,
nch,\
nch,nzl,nzh,\
nch,sizeof(double))
nch,sizeof(float))
nch,sizeof(int))
ncl,
ncl,nch,nzl,nzh,\
ncol,
ncols
ncols()
ncols(0),
ncols)
ncols))
ncols);
ncols,
ncols--;
ncols;
ncols=ncol;
ndata
ndata)
ndeep,
ndeep;
ndlbs)
ndlbs);
ndx
ndx)
ndx));
ndx);
ndx++;
ndx,
ndx--;
ndx-th
ndx.size(),
ndx;
ndx=0;
ndx[i]
ndx_vec,
ne
ne++;
necessarily
necessary
need
needed
needed.
needs
neg_flag
neg_flag=false;
negative_infinity;
negative_infinity_val)
negative_infinity_val;
neighbor
nel,
nest
nested
nested).
nested,
new
new(size_t
new(size_t);
new(type)
newLocation
newValue)
newValue);
newValue;
new_BasicArray_double()
new_BasicArray_int()
new_BitArray()
new_CharString()
new_CommonIO()
new_IntVector()
new_Normal(_swigarg0,_swigarg1,_swigarg2)
new_PM_LCG(_swigarg0)
new_RealVector()
new_SimpleArray_double()
new_SimpleArray_int()
new_Triangular(_swigarg0,_swigarg1,_swigarg2)
new_Uniform(_swigarg0,_swigarg1,_swigarg2)
new_array(type,
new_array_len)
new_array_len);
new_ifstream(_swigarg0)
new_ofstream(_swigarg0)
newbytes
newbytes);
newbytes;
newdata
newdata++)
newitem
newitem;
newl)
newl);
newl+1;
newl;
newlen
newlen)
newlen);
newlen,
newlen;
newroot
newroot)
newroot->Key();
newroot->left
newroot->right
newroot->size
newroot;
newsize)
newsize);
newsize;
newsize=-1);
next
next(
next(ListItem<T>*
next(OrderedListItem<T,V>*
next(T*
next)
next->prev
next->prev->next
next->prev;
next.
next.resize(10);
next.resize(curr
next;
next[0]
next[0];
next[Last]
next[curr]
next[curr];
next_free();
nh)
nh,
nice,
nicePrint.C
nicePrint.h
nints,
nl,
nm
nm))
nnzero
nnzero)
nnzero,
nnzeros
nnzeros(0)
nnzeros--;
nnzeros;
nnzeros;}
nnzeros=nnzero;
no
nobjs
nobjs=0;
nobody
node
node,
node.
node;
node_size(l->left);
node_size(newroot->left)
node_size(newroot->right);
node_size(r->right);
node_size(t->left)
node_size(t->left);
node_size(t->right)
node_size(t->right);
node_size(tmp)))
node_size(tmp->left);
node_size(x)
node_size(y->left);
node_size(y->right);
non-ansi
non-standard
non-zero,
non-zeros
nonequal
nonnegative,
nonzeros
norm
normal
normally
not
not-a-number.
note
nothing
notice
notify
now
now!
now,
now...
np
np,nm,ne,j;
nref++;
nref--;
nref;
nrefs()
nregs,
nrh,
nrl,
nrow,
nrows
nrows()
nrows(0),
nrows)
nrows,
nrows,ncols;
nrows--;
nrows;
nrows=1,
nrows=mat.get_nrows();
nrows=nrow;
nsecs
nsecs;
ntmp
ntmp,
null
null,
num
num)
num);
num,
num.Finite);
num.read(is);
num.val
num.write(os);
num;
num=0.0);
num=1);
numAllVars()
numBinaryVars()
numBits+numGenInts+numDoubles;
numBits+numGenInts;
numBits,
numBits;
numBits=0,
numDigits
numDigits;
numDigits=0).
numDigits_)
numDigits_;
numDoubles()
numDoubles)
numDoubles);
numDoubles=0);
numGenInts,
numGenInts=0,
numGeneralIntVars()
numIntegerVars()
numParameters;
numProcs()
num_del;
num_elements;
num_new;
num_refs_limit
num_refs_limit)
num_refs_limit;
number
numberOfStates++;
numberOfStates;
number_of_entries_per)
number_of_entries_per);
number_of_entries_per*MAXTYPES+1;
number_of_entries_per+1;
number_of_types,int
number_of_types;
numerator,
numeric
numerical
numerically
nzh)
nzh,
nzl,
o
o)
o);
o.
o=DataNotOwned)
o=DataNotOwned);
o_stream(0);}
o_stream(1);}
o_stream(const
obj)
obj.read(is);
obj.write(os);
object
object's
object.
object.snortate();
object;
objects
objects,
objects.
occassion
occured.
of
off
offer
offset
offset)
offset;
offset=0);
ofile);
ofstr
ofstr(tmp);
ofstr.close();
ofstr.open(tmp);
ofstream
ofstream(_swigarg0))
ofstream).
ofstream_close(_arg0);
ofstream_close(_swigobj)
ofstream_open(_arg0,_arg1);
ofstream_open(_swigobj,_swigarg0)
old
oldPrecision
oldTree
oldTree[i];
olist
olist)
olist->add(ptr,key);
olist.cpp
olist.next(item);
olist;
on
on)
once
one
only
onto
op
op)
op)\
op,int
op1
open
open();
operate
operates
operation
operations
operations.
operator
operator!=
operator!=((const
operator!=(const
operator%
operator%<T>(const
operator&=
operator&=(BasicArray<T>&
operator&=(BitArrayBase&
operator&=(const
operator()()
operator()(const
operator*
operator*=
operator+
operator+=
operator+=((const
operator+=(char*
operator+=(const
operator,
operator-
operator-=
operator/
operator/=
operator<
operator<(GenericKey<KEY,DATA>&
operator<(const
operator<<
operator<<(BasicArray<T>&
operator<<(LinkedList<T>&
operator<<(OrderedSet<T>&
operator<<(PackBuffer&
operator<<(QueueArray<T>&
operator<<(StackArray<T>&
operator<<(const
operator<<(ostream&
operator<=
operator=
operator=(A<T>&
operator=(const
operator=,
operator==
operator==((const
operator==(GenericKey<KEY,DATA>&
operator==(const
operator>
operator>(GenericKey<KEY,DATA>&
operator>(const
operator>(y,x);
operator>=
operator>=(const
operator>=(y,x);
operator>>
operator>>(LinkedList<T>&
operator>>(OrderedSet<T>&
operator>>(QueueArray<T>&
operator>>(StackArray<T>&
operator>>(UnPackBuffer&
operator>>(istream&
operator[]
operator[](const
operator[](i);
operator[](idx);
opname
optimization
optimized,
option.
optional
options
or
order
order(BasicArray<int>&
order(ndx,
order(ovec,
order(tmp,a);
order,
order.
order_k
order_ki
ordered
ordering
orderx
orderx(ndx.data(),
orderx.
original
originally
orthogonal
os
os)
os);
os,
os;
os;}
ostr
ostr)
ostream
ostream&
ostream*
ostream**
ostream_flush(_arg0);
ostream_flush(_swigobj)
ostream_write(_arg0,_arg1);
ostream_write(ostream
ostreams
ostreams,
other
other(i))
other)
other.size();
otherwise
otherwise.
our
out
outcount,
output
output)
output,
output.
outs()
outs.
outside
outstr)
outstr);
outstr.flush();
outstr;
ovec(v.size());
over
overhead,
override
overriding
own
own(AssumeOwnership),
own;
own=DataNotOwned)
own=DataNotOwned);
own=DataNotOwned;
own_)
own_);
own_;
own_data;
own_flag(0)
own_flag)
own_flag;
own_flag=flag;
own_ptrs;
owned
owned)
ownership
owns
p)
p++)
p,
p-1;
p.
p436
p;
p<(k-1);
pStrCerr;
pStrCout;
pack
pack(const
packSlop(int
packed
packed.
packing
page
pages
pair
pair-wise
pairwise
parallel
param
param->changeCounter
param->changeCounter;
param->changeValue(1);
param->changeValue(convert(buffer,param->name));
param->changeValue(convert(c,name));
param->value
param->value;
param;
param=hashHeader[list];
param=param->next)
param?
paramTable.C
paramTable.H
parameter
parameter(const
parameter*
parameter.
parameter::changeValue(double
parameter::convert(const
parameter::hash(const
parameter::hashHeader[parameter::tableSize];
parameter::lookup(const
parameter::numParameters
parameter::parameter(const
parameter::parseLine(int
parameter::readAll(argc,
parameter::readAll(argc,argv,1,2);
parameter::readAll(int
parameter::readFromFile(const
parameter::~parameter()
parameters
parameters.
params
parseLine(argc,argv,minArgs,maxArgs);
parseLine(int
parsed
part
part,
particular
partition
partition(double*
partition(x,p,n,ws);
parts
pass
passed
passes
passing
path
pc='
pc=c;
pct_full
per
percent)
percent);
perform
performance,
performance.
performed
permited.
pi.
pivoting
pivotting
pivotting.
platform
platforms.
plural(int
plus
plus(const
plus(val,Finite,num.val,num.Finite,val,Finite);
point
point,
point.
pointed
pointer
pointer,
pointer->verbosity(level);
pointer.
pointers
pointers,
pointers.
points
pool
poor
positions
positive
positive_infinity;
positive_infinity_val)
positive_infinity_val;
possible
possible.
possibly
powers
practical
practice,
practice.
pre-compiled
precede
preceded
prepare
prepended
prepending
present
present.
pretty
pretty_print(ostream&
prev
prev->next
prev;
prev_cndx)
prev_cndx=0;
prev_cndx=cndx;
prev_rndx=0;
prev_rndx=rndx;
previous
primarily
prime
primes
principle,
print
printPercent(ostream&
print_dmatrix();
print_dmatrix(double**
print_dvector();
print_dvector(double*
print_farray();
print_farray(float***
print_fmatrix();
print_fmatrix(float**
print_fvector();
print_fvector(float*
print_imatrix();
print_imatrix(int**
print_ivector();
print_ivector(int*
print_links();
print_marker_status
print_marker_status)
print_marker_status=FALSE;
print_summary(ostream&
print_tree(os,d+1,t->left);
print_tree(os,d+1,t->right);
print_tree(ostream&
printed
printing
printing.
prints
private,
private:
probability
probably
problem
problems
process
process,
process.
processed
processes
processing
processor
processor.
processors
processors.
product
product(NumArray<T>&
product<T>(NumArray<T>&
profile_total_bytes_used;
program
programmer
prohibit
project
properly.
protected
protected:
provide
provided
provided.
provides
providing
prunable(AbstractHeapItem*
prune();
pruneEffect(AbstractHeapItem*
pruneEffect(item);
pt
ptemp[128];
ptr
ptr)
ptr->next);
ptr1
ptr1++,
ptr1++;
ptr2
ptr2++)
ptr2++;
ptr;
ptrlen
ptrlen)
ptrlen/2))
ptrlen;
ptrlen=0;
public
public:
published
published.
purify
purpose
purposes,
purposes.
put
put(const
put(i,
put(i,0);
put(i,1);
put(i,2);
put(i,3);
put(i,enum_vals[j]);
put(i,value);
put(i,vec[i]);
put(idx,
pyobj
pyobj;
python_main(int
python_main.cpp
pyutilib
pyutilib.cpp
pyutilib.h
pyutilib_main(argc,
q
q-p+1;
qraux,
qraux[p]
qsort((SORT_VOID*)(array.data()),
qsort((SORT_VOID*)(vec.data()),
qty
qty,
qty[n]
quantities
quantity
quantum(quantumChoice),
quantum;
quantumChoice
quantumChoice)
queue
queue,
queue.
queueLL
queueLL)
queueLL;}
queue_mode()
quick
quick_sort
quickly
quite
qwerty
qwerty;
qwertydata
qwertydata;
qy
qy,
qy[n]
r
r)
r);
r,
r->left
r.
rFinite
rFinite)
rFinite);
r_size
r_size;
rand_partition(double*
rand_partition(x,p,r,ws,drnd);
rand_select(double*
rand_select(x,0,n-1,(n+1)/2,ws,drnd);
rand_select(x,p,q,i,ws,drnd);
rand_select(x,q+1,r,i-k,ws,drnd);
random
randvar,dist[101],mom=0.0;
randvar=(*tb)();
range
rank
rank()
rank(),
rank();
rank(BasicArray<int>&
rank(const
rank(ndx,
rank(ovec.data(),
rank(tmp2,a);
rank,
rank.
rank/count
rank;
rank_vec
rank_vec,
rare,
rarely-used
rather
ratio.
ratio;
rcond
rcond)
rcond,
rcond;
reached
read
read(UnPackBuffer&
read(istream&
read(std::istream&
read:
readAll(int
readFromFile(c);
readFromFile(const
read_common_cin(int
read_dmatrix();
read_dmatrix(double**
read_dvector();
read_dvector(double*
read_fvector();
read_fvector(float*
read_item(is,item);
read_item(istream&
read_ivector();
read_ivector(int*
reading
real
real.h
reason,
reasonable
receive
reciprocal
recovering
recv(void*
recvbuf,int
redirect
redirected.
redirecting
reduce
reduce(&ioProc,&elected,1,MPI_INT,MPI_MIN,0);
reduce(sendbuf,recvbuf,count,datatype,op,0);
reduce(void*
reduceCast(void*
reduction
reduction.
ref(1),
ref--;
ref;
ref=0;
ref_ptrs
ref_ptrs;
ref_ptrs;}
ref_ptrs=0;
ref_ptrs=tmp;
ref_ptrs[--ref];
ref_ptrs[i]
ref_ptrs[i];
ref_ptrs[ref++]
refer
reference
referenced
referenced,
references
references,
referencing
referencing,
reflects
refloatElement(element);
refloatElement(int
regardless
register
regression
rehashing
relatively
release(V*
remains
remove(
remove(AbstractHeapItem*
remove(AbstractSplayTreeItem*
remove(GenericHeapItem<T>*
remove(GenericSplayTreeItem<T>*
remove(ListItem<T>*
remove(OrderedListItem<T,V>*&
remove(SimpleHeapItem<T>*
remove(SimpleSplayTreeItem<T>*
remove(T*&
remove(item,status);
remove(t,status);
removeEffect(AbstractHeapItem*
removeEffect(item);
remove_index
remove_index(i,check_index);
remove_index(int
remove_index)
remove_index);
remove_value
remove_value(int
removed.
removes
removes,
renamed
replace
replaced
replacing
report
repositions
represent
representation
representation.
representations.
represents
reqd.
request
request)
request);
request,
request,MPI_Status*
request,int*
request.
request;
requestFree(&request);
requestFree(MPI_Request*
request_array,
requested
requests
requests.
required
required).
requires
requiring
res
res(mylen);
res,
res.Data;
res.a->Data[i][j]
res.pseudonym(a1,a2);\
res.pseudonym(a1,val);\
res.resize(mat.get_nrows());
res;
res;\
res[i]
res[i][j]
reserved
reset
reset()
reset();
reset(const
reset(i);
reset(idx);
reset_data(BitArrayBase*
reset_data(V*
reset_data(array);
reset_map();
reset_map();}
reseting
resets
residual
resize
resize()
resize();
resize(0);
resize(PackSize(data[0],num));
resize(a1.nrows(),a1.ncols());\
resize(a1.nrows(),a2.ncols());\
resize(a1.size());\
resize(const
resize(curr+next);
resize(len);
resize(ndx);
resize(nrows,ncols);
resize(num*PackSize(data[0],1));
resize(tmp);
resize(tmp+1);
resize(tmp+vec.size());
resize_OK)
resize_OK=true);
resize_flag=false;
resize_flag=true;
resize_ref_ptrs(const
resize_ref_ptrs(ptrlen*2+2);
resize_ref_ptrs(ref);
resized
resized).
resized.
resizes
resizing
resolved
response.
responsible
rest
restart
restmp
restmp[i]
restriction
result
result)
result);
result.
result.put(i,a1(i)
result.size()))
result.size()));
result;
result==MPI_CONGRUENT)
resulting
ret
return
return(
return(((double)
return(*this);
return(0);
return(CPUSeconds()
return(Data);}
return(Len-1);
return(MICROSECONDS*amicclk());
return(MILLISECONDS*mclock());
return(WallClockSeconds()
return(all_seconds());
return(ans);
return(busy);
return(compare(vec)>0);
return(compare(vec)>=0);
return(dclock());
return(elapsed);
return(element);
return(input);
return(output);
return(running);
return(tb.time
return(temp);
return(user_seconds());
return;
return_print_marker()
return_print_marker();
returning
returns
reuse
reversibly.
revisions
rework
right
right(0),
right;}
rndx
rndx)
rndx;
rndx=-1;
rndx=nrows;
rng
rng)
rng);
rng)];
rng,
rng;
rng=&default_rng)
rng=&default_rng);
rng=NULL)
rngtest.cpp
robust
role
root
root)
root.
rooted
rotate
round
round-off
rounded
roundoff
routed
routine
routine,
routine.
routines
routines.
routing
row
row)
row,
row-major
row-th
row.
row/column
rowPosition,
rowPosition[i]
rowPosition[i];
rowlen)
rowlen);
rowlen-matcnt[rowndx];
rowlen.
rowmajor)
rowmajor);
rowmajor.matind[rowmajor.matbeg[j]+rowndx[j]];
rowmajor.matval[rowmajor.matbeg[rndx]+rowndx[rndx]];
rowmajor.ncols;
rowmajor.nnzeros;
rowmajor.nrows;
rowndx(nrows);
rowndx)
rowndx,
rowndx-th
rowndx=0;
rowndx[j]))
rowndx[rndx]++;
rows
rows.
rowscale(*_arg0);
rowscale(Basic2DArray<T>&
rsd
rsd,
rsd[n]
run
running
running()
running(),
running)
running.
running;
rusage
rv,
rval
rval,
rvar=floor((x+delta*randvar)*100.0);
rvec,
rvec.data(),
rvec.size());
s
s)
s->get(c));
s.get(c);
s.pack(Data,Len);
s.t.
s.unpack(Data,
s;
safe.
same
sampleflag)
sampleflag=TRUE)
sanity
satisfied.
scalable
scratch,
script.
search
search.
sec
sec,
seconds
seconds).
seconds.
seconds.C
seconds.cpp
seconds.h
see
seem
seems
seen
sees.
self
self->close();
self->flush();
self->generator(p);
self->operator()();
self->operator()(i);
self->operator[](i)
self->operator[](i);
self;
semantics
send
send(void*
sendbuf,void*
sends
sense()
sense_)
separate
seperate
seperately,
seqNum++;
seqNum;
sequence
serves
set
set()
set();
set(const
set(i);
set(idx);
set)
set);
set){
set,
set.
set.Data[j])
set.first(index
set.next(index
set.read(input);
set.write(output);
setBit(const
setDebug(int
setDouble(const
setGeneralInt(const
setIOFlush(int
setIORank()
setIORank(int
setIORank(x),
setInt(const
setSense(OrderSense
set_cerr
set_cerr(&common_ofstr);
set_cerr(ostream*
set_cin
set_cin(istream*
set_cout(&common_ofstr);
set_cout(ostream*
set_cout,
set_data
set_data()
set_data(T*
set_data(array.size(),array,o);}
set_data(char*
set_data(const
set_data(vec,start,vec.size()-start);}
set_ofile(const
set_ref_limit()
set_ref_limit(const
set_shared_data(
set_shared_data(Data,
set_shared_data(Data,Len,array_len,o);
set_shared_data(Data,Len,o);
set_shared_data(T
set_shared_data(char
set_shared_data(data,
set_streams(ostream*
set_streams,
set_subvec(const
set_sync_print(const
set_up
set_up(int
sets
setting
setup
setup(char*
setup(int
setup(nrow,ncol,nnzero,0);
setup(nrow,ncol,nnzero,1);
setup,
setup_bufexp
share
shared
shared,
shared->acquire(this);
shared->freeze();
shared->ref;
shared->release(this);
shared->set_data(0,0,0,AcquireOwnership);
shared->set_data(0,0,AcquireOwnership);
shared->set_data(d,newbytes,newl,AcquireOwnership);
shared->set_data(d,newl+1,AcquireOwnership);
shared->set_data(d,newl,AcquireOwnership);
shared->set_data(data,len,o);
shared->set_data(data,newlen,array_len_,o);
shared.
shared;
shared=0;
shared_mem()
shared_one(BitArray&
shares
sharing
shell_sort
short
short&
short's
short*
shorter,
should
shouldn't
show_list(int
shuffle
shuffle(*_arg0,_arg1);
shuffle(BasicArray<T>&
shuffle(BitArray&
shuffle(vec,rng);
shuffled
sign
signal,
signalError
signalError(const
signalError.h
signalled.
significant
similar
similar.
similarly
simple
simple,
simplifies
simply
since
single
singular.
sinkDown(element);
sinkDown(int
situations
size
size()
size())
size()-start);}
size();
size();\
size(0)
size)
size))
size);
size,
size;
size;}
size=size_;
sizeOf(MPI_Datatype
size_)
size_,
size_=1024)
size_t
size_t)
size_t);
size_t;
size_type
size_type)
size_type);
size_type;
sizeof(
sizeof(char)
sizeof(double))
sizeof(float))
sizeof(int))
sizeof(size_type)
sizeof(type)*n)
sizes
sizes.
skipped.
slot
slots
slow!).
slow,
smaller
smallest
snortate();
so
so...
software
soln
some
someone
something
somewhat
soon
sooo
sort
sort(BasicArray<T>&
sort(BasicArray<double>&
sort(BasicArray<float>&
sort(BasicArray<int>&
sort(array);
sort(array,
sort.
sort.cpp
sort.h
sort/order
sort/order/rank
sortd(x,n);
sorting
sorting.
sorts
sought
source
source,
space
sparse
sparse,
sparseity
special
special,
specific
specification
specified
specified.
specifies
specifies.
specify
splay
splay(*key);
splay(const
splay(key);
splay(key,t);}
splay(node->Key());
splay(node->Key(),
splay(tmp->Key());
splay,
splayed
splaying
spot
sqrt(
sqrt(ans);
squares
src
src;
stab
stable?
stack
stack,
stack.
stackLL
stackLL;}
stack_mode()
standard
start
start++
start,
start.
start;
start=0)
startEvent
started
starting
startme
startme;
startw
startw;
state
state)
state);
state.
stateNumber
stateNumber)
stateNumber*2;
stateNumber;
state[0]=a;
state[1]=b;
state[2]=c;
state[3]=d;
state[4]=e;
state[5]=f;
state[6]=g;
state[7]=h;
state[i]
statements
statements,
states
static
staticA[5][5]
staticA[i][j];
statistics(ostream&
stats_flag)
status
status)
status);
status,MPI_Datatype
status->MPI_TAG,
status.
status;
status=FALSE;
status=TRUE;
status_array)
std::istream&
std::ostream&
std;
std_#
std_cerr;
std_cin;
std_cout;
stdafx.cpp
stdafx.h
stdafx.obj
stdcerr
stdcin
stdcout
stderr);
stdio
stdlibmpi.h
stdout
stemp
stemp=(sumx/sum)-a;
stltest.cpp
stmt
stmt1
stmt1;
stmt2
stmt2;
stmt;
stmts.
stmts;
stop
stop)
stop);
stop.
stop;
stopped
store
storing
str
str(10);
str)
str);
str,
str.
str.Data)
str.resize(15);
str.resize(5);
str1,
str2)
str2);
str2.Data[i])
str2.Len)
str;
str=(char*)0,
str[0]
str[128];
str[16];
str[i-curr];
str[i]
str[i]);
str[i];
str_flag=FALSE;
strcmp(name_,ptr->name);
stream
stream,
stream,int
stream.
stream.clear();
stream.fill('
stream.fill('-');
stream.get(c);
stream.precision(1);
stream.precision(oldPrecision);
stream.rdbuf();
stream.setf(ios::fixed,ios::floatfield);
stream.unsetf(ios::floatfield);
stream.width(5);
stream.width(n);
stream;
stream_flag;
streams
streams,
streams.
streams;
strictly
string
string,
string.
strings
strings).
strlen(str);
strncpy(Data,buf,ndx+1);
stronger
strongly
strstream
strstream,
strstreams
strtod(str.data(),&ptr);
strtol(str.data(),&ptr,0);
struct
structure
structure.
structures
stuff
stuff;
stupid
subclass
sublist_empty(int
submatrix
subroutines
subsequent
subset
subshuffle(*_arg0,_arg1,_arg2,_arg3);
subshuffle(BasicArray<T>&
substring
subtract
subtree
subtree.
subvector
successfully
such
suffix)
suffix;
suggested
sum
sum(const
sum(double
sum(int
sumx
superscalar
supplanted
supplied)
support
supports
sure
swap(T&
swap(element,child);
swap(element,next);
swap(int
swig_add_builtin()
swig_add_builtin();
swig_add_module(char
swig_add_module(swig_inittab[i].name,
swig_inittab
swig_inittab[i].initfunc);
swig_num_modules
swig_num_modules++;
switch
switch(len)
switched
symbol
symbols
symmetric
symmetrix
sync
sync_io.cpp
sync_print_flag=FALSE;
sync_print_flag=flag;
sync_stdio()
synchronous
syncronizing
syntactic
system
system-dependent
system.
systems
t
t)
t);
t,
t->Key()))
t->Key());
t->Key();
t->ctr++;
t->element=element;
t->left
t->left);
t->left->Key()))
t->left->size
t->left;
t->right
t->right;
t->size
t->size;
t1
t1->element=b;
t1;
t2
t2->element=a;
t2;
t;
t;}
t=0;
table
table(__stl_prime_list[0]),
table(initial_size),
table(utilib_prime_list[0]),
table)
table,
table.
table.add(*tmp);
table.add(tmp);
table.first();
table.len();
table.next(item);
table.read(input);
table.resize(MAXTABLESIZE);
table.resize(tmp);
table.size())
table.size());
table.size()*2;
table.statistics(cout);
table.write(output);
table;
tableSize;
tableSize=101
table[candidate]
table[current]=value;
table[i]
table[index]
table[index])
table[index]);
table[index];
table_size)
table_size);
table_size;
tables
tablesize)
tabsz,
tabu
tag)
tag,MPI_Request*
tag,MPI_Status*
tag,int
tagging
tagging,
tagging.
tagging;
tagging=OFF;}
tagging=ON;}
tail
tail()
taken
takes
taking
taskcommon
tb
tb->set_base(delta,lwr,upr,x);
tb.time
tb;
tdata
temp
temp(matrix.ncols());
temp/(array.size()
temp/array.size()
temp;
temp=0.0;
temp=0;
temp=i;
temp[i]
temp_mat(m1.nrows(),
temp_mat.resize(m1.nrows(),
temp_mat;
temp_vec(m.ncols());
temp_vec(m.nrows());
temp_vec.resize(m.ncols());
temp_vec.resize(m.nrows());
temp_vec;
tempj
tempj;
template
template<>
template<class
terminating
termination
termination.
test(MPI_Request*
test(request,&flag,status);
test(request,&status);
test_a(10);
test_crandvar(&trv,-1.0,1.0,vec,1000000);
test_crandvar(&urv,0.0,1.0,vec,1000000);
test_crandvar(CRandVar*
test_int;
test_triang(&trv,-0.5,1.0,vec,1000000);
test_triang(Triangular*
tested
testing
testsome(int
text,
than
that
that's
that.
the
their
them
then
there
there.
thereby
these
they
this
this)
this,
this.
this:
this;
thoroughly
those.
though
though,
three
through
throw(__EDG_STD_NAMESPACE::bad_alloc)
tieing
time
time.
time_t
timeb
timer
timer)
timer.
times
times(&usage);
timestamp
timestamp.resize(MAXTABLESIZE);
timestamp;
timestamp[current]=expiration;
timing
tkey
tm
tm_str
tm_str->tm_sec
tm_str;
tmp
tmp(10);
tmp)
tmp);
tmp*Sense;
tmp++)
tmp+=
tmp->left;
tmp->right;
tmp->set_data((*this),
tmp->val
tmp->val;
tmp.val;
tmp1(10);
tmp2
tmp2(10);
tmp2;
tmp3(10);
tmp;
tmp;\
tmp;}
tmp=-1;
tmp=0.0;
tmp=0;
tmp=Len;
tmp=key1->compare(key2);
tmp=t;
tmp[256];
tmp[i]
tmp[i];
tmp_array
tmp_array,
tmp_item=NULL;
tmparray(array.size());
tms
tnbuckets+=nobjs;
tnbuckets=0;
to
to.
to/from
together
tol,
too
top
top()
top();
top-down
total
total=0.0;
total=0;
total_free,
total_slots
total_used;
tothe
tracks
trans_flag));
transforms
transpose
transpose_dmatrix(m,
transpose_fmatrix(m,
transpose_imatrix(m,
trashStatus;
treat
tree
tree)
tree,
tree->ctr++;
tree.
tree.)
tree.read(input);
tree.write(output);
tree:
tree;
tree[++used]
tree[1];
tree[a]
tree[a];
tree[b]
tree[b];
tree[element]
tree[element];
tree[i]
tree[n];
tree[used];
treeitem
treeitem->ctr++;
treeitem;
trees
triangular
trimmed
trimmed_mean(BasicArray<T>&
true
true)
true,
true.
true;
trv(&rng);
trv.truncation(EXPECTATION_BALANCED_TRIANGULAR);
trv.truncation(PROBABILITY_BALANCED_TRIANGULAR);
try
trying
tsize
tsize-1;
tsize;
tuple)
turn
turning
tval
tval;
two
two-bit
type
type&
type*
type-checker).
type-equivalency
type.
typeSize;
type_id)
type_id);
type_id,
type_id,int
typedef
typedefs
types
types.
uMPI
uMPI::barrier();
uMPI::broadcast(buffer,numParameters,MPI_DOUBLE,uMPI::ioProc);
uMPI::broadcast(ibuffer,numParameters,MPI_INT,uMPI::ioProc);
uMPI::comm
uMPI::done()
uMPI::done();
uMPI::errorCode
uMPI::iDoIO
uMPI::init(&argc,
uMPI::init(&argc,&argv);
uMPI::init(int*
uMPI::ioProc
uMPI::killRecvRequest(MPI_Request*
uMPI::killSendRequest(MPI_Request*
uMPI::logRecv(MPI_Status*
uMPI::logSend(int
uMPI::rank
uMPI::size
uMPI::sizeOf(MPI_Datatype
ub1*
ub1;
ub4
ub4*
ub4;
ucerr
ucin
ucin.
ucout
ucout,
ucout.
ucout.flush();
ucout/ucerr
ul_reason_for_call,
ultimately
unaligned
unchanged.
undefinedState
under
underlying
unfortunate,
uniformly
unique=FALSE
unless
unmodified
unpack
unpack(bool&
unpack(bool*
unpack(char&
unpack(char*
unpack(double&
unpack(double*
unpack(float&
unpack(float*
unpack(int&
unpack(int*
unpack(long&
unpack(long*
unpack(short&
unpack(short*
unpack(unsigned_char&
unpack(unsigned_char*
unpack(unsigned_int&
unpack(unsigned_int*
unpack(unsigned_long&
unpack(unsigned_long*
unpack(unsigned_short&
unpack(unsigned_short*
unpacked
unpacking
unquoted
unsigned
unsigned_char
unsigned_char&
unsigned_char*
unsigned_char;
unsigned_int
unsigned_int&
unsigned_int*
unsigned_int;
unsigned_long
unsigned_long&
unsigned_long*
unsigned_long;
unsigned_short
unsigned_short&
unsigned_short*
unsigned_short;
unspecified
unsupported
until
unused
unused->next;
unused;
unused=NULL;
up
up!
up.
update
update(OrderedListItem<T,V>*
update_refs()
update_refs();
updated
updating
upon
upper
upper)
upper,
upr=1.0,lwr=0.0,delta,x=0.8;
urnd(i,end-1);
urnd(rng);
urv(&rng);
usage
usage.ru_stime.tv_sec
usage.ru_stime.tv_usec;
usage.ru_utime.tv_sec
usage.ru_utime.tv_usec
usage;
use
use.
usec
usec;
used
used!
used(0),
used)
used))
used,
used--;
used.
used;
useful
useful.
user
user-defined
user-provided
user-supplied
user.
users
uses
using
using_prime_ht(true),
using_prime_ht;
utilib.cpp
utilib.pch
utilib/src/io/paramTable.doc.
utilib_dll.h
utilib_num_primes
utilib_num_primes)
utilib_num_primes;
utilib_prime_list[]
utilib_prime_list[];
utilib_prime_list[i];
utilib_wrap.c
utilibcMethods[]
utilities
utility???
utilizes
v)
v));
v);
v,
v,nl,nh,sizeof(double))
v,nl,nh,sizeof(float))
v,nl,nh,sizeof(int))
v,nrl,nrh,
v,nrl,nrh,ncl,
v.size())
v.size();
v1,
v1[i]*v2[i];
v2)
v[0];
v[j];
val
val(num),
val)
val))
val);
val)\
val++,
val,
val->key());}
val.
val.size())
val1(_val1)
val1);}
val1;
val1;}
val2(_val2)
val2));}
val2;
val3(_val3)
val3));}
val3;
val4(_val4)
val4));}
val4;
val5(_val5)
val5));}
val5;
val6(_val6)
val6));}
val6;
val7(_val7)
val7));}
val7;
val;
val;\
val[j];
vals)/(table.size())
vals)/(table.size()*max_bucket_size)
value
value(value_),
value)
value))
value);
value,
value,int
value.
value;
value[i];
value_,
value_,double
values
values,
values.
var
var(const
var(mat,
variable
variable-length
variable.
variables
variables,
variables.
variance
variances
variety
vars)
vars.nGeneralIntVars()*sizeof(int),
vars.ndoubleVars()*sizeof(double),
vars.read(buff);
vars.write(buff);
vec
vec(101);
vec(20);
vec(j);
vec)
vec);
vec,
vec.
vec.put(i,tempj);
vec.put(j,vec(i));
vec.resize(21);
vec.size())
vec.size(),
vec.size()-1);
vec=0;
vec[(int)((tmp-lower)/(upper-lower)*vec.size())]++;
vec[*col]
vec[ans]
vec[argmax(vec)];
vec[argmedian(vec)];
vec[argmin(vec)];
vec[i-tmp];
vec[i]
vec[i])
vec[i]);
vec[i];
vec[j]
vec[j];
vectest.cpp
vector
vector!
vector(nl,nh)
vector)
vector,
vector.size(),
vector<int>
vector[temp])
vector\matrix
vectors
vectors.
verbosity
verbosity()
verbosity(const
verbosity(dlevel)
verbosity(int
version
versions.
very
via
virtual
virtually
visible
visualizer
void
void*
w,
wait(MPI_Request*
wait(request,&trashStatus);
waits
wall
wall-clock
wallclock
wallclock)/((double)
warning
warranty.
was
wastage
way
we
we're
well
well-suited
were
what
when
where
whether
whetner
which
while
while(!(s->eof()))
while((found_index
while((table[i]
while(*name_)
while(*ptr1)
while(1)
while(candidate
while(fgetc(stdin)
while(table[i]
whitespace
whitespace(istream&
whitespace,
whitespace.
whitespace;
whole
whose
widely
width,
will
windows
wish,
wish.
with
within
without
work
work!
work)
work,
work[i]
work[p]
worked.
works
workspace
world_rank)
world_rank;
worrying
would
would.
wrappers
wraps
write(*olist);
write(OrderedList<void*,double>&
write(PackBuffer&
write(ostream&
write(std::ostream&
write_item(os,member(i));
write_item(os,node);
write_item(ostream&
writing
ws
ws(101);
ws)
ws,
ws.data(),
ws;
ws[i]
ws[i];
ws[j]
ws[j];
ws[p]
ws[p];
x
x)
x));
x);
x,
x->right
x->size
x.
x.Finite,
x.size(),
x.size();
x;
x=10.0;
xFinite
xFinite,
x[0];
x[argmedian(x,n,
x[i]
x[med];
x[n,p]
x[n/2];
x[ws[--j]]);
x[ws[p]];
x[xm_ndx]
x[xm_ndx]))
x[xm_ndx]+stemp*AMP;
x[xp_ndx]
x[xp_ndx]))
x[xp_ndx]+stemp*AMP;
xb
xb,
xb[n]
xm_ndx
xm_ndx);
xm_ndx,
xm_ndx;
xm_ndx=j;
xmax));
xmin,
xor
xp_ndx
xp_ndx;
xp_ndx=j;
xval
xval*yval;
xval,
xval;
xx
xx*dum;
xx,sumx,sum,eps,stemp,dum,aa;
xx=x[j];
y
y)
y));
y);
y,
y->left
y->left)
y->left;
y->right
y->right)
y->right;
y->size
y.
y.Finite,
y.size())
y.size()));
y.val);
y.val,
y;
yFinite
yFinite,
y[i];
y[n]
yes
you
you're
your
yourself.
yval
yval,
yval;
z
z);
z.
zero
zero.
ztmp;
{
{((GenericHeapItem<T>*)item)->Key->write(output);}
{//
{10,
{12,
{;}
{AbstractSplayTree::splay(&key);}
{Basic2DArray<T>::operator=(array);
{Basic2DArray<T>::operator=(val);
{BasicArray<T>::operator=(array);
{BasicArray<T>::operator=(val);
{Data.resize(Len);
{IOflush();
{Key->write(os);}
{Keyptr->write(os);}
{Len=0;
{Sense=sense_;}
{Simple2DArray<T>::operator=(array);
{SimpleArray<T>::operator=(array);
{Tuple1<T1>::write(os);os
{Tuple2<T1,T2>::write(os);os
{Tuple3<T1,T2,T3>::write(os);os
{Tuple4<T1,T2,T3,T4>::write(os);os
{Tuple5<T1,T2,T3,T4,T5>::write(os);os
{Tuple6<T1,T2,T3,T4,T5,T6>::write(os);os
{Warning(str);
{\
{array_len=0;}
{buff.pack(data);
{buff.unpack(data);
{cmd;
{construct(0,(T*)NULL,DataNotOwned);}
{construct(0,0,(T*)0);}
{construct(0,0,0);}
{construct(array.a->Nrows,array.a->Ncols,array.a->Data,
{construct(array.array_len,array.Len,
{construct(array.nrows(),array.ncols(),array.data(),
{construct(array.size(),
{construct(len,
{construct(len,nbytes,d,o);}
{construct(mylen,d,o);}
{construct(nrows,array.size()/nrows,array,own);}
{construct(nrows,ncols,array,own);}
{construct(nrows,ncols,d,own);}
{data
{double
{extract(first,data,key);}
{extract(item);}
{extract(item,data);}
{extract(item,data,key);}
{find(key);
{flush();
{for
{free();}
{if
{index=0;
{index=0;}
{insert(&key);}
{insert((const
{insert(data,key);}
{insert(key);}
{ios::sync_with_stdio();}
{is
{item
{item->element=0;}
{key
{key.read(is);
{key.write(os);
{key_ptr->write(os);}
{list.add(data);
{list.add(val);
{list.remove(data);
{list.remove(val);
{mode
{next
{num_elements=0;}
{num_elements=1;}
{num_elements=2;}
{num_elements=3;}
{num_elements=4;}
{num_elements=5;}
{num_elements=6;}
{num_elements=7;}
{os
{output
{own=DataNotOwned;
{pack(&data);}
{ref=1;
{return
{setup(0,0,0);}
{setup(buf_,size_,flag);}
{setup(new
{setup(nrow,ncol,nnzero,0);}
{setup(nrow,ncol,nnzero,1);}
{shuffle(vec,rng,vec.size());}
{stmt;}
{t
{unpack(&data);}
{val
{}
|
|=
|y
||
}
};
~(char)(1
~AbstractHashTable()
~AbstractHeap();
~AbstractSplayTree()
~ArrayRef()
~Basic2DArray()
~Basic3DArray()
~BasicArray()
~BitArrayBase()
~CMSparseMatrix()
~ClassRef()
~CommonIO();
~GenericHeap();
~GenericSplayTree();
~LinkedList();
~MixedIntVars()
~MultiLL();
~NumArray()
~OrderedList();
~OrderedSet()
~PackBuffer()
~QueueArray()
~RMSparseMatrix()
~SimpleArray()
~SimpleHeap();
~SimpleSplayTree();
~SimpleSplayTreeItem()
~SparseMatrix()
~StackArray()
~UnPackBuffer()
~parameter();

